AAABABBBBAABBBB

Let c ( n ) be the number of phrases created from input of length n . Let α be the size of the alphabet of characters in input. Length of output is c ( n )(log 2 c ( n ) + log 2 α ) bits.

| A | AA | B | AB | BB | BA | ABB | BB

Each phrase is the shortest string not already a phrase. The 0th phrase is ∅ . ▶ Output i c for each phrase w , where c is the last character of w and i is the index of phrase u where w = u ◦ c 1 2 3 4 5 6 7 8 A AA B AB BB BA ABB BB 0 A 1 A 0 B 1 B 3 B 3 A 4 B 5 00 10 001 011 0111 0110 1001 111 Let c ( n ) be the number of phrases created from input of length n . Let α be the size of the alphabet of characters in input. Length of output is c ( n )(log 2 c ( n ) + log 2 α ) bits.

How do we show LZ78 is a good compressor? Empirical Try it on lots of inputs. Worst case? Average case? Something else?

Maximize c ( n ) (make many small phrases)

The smallest input with all phrases of lengths 1 , 2 , . . . , k has length n k = k j =1 j 2 j = ( k − 1)2 k +1 + 2 For such an input, c ( n k ) = ki =1 2 i = 2 k +1 − 2, so c ( n k ) ≤ n k k − 1 .

c ( n ) ❶ ≤ n k k − 1 + n − n k k + 1 ≤ n k − 1 ❷ ≤ n log 2 c ( n ) − 3 since ❶ to maximize c ( n ), the first n k input bits make ≤ c ( n k ) phrases and the rest make phrases of length k + 1, and ❷ c ( n ) ≤ c ( n k +1 ) = 2 k +2 − 2. As we saw, LZ78 compresses inputs of length n to about

Alphabet = { a 1 , a 2 , . . . , a α } Create input x = a x (1) a x (2) . . . a x ( n ) by choosing n characters at random, where a i is chosen with probability p i . Let Q ( x ) = ni =1 p x ( i ) be the probability of input x . If LZ78 breaks x into distinct phrases x = y 1 y 2 . . . y c ( n ) then Q ( x ) = c ( n ) j =1 Q ( y j ) = ℓ | y i | = ℓ Q ( y i ) Let c ℓ be the number of phrases of length ℓ . Since the y i ’s with length ℓ are distinct | y i | = ℓ Q ( y i ) ≤ 1 and | y i | = ℓ Q ( y i ) ≤ 1 c ℓ c ℓ take log sum over ℓ − log 2 Q ( x ) ≥ ℓ c ℓ log 2 c ℓ x (1 − x )

Average case continued Q ( x ) = i p n i i where n i = # a i in x ≈ np i ℓ c ℓ log 2 c ℓ ≤ − log 2 Q ( x ) ≈ np i log 2 (1 / p i ) = nH ( X ) where X is a random character. Recall, LZ78 compresses to approx c ( n ) log 2 c ( n ) bits. If this is approx ℓ c ℓ log 2 c ℓ then LZ78 compresses (nearly) optimally [Source Coding Theorem]. In fact, nH ( X ) ≥ − log 2 Q ( x ) ≥ c ( n ) log 2 c ( n ) − O (log 2 ( n c ( n )))

A # B C a / a / 0 b / 1 1 1 b / 10 a / 0 b / 1 # /10 #/0 #/11 input T Output a # 0 aa # 010 output of M uniquely determines input T . Show all FSC with s states can’t compress better than r

A # B C a / a / 0 b / 1 1 1 b / 10 a / 0 b / 1 # /10 #/0 #/11

If two phrases x and y cause the same output going from A to B then M outputs the same encoding for wx # ̸ = wy #, where w takes M to state A . Assume c j = s 2 2 j for all j ≤ k i.e. use max number of short codes. c ( T ) = k j =0 c j ≤ s 2 k j =0 2 j = s 2 (2 k +1 − 1) Total length of encoding by M : | M ( T ) | ≥ k j =0 jc j = s 2 k j =0 j 2 j = s 2 (( k − 1)2 k +1 + 2) = r s ( T )

| LZ78( T ) | ≤ c ( T ) log 2 c ( T )