CPSC 420 Lecture 16: Today’s announcements:
▶ Examlet 2 on Feb 17 in class. Closed book & no notes
▶ Reading: Shor’s notes on Lempel-Ziv compression https:
//math.mit.edu/~shor/PAM/lempel_ziv_notes.pdf
Today’s Plan
▶ Compression
▶ Huffman Coding
▶ Lempel-Ziv Compression
1 / 9

Compression [Lempel & Ziv 1978]
AAABABBBBAABBBB
▶ Parse input into distinct phrases reading from left to right.
Each phrase is the shortest string not already a phrase.
The 0th phrase is ∅.
▶ Output i c for each phrase w, where c is the last character of
w and i is the index of phrase u where w = u ◦ c
Let c(n) be the number of phrases created from input of length n.
Let α be the size of the alphabet of characters in input.
Length of output is c(n)(log2 c(n) + log2 α) bits.
2 / 9

Compression [Lempel & Ziv 1978]
|A|AA|B|AB|BB|BA|ABB|BB
▶ Parse input into distinct phrases reading from left to right.
Each phrase is the shortest string not already a phrase.
The 0th phrase is ∅.
▶ Output i c for each phrase w, where c is the last character of
w and i is the index of phrase u where w = u ◦ c
1
2
3
4
5
6
7
8
A
AA
B
AB
BB
BA
ABB
BB
0A
1A
0B
1B
3B
3A
4B
5
00
10
001
011
0111
0110
1001
111
Let c(n) be the number of phrases created from input of length n.
Let α be the size of the alphabet of characters in input.
Length of output is c(n)(log2 c(n) + log2 α) bits.
2 / 9

Compression [Lempel & Ziv 1978]
How do we show LZ78 is a good compressor?
Empirical Try it on lots of inputs.
Worst case? Average case? Something else?
Worst case
c(n) = #phrases
α = |alphabet| (assume α = 2)
Maximize c(n) (make many small phrases)
A|B|AA|AB|BA|BB|...
The smallest input with all phrases of lengths 1, 2, . . . , k has length
nk =
k
�
j=1
j2j = (k − 1)2k+1 + 2
For such an input, c(nk) = �k
i=1 2i = 2k+1 − 2, so c(nk) ≤
nk
k−1.
3 / 9

Compression [Lempel & Ziv 1978]
Worst case continued
In fact, for all n between nk and nk+1,
c(n)
≤❶
nk
k − 1 + n − nk
k + 1 ≤
n
k − 1
≤❷
n
log2 c(n) − 3
since ❶ to maximize c(n), the first nk input bits make ≤ c(nk)
phrases and the rest make phrases of length k + 1, and
❷ c(n) ≤ c(nk+1) = 2k+2 − 2.
As we saw, LZ78 compresses inputs of length n to about
c(n) log2 c(n) + c(n) ≤ n +
4n
log2 c(n) − 3 = n + O(
n
log2 n) bits.
Is this good?
4 / 9

Compression [Lempel & Ziv 1978]
Average case
Alphabet = {a1, a2, . . . , aα}
Create input x = ax(1)ax(2) . . . ax(n) by choosing n characters at
random, where ai is chosen with probability pi.
Let Q(x) = �n
i=1 px(i) be the probability of input x.
If LZ78 breaks x into distinct phrases x = y1y2 . . . yc(n) then
Q(x) =
c(n)
�
j=1
Q(yj) =
�
ℓ
�
|yi|=ℓ
Q(yi)
Let cℓ be the number of phrases of length ℓ.
Since the yi’s with length ℓ are distinct �
|yi|=ℓ Q(yi) ≤ 1 and
�
|yi|=ℓ
Q(yi) ≤
� 1
cℓ
�cℓ
take log
sum over ℓ
− log2 Q(x) ≥
�
ℓ
cℓ log2 cℓ
x(1 − x)
5 / 9

Compression [Lempel & Ziv 1978]
Average case continued Q(x) = �
i pni
i
where ni = #ai in x ≈ npi
�
ℓ
cℓ log2 cℓ ≤ − log2 Q(x) ≈ npi log2(1/pi) = nH(X)
where X is a random character.
Recall, LZ78 compresses to approx c(n) log2 c(n) bits. If this is
approx �
ℓ cℓ log2 cℓ then LZ78 compresses (nearly) optimally
[Source Coding Theorem].
In fact,
nH(X) ≥ − log2 Q(x) ≥ c(n) log2 c(n) − O(log2( n
c(n)))
6 / 9

Compression [Lempel & Ziv 1978]
As good as any finite state compressor
Every text has an algorithm that compresses it well, but the
algorithm is as big as the text.
A finite state compressor is a finite state machine with output
strings on transitions.
A
#
B
C
a/
a/0
b/111
b/10
a/0
b/1
#/10
#/0
#/11
input T
Output
a#
0
aa#
010
Require: output of M uniquely determines input T.
1. Show all FSC with s states can’t compress better than rs(T)
2. Show |LZ78(T)| ≤ rs(T) + o(|T|)
7 / 9

Compression [Lempel & Ziv 1978]
As good as FSC continued
Let c(T) = max number of distinct phrases T can be split into.
Let cj = #phrases that cause M to output j bits starting from
some state in M.
cj ≤ s22j since [A, j-bit code, B] uniquely specifies phrase x, where
A is state when M starts reading x and B is state when it stops.
If two phrases x and y cause the same output going from A to B then M
outputs the same encoding for wx# ̸= wy#, where w takes M to state A.
Assume cj = s22j for all j ≤ k
i.e. use max number of short codes.
c(T) =
k
�
j=0
cj ≤ s2
k
�
j=0
2j = s2(2k+1 − 1)
Total length of encoding by M:
|M(T)| ≥
k
�
j=0
jcj = s2
k
�
j=0
j2j = s2((k − 1)2k+1 + 2) = rs(T)
8 / 9

Compression [Lempel & Ziv 1978]
As good as FSC continued
From before
|LZ78(T)| ≤ c(T) log2 c(T)
and
rs(T) = s2((k − 1)2k+1 + 2) ≥ (c(T) + s2) log2(c(T)
4s2 )
So
|LZ78(T)| ≤ rs(T)+2c(T) − s2 log2 c(T) + (c(T) + s2) log2(4s2)
�
��
�
this is o(|T|)
9 / 9