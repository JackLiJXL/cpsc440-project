CPSC 420 Lecture 2 : Today’s announcements:
▶ HW1 available on Gradescope, due Jan 19, 23:59
▶ Examlet 1 on Jan 27 in class.
Today’s Plan
▶ Convex hulls
▶ Jarvis March
▶ Graham’s Scan
▶ Optimal?
1 / 10

Polygon
A polygon is a circular sequence of line seg-
ments in the plane joined end-to-end.
(Each
segment endpoint is the endpoint of two adja-
cent segments in the sequence.)
A polygon is simple if the segments don’t in-
tersect in a non-endpoint.
The convex hull of a finite point set P is a simple
polygon.
2 / 10

Jarvis March (Gift-wrapping)
Idea: Tie a string to a point p1 ∈ P
that is on the CH(P). Rotate a taut
string around the points until it ”bends”
at the next point on CH(P). Keep go-
ing until back to p1.
Turn test
Path a → b → c makes a left turn at b iff
det


ax
ay
1
bx
by
1
cx
cy
1

 > 0
axby − aybx + aycx − axcy + bxcy − cxby > 0
How do we use LeftTurn(a,b,c) to wrap?
3 / 10

Jarvis March Algorithm
4 / 10

Jarvis March Algorithm
INPUT: P[0...n-1] array of 2D points
OUTPUT: Array of convex hull vertices in ccw order.
If n < 3 return distinct points in P
a0 = index of point with min y-coord in P
h = 0, a = a0, b = (any index not a0) mod n
while b != a0
for c = 0 to n-1
if (c != a and c != b and
not LeftTurn(P[a],P[b],P[c])) then
b = c
H[h++] = P[b], a = b
return H
Running time: O(nh) where h is number of vertices of convex hull.
5 / 10

Graham’s Scan
1. Find point p1 in P with smallest y-coord (break ties using
smaller x-coord)
2. Sort remaining points in P by ccw angle around p1. Let
p2, p3, . . . , pn be these points in order. (What about ties?)
3. Start with p1p2p3 as candidate hull. Put them on a stack S.
4.
for i = 4 to n
while not LeftTurn(S[top-1], S[top], pi)
pop(S)
push pi onto S
return S
6 / 10

Graham’s Scan Run Time
1. Finding p1 takes
time
2. Sorting by angle takes
time
3. Put p1p2p3 on a stack S takes
time
4.
for i = 4 to n
while not LeftTurn(S[top-1], S[top], pi)
pop(S)
push pi onto S
return S
One iteration of for-loop causes < n pops ⇒
time
But, over all iterations, #pushes < n and #pops < #pushes
So total time taken by for-loop is
7 / 10

Faster Convex Hull?
Is this the fastest algorithm for Convex Hull?
How powerful is our computer?
▶ It can multiply, add, subtract, compare two real numbers in
one step.
▶ It cannot wrap a string around n objects in linear time.
Is this the fastest algorithm using an Algebraic Decision Tree
model computer for Convex Hull?
8 / 10

Faster Convex Hull?
Suppose there exists a really fast Convex Hull algorithm.
CH Alg.
Input
pts P
Output
CH(P)
9 / 10

Faster Convex Hull?
Suppose there exists a really fast Convex Hull algorithm.
CH Alg.
Input
pts P
Output
CH(P)
Transform
Input
Input to
Sort
x1, . . . , xn
Transform
Output
Output
Create an alg. that transforms
an input to the sorting problem
into an input to CH problem...
Make this really fast.
and then transform CH
output into the answer to
the sorting problem.
Make this really fast.
let CH Alg. do all
the hard work...
Sorted
x1, . . . , xn
9 / 10

Faster Convex Hull?
Suppose there exists a really fast Convex Hull algorithm.
CH Alg.
Input
pts P
Output
CH(P)
Transform
Input
Input to
Sort
x1, . . . , xn
Transform
Output
Output
Create an alg. that transforms
an input to the sorting problem
into an input to CH problem...
Make this really fast.
and then transform CH
output into the answer to
the sorting problem.
Make this really fast.
let CH Alg. do all
the hard work...
Sorted
x1, . . . , xn
x3 x4 x1 x5 x2
xi → (xi, x2
i )
for all i:
Find hull pt w/ min x-coord
Output x-coords in ccw order
Transform Input
Transform Output
9 / 10

Why did we do this?
We already have good algorithms for sorting. Why make this
complicated sorting algorithm?
10 / 10

Why did we do this?
We already have good algorithms for sorting. Why make this
complicated sorting algorithm?
Because we know Sorting complexity is Ω(n log n).
(i.e. fastest alg. for sorting takes ≥ cn log n steps for large n)
We’ve just constructed a sorting algorithm that takes time
T(n) = TI(n) + TCH(n) + TO(n)
We know T(n) ≥ cn log n (sorting complexity).
We know TI(n) ≤ cIn and TO(n) ≤ cOn for some constants cI and
cO (from the input and output transformations).
That means (since TCH(n) = T(n) − TI(n) − TO(n))
TCH(n) ≥ cn log n − cIn − cOn ∈ Ω(n log n).
This holds for any convex hull algorithm, so the complexity of
convex hull is Ω(n log n).
10 / 10