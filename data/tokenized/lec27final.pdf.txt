of MTF and OPT after find( s i ). a b c d e b d a e c φ ( i ) = 4 OPT MTF Let c i ( A ) be the cost of A on find( s i ). We first show that c i (MTF) + ϕ ( i ) − ϕ ( i − 1) ≤ 2 c i (OPT) − 1.

OPT s i s i MTF A B C D φ ( i ) − φ ( i − 1) = k − k j

OPT s i s i MTF A B C D OPT s i s i MTF A B C D ⇒ k matches from A to C e
 matches from B to C φ ( i ) − φ ( i − 1) = k − k k s i j j 1. c i (MTF) = k + ℓ + 1 2. ϕ ( i ) − ϕ ( i − 1) = k − ℓ 3. c i (OPT) = j + P ( i ) ≥ k + 1 + P ( i ) where P ( i ) is #paid swaps by OPT on i th find. 4. Each of P ( i ) paid swaps increases ϕ ( i ) by ≤ 1. So c i (MTF) + [ ϕ ( i ) − ϕ ( i − 1)] ≤ k + ℓ + 1 + [ k − ℓ + P ( i )]

) paid swaps increases ϕ ( i ) by ≤ 1. i ) − ϕ ( i − 1)] ≤ k + ℓ + 1 + [ k − ℓ + P ( i )] = 2 k + 1 + P ( i ) ≤ 2 c i (OPT) − 1

Sum over all i to get: cost(MTF) + o>
 mi =1 [ ϕ ( i ) − ϕ ( i − 1)] = m i =1 ( c i (MTF) + [ ϕ ( i ) − ϕ ( i − 1)]) ≤ m i =1 (2 c i (OPT) − 1) = 2cost(OPT) − m ≤ 2cost(OPT) Since mi =1 [ ϕ ( i ) − ϕ ( i − 1)] = ϕ ( m ) − ϕ (0) ≥ 0, we’re done.

A hash function maps keys from a universe U = { 0 , 1 , . . . , u − 1 } of possible keys to a slot (index from 0 to m − 1) in a hash table (array) of size m .

What’s a good hash function?

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

No two keys map to the same slot?

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

No two keys map to the same slot? Impossible! | U | / m must hash to the same slot.

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

A hash function maps keys from a universe U = { 0 , 1 , of possible keys to a slot (index from 0 to m − 1) in a (array) of size m .

What’s a good hash function?

A family of hash functions H (that map U → { 0 , 1 , . . . , m − 1 } ) is universal if for all distinct keys x , y ∈ U Pr h ∈ H [ h ( x ) = h ( y )] ≤ 1 m . Example Let h a , b ( x ) = (( ax + b ) mod p ) mod m where p is a prime bigger than any key. H = h a , b | a ∈ { 1 , 2 , . . . , p − 1 } , b ∈ { 0 , 1 , . . . , p − 1 }

Let h a , b ( x ) = (( ax + b ) mod p ) mod m where p is a prime bigger than any key. H = h a , b | a ∈ { 1 , 2 , . . . , p − 1 } , b ∈ { 0 , 1 , . . . , p − 1 } Theorem: H is universal Proof: Choose any x ̸ = y . Let r = ( ax + b ) mod p and s = ( ay + b ) mod p . 1. r ̸ = s since x ̸ = y ⇔ x ̸ = y (mod p ) a ̸ =0 ⇔ p prime ax ̸ = ay (mod p ) ⇔ r ̸ = s 2. For x ̸ = y , every pair ( a , b ) gives different ( r , s ) with r ̸ = s since we can solve for ( a , b ) given ( r , s ) . #( a , b ) pairs = #( r , s ) pairs = p ( p − 1) so choosing ( a , b ) uniformly at random yields uniform random ( r , s ). For a given value of r , of the p − 1 possible values of s (since

For a given value of r , of the p − 1 possible values of s (since s ̸ = r ), how many have s = r (mod m )? 0 m − 1 1 2 r mod m At most ⌈ pm ⌉ values s from 0 , 1 , . . . , p − 1 hit this spot; minus 1 since s ̸ = r (and r does hit this spot). Thus, 3. Pr h ∈ H [ h ( x ) = h ( y )] = Pr a , b [ r = s (mod m )] ≤ ⌈ p / m ⌉− 1 p − 1 ≤ ( p − 1) / m = 1