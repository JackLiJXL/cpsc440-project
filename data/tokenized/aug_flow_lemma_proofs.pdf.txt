Navigating Central Path with Electrical Flows: from Flows to Matchings, and Back (Preliminary draft)

aleksander.madry@epﬂ.ch

Abstract

We present an oO
 O ( m 107 ) = O ( m 1 . 43 ) -time 1 algorithm for the maximum s - t ﬂow and the minimum s - t cut problems in directed graphs with unit capacities. This is the ﬁrst improvement over the sparse-graph case of the long-standing O ( m min {√ m, n 2 / 3 } ) running time bound due to Even and Tarjan [ET75] and Karzanov [Kar73]. By well-known reductions, this also establishes an O ( m 107 ) -time algorithm for the maximum-cardinality bipartite matching problem. That, in turn, gives an improvement over the celebrated O ( m √ n ) running time bound of Hopcroft and Karp [HK73] and Karzanov [Kar73] whenever the input graph is suﬃciently sparse.

At a very high level, our results stem from acquiring a deeper understanding of interior-point methods – a powerful tool in convex optimization – in the context of ﬂow problems, as well as, utilizing certain interplay between maximum ﬂows and bipartite matchings.

The core of our approach comprises a primal-dual algorithm for (near-)perfect bipartite b - matching problem. This algorithm is inspired by path-following interior-point methods and employs electrical ﬂow computations to gradually improve the quality of maintained solution by advancing it toward (near-)optimality along so-called central path. To analyze this process, we establish a formal connection that ties its convergence rate to the structure of corresponding electrical ﬂows. Then, we exploit that connection to obtain a convergence guarantee for our algorithm that improves upon the well-known barrier of Ω( √ m ) iterations corresponding to the generic worst-case performance bounds for interior-point-method-based algorithms. This improvement is based on reﬁning certain insights into behavior of electrical ﬂows that stem from the work of Christiano et al. [CKM + 11] and combining them with a new technique for preconditioning primal-dual solutions.

The ﬁnal ingredient of our approach is a simple reduction of the maximum s - t ﬂow problem to the bipartite b -matching problem. This reduction is then composed with the recent sub- linear-time algorithm for ﬁnding perfect matchings in regular graphs of Goel et al. [GKK10], to derive an eﬃcient procedure for rounding fractional s - t ﬂows and bipartite matchings.

∗ Part of this work was done when the author was with Microsoft Research New England. 1 We recall that O ( f ) denotes O ( f log c f ) , for some constant c .

Introduction

The maximum s - t ﬂow problem and its dual, the minimum s - t cut problem, are two of the most fun- damental and extensively studied graph problems in combinatorial optimization [Sch03, AMO93]. They have a wide range of applications (see [AMOR95]), are often used as subroutines in other algorithms (see, e.g., [AHK12, She09]), and a number of other important problems – e.g., bipartite matching problem [CLRS09] – can be reduced to them. Furthermore, these two problems were often a testbed for development of fundamental algorithmic tools and concepts. Most prominently, the Max-Flow Min-Cut theorem [EFS56, FF56] constitutes the prototypical primal-dual relation.

Several decades of extensive work resulted in a number of developments on these problems (see Goldberg and Rao [GR98] for an overview) and many of their generalizations and special cases. Still, despite all this eﬀort, the basic problem of computing maximum s - t ﬂow and minimum s - t cut in general graphs has resisted progress for a long time. In particular, the current best running time bound of O ( m min { m 12 , n 23 } log( n 2 /m ) log U ) (with U denoting the largest integer arc capacity) was established over 15 years ago in a breakthrough paper by Goldberg and Rao [GR98] and this 1 2

bound, in turn, matches the O ( m min { m 2 , n 3 } ) bound for unit-capacity graphs that Even Tarjan [ET75] – and, independently, Karzanov [Kar73] – put forth over 35 years ago.

Recently, however, important progress was made in the context of undirected graphs. Christiano et al. [CKM + 11] developed an algorithm that allows one to compute a (1+ ε ) -approximation to the undirected maximum s - t ﬂow (and the minimum s - t cut) problem in O ( mn 13 ε − 11 / 3 ) time. Their result relies on devising a new approach to the problem that combines electrical ﬂow computations with multiplicative weights update method (see [AHK12]). Later, Lee et al. [LRS13] presented a quite diﬀerent – but still electrical-ﬂow-based – algorithm that employs purely gradient-descent- type view to obtain an O ( mn 1 / 3 ε − 2 / 3 ) -time (1 + ε ) -approximation for the case of unit capacities. Finally, very recently, this line of work was culminated by Sherman [She13] and Kelner et al. [KLOS13] who independently showed how to integrate non-Euclidean gradient-descent methods with fast poly-logarithmic-approximation algorithms for cut problems of Mądry [Mąd10] to get an O ( m 1+ o (1) ε − 2 ) -time (1 + ε ) -approximation to the undirected maximum ﬂow problem.

Finally, we note that, in parallel to the above work that is focused on designing weakly- polynomial algorithms for the maximum s - t ﬂow and minimum s - t cut problems, there is also a considerable interest in obtaining running time bounds that are strongly-polynomial, i.e., that do not depend on the values of arc capacities. The current best such bound is O ( mn ) and it follows by combining the algorithms of King et al. [KRT94] and Orlin [Orl13].

Bipartite Matching Problem. Another problem that we will be interested in is the (maximum- cardinality) bipartite matching problem – a fundamental assignment problem with numerous appli- cations (see, e.g., [AMO93, LP86]) and long history. Already in 1931, König [Kön31] and Egerváry [Ege31] provided ﬁrst constructive characterization of maximum matchings in bipartite graphs. This characterization can be turned into a polynomial-time algorithm. Then, in 1973, Hopcroft and Karp [HK73] – and, independently, Karzanov [Kar73] – devised the celebrated O ( m √ n ) -time algorithm. Till date, this bound is the best one known in the regime of relatively sparse graphs. It can be improved, however, when the input graph is dense, i.e., when m is close to n 2 . In this case, one can combine the algebraic approach of Rabin and Vazirani [RV89] – that itself builds on the work of Tutte [Tut47] and Lovász [Lov79] – with matrix-inversion techniques of Bunch and Hopcroft [BH74] to get an algorithm that runs in O ( n ω ) time (see [Muc05]), where ω ≤ 2 . 3727 is the exponent

Bipartite Matching Problem.

of matrix multiplication [CW90, VW12]. Also, later on, Alt et al. [ABMP91], as well as, Feder and Motwani [FM95] developed combinatorial algorithms that oﬀer a slight improvement – by a factor of, roughly, log n n 2 m – over the O ( m √ n ) bound of Hopcroft and Karp whenever the graph is suﬃciently dense.

Finally, it is worth mentioning that there was also a lot of developments on the (maximum- cardinality) matching problem in general, i.e., not necessarily bipartite, graphs. Starting with the pioneering work of Edmonds [Edm65], these developments led to bounds that essentially match the running time guarantees that were previously known only for bipartite case. More speciﬁcally, the running time bound of O ( m √ n ) for the general-graph case was obtained by Micali and Vazirani [MV80, Vaz94] (see also [GT91] and [GK04]). While, building on the algebraic characterization of the problem due to Rabin and Vazirani [RV89], Mucha and Sankowski [MS04] and then Harvey [Har09] gave O ( n ω ) -time algorithms for general graphs.

1.1 Our Contribution

In this paper, we develop a new algorithm for solving maximum s - t ﬂow and minimum s - t cut problems in directed graphs. More precisely, we prove the following theorem.

Theorem 1.1. Let G = ( V, E ) be a directed graph with m arcs and unit capacities. For any two vertices s and t , one can compute an integral maximum s - t ﬂow and minimum s - t cut of G in O ( m 107 ) time.

This improves over the long-standing O ( m min {√ m, n 2 / 3 } ) running time bound due to Even and Tarjan [ET75] and, in particular, ﬁnally breaks the Ω( n 32 ) running time barrier for sparse directed graphs.

Furthermore, by applying a well-known reduction (see [CLRS09]), our new algorithm gives the ﬁrst improvement on the sparse-graph case of the seminal O ( m √ n ) -time algorithms of Hopcroft- Karp [HK73] and Karzanov [Kar73] for the maximum-cardinality bipartite matching problem.

Theorem 1.2. Let G = ( V, E ) be an undirected bipartite graph with m edges, one can solve the maximum-cardinality bipartite matching problem in G in oO
 O ( m 107 ) time.

This, again, breaks the 40-years-old running time barrier of Ω( n 32 ) for this problem in sparse graphs. Additionally, we design a simple reduction of the maximum s - t ﬂow problem to perfect bipartite b -matching problem (see Theorem 3.1). (This reduction can be seen as an adaptation of the reduction of the maximum vertex-disjoint s - t -path problem to the bipartite matching problem due to Hoﬀman [Hof60] – cf. Section 16.7c in [Sch03]. 2 ) As the reduction in the other direction is well- known already, this establishes an algorithmic equivalence of these two problems. We also show (see Theorem 3.3 and Corollary 3.4) how this reduction, together with the sub-linear-time algorithm for perfect matching problem in regular bipartite graphs of Goel et al. [GKK10], leads to an eﬃcient, nearly-linear time, rounding procedure for s - t ﬂows. 3

Finally, our main technical contribution is a primal-dual algorithm for (near-)perfect bipartite b -matching problem (see Theorem 3.2). This iterative algorithm draws on ideas underlying interior- point methods and the electrical ﬂow framework of Christiano et al. [CKM + 11]. It employs electrical

2 We thank Lap Chi Lau [Lau13] for pointing out this similarity. 3 Recently, it came to our attention that a very similar rounding result was independently obtained by Khanna et al. [KKL13].

ﬂow computations to gradually improve the quality of maintained solution by advancing it toward (near-)optimality along so-called central path.

We develop a way of analyzing this algorithm’s rate of convergence by relating it to the structure of the corresponding electrical ﬂows (see Theorem 5.5). This understanding enables us to devise a way of perturbing (see Section 6.1) and preconditioning (see Section 6.2) our intermediate solutions to ensure a convergence in only O ( m 37 ) iterations and thus improve over the well-known barrier of Ω( m 12 ) iterations that all the previous interior-point-methods-based algorithms suﬀer from. (To the best of our knowledge, this is the ﬁrst time that this barrier was broken for a natural optimization problem.)

We also note that most of this understanding of convergence behavior of interior-point methods can be carried over to general LP setting. Therefore, we are hopeful that our techniques can be extended and will eventually lead to breaking the Ω( m 12 ) iterations barrier for general interior-point methods.

1.2 Our Approach

The core of our approach comprises two components. One of them is combinatorial in nature and exploits an intimate connection between the maximum s - t ﬂow problem and bipartite matching problem. The other one is more linear-algebraic and relies on interplay of interior-point methods and electrical ﬂows.

Maximum ﬂows and bipartite matchings. The combinatorial component shows that not only one can reduce bipartite matching problem to the maximum s - t ﬂow problem, but also that a reduction in the other direction exists. Namely, one can reduce, in a simple and purely combinatorial way, the maximum s - t ﬂow problem to a certain variant of bipartite matching problem (see Theorem 3.1). Once this reduction is established, it allows us to shift our attention to the matching problem. Also, as a byproduct, this reduction – together with the algorithm of Goel et al. [GKK10] – yields a fast procedure for rounding fractional maximum ﬂows (see Corollary 3.4). This enables us focus on obtaining solutions that are only nearly-optimal, instead of being optimal.

Also, as a byproduct, this reduction – together with the algorithm of Goel et al. [GKK10] yields a fast procedure for rounding fractional maximum ﬂows (see Corollary 3.4). This enables to focus on obtaining solutions that are only nearly-optimal, instead of being optimal.

Bipartite Matchings and Electrical Flows.

Bipartite Matchings and Electrical Flows. The other component is based on using the interior-point method framework in conjunction with nearly-linear time electrical ﬂow computa- tions, to develop a faster algorithm for the bipartite matching problem.

The point of start here is a realization that the recent approaches to approximating undirected maximum ﬂow [CKM + 11, LRS13, She13, KLOS13], despite achieving impressive progress, have fundamental limitations that make them unlikely to yield improvements for the exact undirected or (approximate) directed setting. 4 Very roughly speaking, these limitations stem from the fact that, at their core, all these algorithms employ some version of gradient-descent method that relies on purely primal arguments, while almost completely neglecting the dual aspect of the problem. It is well-understood, however, that getting a running time guarantee that depends logarithmically, instead of polynomially, on ε − 1 – and such dependence is a prerequisite to making progress in directed setting – one needs to also embrace the dual side of the problem and take full advantage of it.

4 Note that it is known – see, e.g., [Mąd11] – that computing exact maximum s - t ﬂow in undirected graphs is algorithmically equivalent to computing the exact or approximate maximum s - t ﬂow in directed graph.

Interior-point methods and fast algorithms.

Interior-point methods and fast algorithms. The above realization motivates us to consider a more sophisticated approach, one that is inherently primal-dual and achieves logarithmic depen- dence on ε − 1 : interior-point methods. These methods constitute a powerful optimization paradigm that is a cornerstone of convex optimization (see, e.g., [BV04, Wri97, Ye97]) and already led to development of polynomial-time exact algorithms for a variety of problems. Unfortunately, despite all its advantages and successes in tackling hard optimization tasks, this paradigm has certain short- comings in the context of designing fast algorithms. The main reason for that is the fact that each iteration of interior-point method requires solving of a linear system, a task for which the current fastest general-purpose algorithm runs in O ( n ω ) = O ( n 2 . 3727 ) time [AHU74, CW90, VW12]. So, this bound becomes a bottleneck if one was aiming for, say, even sub-quadratic-time algorithm.

Fortunately, it turns out that there is a way to circumvent this issue. Namely, even though the above bound is the best one known in general, one can get a better running time when dealing with some speciﬁc problem. This is achieved by exploiting the special structure of the corresponding linear systems. A prominent (and most important from our point of view) example here is the family of ﬂow problems. Daitch and Spielman [DS08] showed that in the context of ﬂow problems one can use the power of fast (approximate) Laplacian system solvers [ST04, KMP10, KMP11, KOSZ13] to solve the corresponding linear systems in nearly-linear time. This enabled [DS08] to develop a host of O ( m 32 ) -time algorithms for a number of important generalizations of the maximum ﬂow problem for which there was no such algorithms before.

Unfortunately, this bound of O ( m 32 ) time turns out to also be a barrier if one wants to obtain even faster algorithms. The new diﬃculty here is that the best worst-case bound on the number of iterations needed for an interior-point method to converge to near-optimal solution is Ω( m 1 / 2 ) . Although it is widely believed that this bound is far from optimal, it seems that our theoretical understanding of interior-point method convergence is still insuﬃcient to make any progress on this front. In fact, improving this state of aﬀairs is a major and long-standing challenge in mathematical

Beyond the Ω( m 12 ) barrier. Our approach to circumventing this Ω( m 12 ) barrier and obtaining the desired O ( m 107 ) -time algorithm for the bipartite b -matching problem consists of two stages.

barrier. Our approach to circumventing this Ω( m 12 ) barrier and obtaining

( ) First one – presented in Section 5 – corresponds to setting up a primal-dual framework for solving the near-perfect b -matching problem. This framework is directly inspired by the principles underlying path-following interior-point methods and, in some sense, is equivalent to them. In it, we start with some initial sub-optimal solution (that is encoded as a minimum-cost ﬂow problem instance) and gradually improve its quality up to near-optimality. These gradual improvements are guided by certain electrical ﬂow computations – the ﬂows are used to update the primal solution and the corresponding voltages update the dual one – and our solution ends up following a special trajectory in the feasible space: so-called central path.

We analyze the performance of this optimization process by establishing a formal connection that ties the size of each improvement step to a certain characteristic of the corresponding electrical ﬂow. Very roughly speaking, this size (and thus the resulting rate of convergence) is directly related to how much the electrical ﬂow we compute resembles the current primal solution (which is also a ﬂow). Once this connection is established, a simple energy-based argument immediately recovers the generic O ( m 12 ) iterations bound known for interior-point methods. So, as each electrical ﬂow computation can be performed in Of
 O ( m ) time, this gives an overall O ( m 3 2 ) -time algorithm. Finally, to improve upon the above O m 12 iterations bound and deliver the desired O m 107 -

time procedure, in Section 6, we devise two techniques: perturbation of arcs – that can be seen as a reﬁnement of the edge removal technique of Christiano et al. [CKM + 11]; and solution precon- ditioning – a way of adding auxiliary arcs to the solution to improve its conductance properties. We show that by a careful composition of these techniques, one is able to ensure that the guiding electrical ﬂows align better with the primal solution – thus allowing taking larger progress steps and guaranteeing faster convergence – while keeping the unwanted impact of these modiﬁcations on the quality of ﬁnal solution minimal. The analysis of this process constitutes the technical core of our result and is based on understanding of the interplay between the interior-point method and both the primal and dual structure of electrical ﬂows.

We believe that this approach of understanding interior-point methods through the lens of electrical ﬂows is a promising direction and our result is just a ﬁrst step towards realizing its full potential.

1.3 Organization

We begin the technical part of the paper in Section 2 where we present some preliminaries on maximum ﬂow problem, electrical ﬂows, and bipartite ( b -)matching problem, as well as, introduce some theorems we will need in the sequel. In Section 3, we provide a general outline of our results and the structure of our proof.

In Section 4, we describe the reduction of maximum s - t ﬂow problem to the bipartite b -matching problem. Next, in Sections 5 and 6, we explain how our path-following algorithms and electrical ﬂows can be used to get an improved algorithm for the bipartite b -matching problem, with Section 7 presenting the analysis of our path-following primitive. Finally, we conclude in Section 8 by showing how to round fractional b -matchings to integral ones.

2 Preliminaries

In this section, we introduce some basic notation and deﬁnitions we will need later.

Throughout this paper, we denote by G = ( V, E, u ) a directed graph with vertex set V , arc set E (we allow parallel arcs), and (non-negative) integer capacities u e , for each arc e ∈ E . We usually deﬁne m = | E | to be the number of arcs of the graph in question and n = | V | to be the number of its vertices. Each arc e of G is an ordered pair ( u, v ) , where u is its tail and v is its head .

∈ v v the demand vector . By a σ -ﬂow in G we understand any vector f ∈ R m that assigns values to arcs G and satisﬁes the ﬂow conservation constraints :

Intuitively, these constraints enforce that the net balance of the total in-ﬂow into vertex v and the total out-ﬂow out of that vertex is equal to σ v , for every v V .

Furthermore, we say that a σ -ﬂow f is feasible in G iﬀ f obeys the non-negativity and capacity constraints :

One type of σ -ﬂows that will be of special interest to us are s - t ﬂows, where s (the source ) and t (the sink ) are two distinguish vertices of G . Formally, a σ -ﬂow f is an s - t ﬂow iﬀ its demand vector σ is equal to F · χ s,t for some F ≥ 0 – we call F the value of f – and the demand vector χ s,t that has 1 (resp. 1 ) at the coordinate corresponding to s (resp. t ) and zeros everywhere else.

Now, the maximum s - t ﬂow problem corresponds to a task of ﬁnding for a given graph G = ( V, E, u ) , a source s , and a sink t , a feasible s - t ﬂow f ∗ in G of maximum value F . We call such a ﬂow f ∗ that maximizes F the maximum s - t ﬂow of G and denote its value by F ∗ .

Sometimes, we will be also interested in (uncapacitated) minimum-cost σ -ﬂow problem (with non-negative costs). In this problem, we have a directed graph G with inﬁnite capacities on arcs (i.e., u e = + ∞ , for all e ) and certain (non-negative) length (or cost ) l e assigned to each arc e . Our goal is to ﬁnd a feasible σ -ﬂow f in G whose cost l ( f ) := e l e f e is minimal. (Note that as we have inﬁnite capacities here, the feasibility constraint (2) just requires that f e 0 for all arcs e .)

Finally, one more problem that will be relevant in this context is the minimum s - t cut problem. In this problem, we are given a directed graph G = ( V, E, u ) with integer capacities, as well as, a source s and sink t , and our task is to ﬁnd an s - t cut C ⊆ V in G minimizes the capacity u ( C ) := E − ( C ) u e among all s - t cuts. Here, a cut C ⊆ V is an s - t cut iﬀ s ∈ C and t / ∈ C , and E − ( C ) is the set of all arcs ( u, v ) with u ∈ C and v / ∈ C . It is well-known [EFS56, FF56] that the minimum s - t cut problem is the dual of the maximum s - t problem and, in particular, that the capacity of the minimum s - t cut is equal to the value of the maximum s - t ﬂow, as well as, that given a maximum s - t ﬂow one can easily obtain the corresponding minimum s - t cut.

2.2 Undirected Graphs

Although the focus of our results is on directed graphs, it will be crucial for us to consider undirected graphs too. To this end, we view an undirected graph G = ( V, E, u ) as a directed one in which the ordered pair ( u, v ) ∈ E does not denote an arc anymore, but an (undirected) edge ( u, v ) and the order just speciﬁes an orientation of that edge from u to v . (Even though we use the same notation for these two diﬀerent types of graphs, we will always make sure that it is clear from the context whether we deal with directed graph that has arcs, or with undirected graph that has edges.) From this perspective, the deﬁnitions of σ -ﬂow f that we introduced above for directed graphs transfer over to undirected setting almost immediately. The only (but very crucial) diﬀerence is that in undirected graphs a feasible ﬂow can have some of f e s being negative - this corresponds to the ﬂow ﬂowing in the direction that is opposite to the edge orientation. As a result, the feasibility condition (2) becomes

Also, the set E + ( v ) (resp. E − ( v ) ) denotes now the set of incident edges that are oriented towards (resp. away) from v , and E ( v ) := E + ( v ) ∪ E − ( v ) is just the set of all edges incident to v , regardless of their orientation.

Finally, given a directed graph G = ( V, E, u ) , by its projection ¯ G we understand an undirected graph that arises from treating each arc of G as an edge with the corresponding orientation. Note that if G had two arcs ( u, v ) and ( v, u ) then ¯ G will have two parallel edges ( u, v ) and ( v, u ) that have opposite orientation and, possibly, diﬀerent capacities.

2.3 Electrical Flows and Potentials

A notion that will play a fundamental role in this paper is the notion of electrical ﬂows. Here, we just brieﬂy review some of the key properties that we will need later. For an in-depth treatment we refer the reader to [Bol98].

Consider an undirected graph G and some vector of resistances r ∈ R m that assigns to each edge e its resistance r e > 0 . For a given σ -ﬂow f in G , let us deﬁne its energy (with respect to r ( f ) to be

where R is an m m diagonal matrix with R e,e = r e , for each edge e .

× For a given undirected graph G , a demand vector σ , and a vector of resistances r , we deﬁne an electrical σ -ﬂow in G (that is determined by resistances r ) to be the σ -ﬂow that minimizes the energy E r ( f ) among all σ -ﬂows in G . As energy is a strictly convex function, one can easily see that such a ﬂow is unique. Also, we emphasize that we do not require here that this ﬂow is feasible with respect to capacities of G (cf. (3)). Furthermore, whenever we consider electrical ﬂows in the context of a directed graph G , we will mean an electrical ﬂow – as deﬁned above – in the (undirected) projection ¯ G of G .

One of very useful properties of electrical ﬂows is that it can be characterized in terms of vertex potentials inducing it. Namely, one can show that a σ -ﬂow f in G is an electrical σ -ﬂow determined by resistances r iﬀ there exist vertex potentials φ v (that we collect into a vector φ ∈ R n ) such that, for any edge e = ( u, v ) in G that is oriented from u to v ,

In other words, a σ -ﬂow f is an electrical σ -ﬂow iﬀ it is induced via (5) by some vertex potential φ . (Note that orientation of edges matters in this deﬁnition.) Using vertex potentials, we are able to express the energy E r ( f ) (see (4)) of an electrical σ -ﬂow f in terms of the potentials φ inducing it as

One of the consequences of this characterization of electrical ﬂows via vertex potentials is that one can view the energy of an electrical σ -ﬂow as being a result of optimization not over all the σ -ﬂows but rather over certain set of vertex potentials. Namely, we have the following lemma that, for completeness, we prove in the Appendix A.

Lemma 2.1. For any graph G = ( V, E ) , any vector of resistances r , and any demand vector σ

where f ∗ is the electrical σ -ﬂow determined by r in G . Furthermore, if φ ∗ are the vertex potentials corresponding to f ∗ then the minimum is attained by taking φ to be equal to ˜ φ := φ ∗ / r ( f ∗ ) .

Note that the above lemma provides a convenient way of lowerbounding the energy of an elec- trical σ -ﬂow. One just needs to expose any vertex potentials φ such that σ T φ = 1 and this will immediately constitute an energy lowerbound. Also, another basic but useful property of electrical σ -ﬂows is captured by the following fact.

Fact 2.2 (Rayleigh Monotonicity) . For any graph G = ( V, E ) , demand vector σ and any two vectors of resistances r and r such that r e ≥ r e , for all e ∈ E , we have that if f (resp. f P|
 ) is the electrical σ -ﬂow determined by r (resp. r ) then

2.4 Laplacian Solvers

A very important algorithmic property of electrical ﬂows is that one can compute very good ap- proximations of them in nearly-linear time. Below, we brieﬂy describe the tools enabling that.

proximations of them in nearly-linear time. Below, we brieﬂy describe the tools enabling that. To this end, let us recall that electrical σ -ﬂow is the (unique) σ -ﬂow induced by vertex potentials via (5). So, ﬁnding such a ﬂow boils down to computing the corresponding vertex potentials φ . It turns out that computing these potentials can be cast as a task of solving certain type of linear system called Laplacian systems. To see that, let us deﬁne the edge-vertex incidence matrix B being an n m matrix with rows indexed by vertices and columns indexed by edges such that

Now, we can compactly express the ﬂow conservation constraints (1) of a σ -ﬂow f (that we view as a vector in R m ) as

On the other hand, if φ are some vertex potentials, the corresponding ﬂow f induced by φ via (5) (with respect to resistances r ) can be written as

where again R is a diagonal m m matrix with R e,e := r e , for each edge e .

where again R is a diagonal m × m matrix with R e,e := r e , for each edge e . Putting the two above equations together, we get that the vertex potentials φ that induce the electrical σ -ﬂow determined by resistances r are given by a solution to the following linear system

where L := BR − 1 B T is the (weighted) Laplacian L of G (with respect to the resistances r ). One can easily check that L is an n n matrix indexed by vertices of G with entries given by

One can see that the Laplacian L is not invertible, but – as long as, the underlying graph is connected – it’s null-space is one-dimensional and spanned by all-ones vector. As we require our

demand vectors σ to have its entries sum up to zero (otherwise, no σ -ﬂow can exist), this means that they are always orthogonal to that null-space. Therefore, the linear system (7) has always a solution φ and one of these solutions 5 is given by

where L † is the Moore-Penrose pseudo-inverse of L .

Now, from the algorithmic point of view, the crucial property of the Laplacian L is that it is symmetric and diagonally dominant , i.e., for any v ∈ V , u us
 = v | L u,v | ≤ L v,v . This enables us to use fast approximate solvers for symmetric and diagonally dominant linear systems to compute an approximate electrical σ -ﬂow. Namely, building on the work of Spielman and Teng [ST03, ST04], Koutis et al. [KMP10, KMP11] designed an SDD linear system solver that implies the following theorem. (See also recent work of Kelner et al. [KOSZ13] that presents an even simpler nearly- linear-time Laplacian solver.)

Theorem 2.3. For any ε > 0 , any graph G with n vertices and m edges, any demand vector σ , and any resistances r , one can compute in O ( m log m log ε − 1 ) time vertex potentials ˜ φ such that ˜ φ − φ ∗ L ≤ ε φ ∗ at
 L , where L is the Laplacian of G , φ ∗ are potentials inducing the electrical σ -ﬂow determined by resistances r , and φ L := φ T L φ .

To understand the type of approximation oﬀered by the above theorem, observe that φ alt
 2 L = φ T L φ is just the energy of the ﬂow induced by vertex potentials φ . Therefore, ˜ φ − φ ∗ L is the energy of the electrical ﬂow ¯f that “corrects” the vertex demands of the electrical ˜ σ -ﬂow induced by potentials ˜ φ , to the ones that are dictated by σ . So, in other words, the above theorem tells us that we can quickly ﬁnd an electrical ˜ σ -ﬂow ˜f in G such that ˜ σ is a slightly perturbed version of σ and ˜f can be corrected to the electrical σ -ﬂow f ∗ that we are seeking, by adding to it some electrical ﬂow ¯f whose energy is at most ε fraction of the energy of the ﬂow f ∗ . (Note that electrical ﬂows are linear, so we indeed have that f ∗ = ˜f + ¯f .) As we will see, this kind of approximation is completely suﬃcient for our purposes.

2.5 Bipartite b -Matchings

A fundamental graph problem that constitutes both an application of our results, as well as, one of the tools we use to establish them, is the (maximum-cardinality) bipartite b -matching problem . In this problem, we are given an undirected bipartite graph G = ( V, E ) with V = P ∪ Q – where P and Q are the two sets of bipartition – as well as, a demand vector b that assigns to every vertex v an integral and positive demand b v . Our goal is to ﬁnd a maximum cardinality multiset M of the edges of G that forms a b -matching . That is, we want to ﬁnd a multi-set M of edges of G that is of maximum cardinality subject to a constraint that, for each vertex v ∈ V , the number of edges of M that are incident to v is at most b v . (When b v = 1 for every vertex v , we will simply call such M a matching .)

We say that a b -matching M is perfect iﬀ every vertex in V has exactly b v edges incident to it in M . Note that a perfect b -matching - if it exists in G - has to necessarily be of maximum cardinality. Also, if a graph has a perfect b -matching then it must be that v ∈ P b v = v ∈ Q b v .

5 Note that the linear system (7) will have many solutions, but each two of them are equivalent up to a translation. as the formula (5) is translation-invariant, each of these solutions will yield the same unique electrical σ -ﬂow.

Now, by the perfect bipartite b -matching problem we mean a task in which we need to either ﬁnd the perfect b -matching in G or conclude that it does not exist.

Finally, by a fractional solution to a b -matching problem, we understand an | E | -dimensional vector x that allocates non-negative value of x e to each edge e and is such that for every vertex v of G , the sum e ∈ E ( v ) x e of (fractional) incident edges in x is at most b v . Also, we deﬁne the size of a fractional b -matching x to be x 1 .

| | An interesting class of graphs that is guaranteed to always have a perfect matching are bipartite graphs that are d -regular , i.e., that have the degree of each vertex equal to d . A remarkable algorithm of Goel et al. [GKK10] shows that one can ﬁnd a perfect matching in such graphs in time that is proportional only to number of its vertices and not edges. (Note that a d -regular bipartite graph has exactly dn 2 edges and thus this number can be much higher than n when d is large.) In particular, they prove the following theorem that we will use later.

Theorem 2.4 (see Theorem 4 in [GKK10]) . Given an n × n doubly-stochastic matrix M with m non-zero entries, one can ﬁnd a perfect matching in the support of M in O ( n log 2 n ) expected time with O ( m ) preprocessing time.

From Flows to Matchings, and Back

As we already mentioned, our results stem from exploiting the interplay between the maximum s - t ﬂow and bipartite b -matching problem, as well as, from understanding the performance of interior- point methods – when applied to these two problems – via the structure of corresponding electrical ﬂows. To highlight these elements, we decompose the proof of our main theorem (Theorem 1.1) into three natural parts.

Reducing Maximum Flow to b -Matching

First, we focus on analyzing the relationship between the maximum s - t ﬂow and the (maximum- cardinality) bipartite b -matching problem. It is well-known that the latter can be reduced to the former in a simple way. As it turns out, however, one can also go the other way – there is a simple, combinatorial reduction from the maximum ﬂow problem to the task of ﬁnding a perfect bipartite b -matching. 6

Before making this precise, let us introduce one deﬁnition. Consider a b -matching problem instance corresponding to a bipartite graph G = ( V, E ) with P and Q ( V = P ∪ Q ) being two sides of the bipartition. For any edge e = ( p, q ) ∈ E , let us deﬁne the thickness d ( e ) of that edge to be d ( e ) := min { b p , b q } . (So, d ( e ) is an upper bound on the value of x e in any feasible b -matching x .) We say that a b -matching instance is balanced iﬀ

Now, in Section 4, we establish the following result.

6 One can view this as one possible explanation of why the techniques used in the context of bipartite matchings and maximum ﬂows are so similar.

Theorem 3.1. If one can solve a balanced instance of a perfect bipartite b -matching problem in a (bipartite) graph with ¯ n vertices and ¯ m edges in T (¯ n, ¯ m, | b | 1 ) time, then one can solve the max- imum s - t ﬂow problem in a graph G = ( V, E, u ) with m arcs and capacity vector u in O (( m + T (Θ( m ) , 4 m, 4 u 1 )) log u 1 ) time.

This connection between maximum ﬂows and bipartite matchings is useful in two ways. Firstly, it enables us to reduce the main problem we want to solve – the maximum s - t ﬂow problem with unit capacities – to a seemingly simpler one: the perfect bipartite b -matching problem. Secondly, the fact that this reduction works also for fractional instances provides us with an ability to lift our b -matching rounding procedure that we develop later (see Theorem 3.3) to the maximum ﬂow setting (see Corollary 3.4).

Once the above reduction is established, we can proceed to designing an improved algorithm for the perfect bipartite b -matching problem. This algorithm consists of two parts.

The ﬁrst one – constituting the technical core of our paper – is related to the (fractional) near-perfect bipartite b -matching problem, a certain relaxation of the perfect bipartite b -matching problem. To describe this task formally, let us call a b -matching x near-perfect if its size | x | 1 is at least | b | 1 2 − O ( m 37 ) , i.e., it is within O ( m 37 ) additive factor of the size of a perfect b -matching. Now, given a bipartite graph G = ( P ∪ Q, E ) and demand vector b , the near-perfect b -matching problem is a task of either ﬁnding a near-perfect b -matching in G or concluding that no perfect b -matching exists in that graph.

Our goal is to design an algorithm that solves this near-perfect b -matching problem in O ( m 107 ) time. To this end, in Sections 5 and 6 we prove the following theorem.

Theorem 3.2. Let G = ( V, E ) with V = P ∪ Q be an undirected bipartite graph with n vertices and m edges and let b be a demand vector that corresponds to a balanced b -matching instance with | b | 1 = O ( m ) . In O ( m 107 ) time, one can either ﬁnd a fractional near-perfect b -matching x or conclude that no perfect b -matching exists in G .

(Observe that whenever we have an instance of maximum s - t ﬂow problem that has ¯ m arcs and unit capacities, | u | 1 is exactly ¯ m . So, if we apply the reduction from Theorem 3.1 to that instance then the resulting b -matching problem instance will be balanced, have m ≤ 4 ¯ m edges, as well as, b 1 4 u 1 = 4 ¯ m 2 m . Therefore, we will be able to apply the above Theorem 3.2 to it.)

At a very high level, our algorithm for the near-perfect b -matching problem is inspired by the way the existing interior-point method path-following algorithms (see, e.g., [Ye97, Wri97, BV04]) can be used to solve it. Basically, our algorithm is an iterative method that starts with some initial, far-from-optimal solution and then gradually improves this maintained solution to near-optimality (pushing it along so-called central path) using appropriate electrical ﬂows as a guidance. We then show how to tie the convergence rate of this process to the structure of the guiding electrical ﬂows. At that point, one can use a simple energy-bounding argument to establish a generic convergence bound that yields an (unsatisfactory) O ( m 32 ) -time algorithm.

To improve upon this bound and deliver the desired Of
 O ( m 107 ) -time algorithm, we show how one can appropriately “shape” these guiding electrical ﬂows to make their guidance more eﬀective and thus guarantee faster convergence. Very roughly speaking, it turns out there is a way of changing

the maintained solution to make it essentially the same from the point of view of our b -matching instance, while dramatically improving the quality of corresponding electrical ﬂows that guide it.

the maintained solution to make it essentially the same from the point of view of our b -matching instance, while dramatically improving the quality of corresponding electrical ﬂows that guide it. Our way of executing this idea is based on a careful composition of two techniques. One of them corresponds to perturbing, in a certain way, the arcs that are most signiﬁcantly distorting the structure of electrical ﬂow – this technique can be viewed as a reﬁnement of edge removal technique of Christiano et al. [CKM + 11]. The other technique corresponds to preconditioning the whole solution by adding additional, auxiliary, arcs to it. These arcs are chosen so to signiﬁcantly improve the conductance properties of the solution (when viewed as a graph with resistances) while not leading to too signiﬁcant deformation of the ﬁnal obtained solution.

Rounding Near-Perfect b -Matchings

Finally, our ﬁnal step on our way towards solving the perfect b -matching problem (and thus the maximum s - t ﬂow problem) is related to turning the approximate and fractional answer returned by the algorithm from Theorem 3.2 into an exact and integral one. To this end, note that if that algorithm returned a near-perfect b -matching that was integral, there would be a standard way to either turn it into a perfect b -matching or conclude that no such perfect b -matching exists. Namely, one could just use repeated augmenting path computations. It is well-known that given an integral b -matching, one can perform, in O ( m ) time, an augmenting path computation that either results in increasing the size of our b -matching by one, or concludes that no further augmentation is possible (and thus no perfect b -matching exists). So, as our initial near-perfect b -matching has size at least | b | 1 2 − O ( m 37 ) , after at most O ( m 37 ) iterations, i.e., in time O ( m 107 ) , we would get the desired answer. Unfortunately, the above approach can fail completely once our near-perfect b -matching is frac- tional. This is so, as in this case we do not have any meaningful lowerbound on the progress on the size of the b -matching brought by the augmenting path computation.

Therefore, to deal with this issue, we develop the last ingredient of our algorithm: a nearly- linear time procedure that allows one to round fractional b -matchings. More precisely, in Section 8, building on the work of Goel et al. [GKK10] (see Theorem 2.4), we establish the following theorem.

Theorem 3.3. Let G = ( V, E ) be an undirected bipartite graph with m edges and let b be a demand vector, if x is a fractional b -matching in G of size k = | x | 1 then one can ﬁnd in O ( m ) time an integral b -matching in G of size k .

Clearly, if we apply the above rounding method to the fractional near-perfect matching x com- puted by the algorithm from Theorem 3.2, it will give us an integral b -matching x ∗ whose size is still at least | b | 1 2 − OF
 O ( m 37 ) . So, the augmenting path-based approach we outlined above will let us obtain the desired integral and exact answer to the perfect b -matching problem within the desired time bound.

In the light of all the above, we see that combining all the above pieces indeed yields an O ( m 107 ) - time algorithm for the perfect bipartite b -matching problem in graphs with | b | 1 = O ( m ) . Now, using the reduction from Theorem 3.1, this gives us the analogous algorithm for the maximum s - t ﬂow problem in unit-capacity graphs and that, in turn, results in an algorithm for the bipartite matching problem. So, both Theorem 1.1 and Theorem 1.2 hold.

Rounding s - t Flows

Finally, we mention the other byproduct of our techniques – the fast rounding procedure for ﬂows. Namely, using the reduction described in Theorem 3.1 and the rounding from Theorem 3.3 we can obtain a fast rounding procedure not only for fractional b -matchings but also for fractional s - t ﬂows. Speciﬁcally, the proof of the following corollary appears in Appendix B.

Corollary 3.4. Let G = ( V, E, u ) be a directed graph with capacities and let f be some feasible fractional s - t ﬂow in G of value F . In Ol
 O ( m ) time, we can obtain out of f an integral s - t ﬂow f ∗ of value F that is feasible in G .

Again, we note that a very similar rounding result was independently obtained by Khanna et al.

Again, we note that a very similar rounding result was independently obtained by Khanna et al. [KKL13].

In this section, we show how to reduce the maximum s - t ﬂow problem in a directed capacitated graph G = ( V, E, u ) to solving O (log | u | 1 ) balanced instances of the perfect bipartite b -matching problem, i.e., we prove Theorem 3.1. We note that our reduction can be seen as an adaptation of the reduction of the maximum vertex-disjoint s - t path problem to the bipartite matching problem due to Hoﬀman [Hof60] – cf. Section 16.7c in [Sch03].

To this end, let G = ( V, E, u ) with n = | V | vertices and m = | E | arcs, as well as, the source s and sink t be our input instance of the maximum s - t ﬂow problem. Without loss of generality, we can assume that there is no arcs entering s and no arcs leaving t , as these arcs do not aﬀect the maximum s - t ﬂow. Also, let F ∗ be the value of the maximum s - t ﬂow in G .

The Reduction

We show that for any integral value of F , we can setup, in OF
 O ( m ) time, a balanced bipartite b - matching problem instance, for some demands b and bipartite graph ¯ G = ( P ∪ Q, ¯ E ) , such that: (1) there will be a perfect b -matching in ¯ G if there is a feasible s - t ﬂow of value F in G ; and (2) given a perfect b -matching in ¯ G one can recover in O ( m ) time an s - t ﬂow of value F that is feasible in G . Observe that once such a reduction is designed, Theorem 3.1 will follow by noticing that 1 ≤ F ∗ ≤ | u | 1 and applying a simple binary search strategy to ﬁnd the value of F ∗ and extract the corresponding maximum s - t -ﬂow.

Given the input graph G = ( V, E, u ) , source s , sink t and the value of F , the construction of our desired balanced bipartite b -matching instance ¯ G = ( P ∪ Q, ¯ E ) is as follows. First, for each arc e ∈ E , we create two vertices p e ∈ P and q e ∈ Q and an edge ( p e , q e ) between them, as well as, we set the demand b p e and b q e of these vertices to u e . Next, for every vertex v of G other than s and t , we add a vertex p v to P and a vertex q v to Q . Also, we create an edge ( p v , q v ) , as well as, an edge ( p v , q e ) (resp. ( q v , p e ) ) for every arc e that is incoming to (resp. outgoing of) v in G . We set the demands b p v (resp. b q v ) to be equal to e ∈ E + ( v ) u e (resp. e ∈ E − ( v ) u e ). Finally, we create a vertex q s ∈ Q (resp. p t ∈ P ) and add an edge ( q s , p e ) (resp. ( q e , p t ) for each arc e that is leaving s (resp. incoming to t ) in G . We put the demand b q s (resp. b p t ) to be ( e ∈ E − ( s ) u e ) − F (resp. ( e ∈ E + ( t ) u e ) − F ). (Note that we can assume here that both these quantities are non-negative as both e ∈ E − ( s ) u e and e ∈ E + ( t ) u e are obvious upperbounds on the value of F ∗ .)

s t e 2 e 3 e 4 e 5 e 1 1 3 2 2 3 a) b) q e 3 p t q e 4 p e 3 p e 4 p e 5 q e 5 q v 2 p v 2 q e 2 v 2 v 1 p e 2 q s p e 1 q e 1 q v 1 p v 1 2 2 1 1 3 3 2 2 3 3 3 3 4 3 2 3

b) q e 3 p t q e 4 p e 3 p e 4 p e 5 q e 5 q v 2 p v 2 q e 2 p e 2 q s p e 1 q e 1 q v 1 p v 1 2 2 1 1 3 3 2 2 3 3 3 3 4 3 2 3

Figure 1: a) An example directed s - t ﬂow instance G . Numbers next to arcs denote their capacities. b) The b -matching instance corresponding to the example from a) in case of F = 2 . Here, numbers next to vertices denote their demands.

An example s - t ﬂow instance and the corresponding instance of the bipartite b -matching can be found in Figure 1.

To see that this instance is balanced, note that every edge h of ¯ G that is incident to some vertex p e or q e has its thickness d ( h ) equal to u e = b p e = b q e . So, the contribution of these edges to the total thickness h ∈ ¯ E d ( h ) of edges of ¯ G is at most 3 e ∈ E u e ≤ 32 | b | 1 . On the other hand, the only edges that are not incident to some p e or q e are the ones of the form ( p v , q v ) . However, the total contribution of these edges to the total thickness is at most

Now, the proof of correctness of this reduction appears in Appendix

Over the next two sections, we prove Theorem 3.2. That is, we present an algorithm for the near- perfect bipartite b -matching problem in the setting where the input instance is balanced (see (9)) and | b | 1 is O ( m ) . In what follows we assume, for convenience, that | b | 1 is at most 2 m and that the graph G is sparse, i.e., m = O ( n ) . 7

7 It is easy to see that these assumptions are made without loss of generality. Whenever | b | 1 is O ( m ) , one can ensure that | b | 1 ≤ 2 m and m = O ( n ) by adding an appropriate – but still O ( m ) – number of dummy copies of complete bipartite K 6 , 6 graph with uniform demands. Adding each such dummy isolated copy brings the ratio of | b | 1 and m , as well as, of m to n down towards 1812 , while never leading to violation of the balance condition (9) and preserving the b -matching structure of the original input graph.

In this section, we show a basic algorithm that runs in O ( m 32 ) time. Later, in Section 6, we reﬁne this algorithm to obtain the desired running time of O ( m 107 ) .

For the sake of clarity, in our description and analysis we assume that the nearly-linear time Laplacian system solver (see Theorem 2.3) always returns an exact solution, i.e., all the electrical σ -ﬂows we compute are exact. We discuss how to handle the approximate nature of the solver’s output in Appendix E.9.

From b -Matching to Min-Cost σ -ﬂow

Let us ﬁx our instance of the bipartite b -matching problem in bipartite graph G = ( V, E ) with V = P ∪ Q . We will solve our b -matching instance by reducing it to a task of ﬁnding a minimum- cost ˆ σ -ﬂow in a certain related directed graph G = ( V , E, ˆl ) with ˆl being a length vector.

p 1 p 2 p 3 p 4 q 1 q 2 q 3 v ∗ s p 1 s p 2 s p 3 s p 4 t q 1 t q 2 t q 3 2 1 4 2 1 3 1 -2 -1 -3 -1 4 1 2 0

v ∗ s p 1 s p 2 s p 3 s p 4 t q 1 t q 2 t q 3 -2 -1 -3 -1 4 1 2 0

Figure 2: a) An example instance of bipartite b -matching problem. Numbers next to vertices represent their demands. b) The minimum-cost ˆ σ -ﬂow problem instance corresponding to the example from a). All arcs have cost ˆ l e equal to 1 and the numbers next to vertices denote their demands in ˆ σ . There are two parallel copies of the arc ( s p 1 , t q 1 ) and three parallel copies of the arc ( s p 3 , t q 3 ) . Also, each dashed arc represents two arcs that have the same endpoints but opposite orientation.

The reduction is performed as follows (see Figure 2 for an example). The vertex set V of the graph G consist of a special vertex v ∗ , as well as, vertices s p (resp. t q ), for every vertex p ∈ P (resp. q ∈ Q ) of the graph G . Next, for every edge e = ( p, q ) in G , we add to G d ( e ) copies of an arc ( s p , t q ) , where we recall that d ( e ) := min { b p , b q } is the thickness of e . Finally, for each vertex p ∈ P (resp. q ∈ Q ) of G , we add to G arcs ( s p , v ∗ ) and ( v ∗ , s p ) (resp. ( v ∗ , t q ) and ( t q , v ∗ ) ). We set the lengths ˆ l e of all arcs e to 1 .

To gain some intuition on this reduction, note that if a perfect b -matching indeed exists in G then the ﬂow that encodes it in G is fully supported on the arcs ( s p , t q ) and does not send more than one unit of ﬂow on any of these arcs. So, the purpose of including the extra vertex v ∗ and the arcs incident to it is to support (and appropriately penalize) the initial and intermediate solutions as they approach optimality.

Also, observe that this new graph has ˆ:= n + 1 vertices and, due to our b -matching instance

being balanced, we have that the total number m of arcs is at most

So, bounding our running time in terms of m provides a bound in terms of the number of edges m of our original b -matching instance that is asymptotically the same.

Now, consider a demand vector ˆ σ that has surplus of b p at each vertex s p , a deﬁcit of b q each vertex t q and a zero demand at vertex v ∗ . (Note that such a demand vector will be valid, i.e., v ˆ σ v = 0 , as we can assume that p b p = q b q – otherwise it would be impossible to have a perfect b -matching in G .) We claim that any near-optimal ˆ σ -ﬂow gives us a solution to our near-perfect b -matching instance. (Recall from Section 3 that a b -matching is near-perfect if its size is at least | b | 1 2 − O ( bad
 m 37 ) . Although, in the lemma below it suﬃces that we have a slack of only 12 instead of O ( (rr
 m 37 ) .)

Lemma 5.1. Given any feasible ˆ σ -ﬂow f in G whose cost ˆ l ( f ) is within additive 12 of the optimum, in O ( m ) time, we can either compute a (fractional) near-perfect b -matching x in G or conclude that no perfect b -matching exists in G .

Proof. First, observe that if there exists a perfect b -matching x ∗ in G then a ﬂow f ∗ that just puts, for each e = ( p, q ) of G , x ∗ e d ( e ) ≤ 1 units of ﬂow on each (of d ( e ) ) copies of the arc ( s p , t q ) in G ,

is a feasible ˆ σ -ﬂow with cost | b | 1 2 . (Recall that in the minimum-cost problem we assume that arc capacities are inﬁnite, thus feasibility condition (2) boils down to non-negativity of all f ∗ e s.) So, we can assume that our ˆ σ -ﬂow f has its cost ˆ l ( f ) at most | b | 1 2 + 12 . (Otherwise, we know that there is no perfect b -matching in G .)

Now, given any feasible ˆ σ -ﬂow in G , we can decompose it into a collection of ﬂow-paths and ﬂow-cycles, where each of these ﬂow-paths transports some amount of ﬂow from some vertex s p to some vertex t q . By our construction of the graph G , each such ﬂow-path has to have a length at least 1 . On the other hand, if this ﬂow-path is indeed of length exactly 1 then it has to correspond to a single arc ( s p , t q ) that reﬂects the existence of edge ( p, q ) in G . As a result, our feasible ˆ σ -ﬂow f in G has to have its cost ˆ l ( f ) to be at least | b | 1 2 and, furthermore, ˆ l ( f ) − | b | 1 2 is an upper bound on the total amount of ﬂow in f that is not transported over the direct one-arc ﬂow paths (and thus passes through the vertex v ∗ ).

f in G has to have its cost ˆ l ( f ) to be at least | b | 1 2 and, furthermore, ˆ l ( f ) − | b | 1 2 is an upper bound on the total amount of ﬂow in f that is not transported over the direct one-arc ﬂow paths (and thus passes through the vertex v ∗ ).

So, as we argued that the cost of f has to be at most | b | 1 2 + 12 , there is only at most 12 units of ﬂow in f that passes through the vertex v ∗ . Now, to extract the desired (fractional) near-perfect b -matching x , we just take x e = f ( s p ,t q ) , for each edge e = ( p, q ) in G . Clearly, the size of such fractional matching is at least | b | 1 2 − 12 , which is well above our lowerbound of | b | 1 2 − Of
 O ( m 37 ) for a near-perfect matching. Also, our construction works in O ( (mi
 m ) time, as desired.

Slack Variables

In the light of the above, our goal now is to compute the near-optimal solution to our minimum- cost ˆ σ -ﬂow problem instance in the graph G . Our approach to this task is inspired by so-called path-following interior-point methods [Ye97, Wri97, BV04]. At a very high level, we will start with certain initial solution that is far from being optimal, and then we will gradually improve – in an

iterative manner – its quality until close-to-optimal solution is obtained. This gradual improvement will be performed in a very speciﬁc way. It will always try to push the current solution further down so-called central path.

Before we can deﬁne the central path, let us ﬁrst mention that, in general, there are two natural ways of tracking the progress of a current solution towards optimality. One of them is purely primal and relies on just maintaining a feasible solution f and comparing its cost against some estimate of the cost of the optimal solution. The second one – and the one that we will actually use here – is based on primal-dual paradigm. Namely, in addition to maintaining a feasible primal solution f , we will also keep a dual feasible solution y . This dual solution provides an embedding of all the vertices in G into a line, i.e., y just assigns a real number y v to each vertex v of G . Its feasibility condition is that for any arc e = ( v, w ) of G it should be the case that its slack variable s e := ˆ l e − y w + y v is always non-negative, i.e., that the length of the arc e in this embedding is never larger than its length according to the length vector ˆl .

Before we proceed further, we note that the dual solution y is uniquely determined – up to translation – by the vector s (given the length vector ˆl ). So, for notational convenience, from now on, we will describe the dual solutions in terms of the vector s instead of y .

Duality Gap

It is not hard to see that any feasible dual solution s provides a lower-bound on the cost of the optimal solution (after all, this is just a consequence of weak duality). In particular, one has that for any pair ( f , s ) of feasible primal and dual solutions, the so-called duality gap , i.e., the diﬀerence between the upper bound on the value of optimal solution that is provided by the primal solution f and the lower bound provided by the dual solution s is exactly

where µ e := f e s e , for each arc e , and 1 is all-ones vector (of dimension m ). This means that one can obtain a close-to-optimal solution by devising a procedure that (quickly) converges to a pair of primal and dual solutions ( f , s ) whose duality gap | µ | 1 is small (in our case, at most 12 ).

γ -Centered Solutions and the Central Path

To describe in more detail the convergence process we will employ, let us associate with each arc e a measure ν e ≥ 1 . One can view ν e as a certain notion of importance of a given arc. (The motivation behind introducing this notion will be clear later.) We will always make sure that the measures of arcs are not smaller than 1 and also that their total sum is never too large. That is, we will make sure to maintain the following invariant.

Invariant 5.2. We have that ν T 1 = e ν e 4 ad
 m and for each arc e , ν e 1 .

We want to note that when discussing the preservation of the above invariant we will only focus on ensuring that the upperbound is not violated. The fact that ν e ≥ 1 for all arcs e will be automatically enforced as we will make sure that the initial measure of all the arcs is always at least and our algorithm will never decrease any measures – they only might increase.

be the weighted average value of ˆ µ e with weights given by the measures ν . We will call a solution ( f , s , ν ) (where ν represents the associated measures) γ -centered , for some γ 0 , if

i.e., x ν ,p is the p -norm of the vector x reweighed by the measures ν . Note that in a 0 -centered solution ( f , s , ν ) we have all ˆ µ e equal to ˆ µ ( f , s , ν ) . More generally, a simple but very useful observation is that

Fact 5.3. For any γ -centered solution ( f , s , ν ) we have that

ˆ µ ( f , s , ν ) as a measure of progress. The quantity ˆ µ ( f , s , ν ) will be important to us for one more reason. It will constitute our measure of progress on the quality of our maintained solution. To see why it indeed can serve this role, recall that by Invariant 5.2 we have that

So, if our goal is to obtain a solution whose duality gap is at most 12 we just need to make sure that the corresponding value of ˆ µ ( f , s , ν ) is at most 18 .

The main reason why we choose to measure our progress in terms of ˆ µ ( f , s , ν ) instead of the actual duality gap f T s is that in our algorithm we will sometime end up increasing measures of arcs. Such increases lead to an increase of the duality gap, so measuring our progress in terms of f T s would require dealing with such local non-monotonicity of this quantity. Continently, once we focus on keeping track of ˆ µ ( f , s , ν ) (and ensure that Invariant 5.2 is never violated), these issues will be avoided.

The central path. Finally, after introducing the above deﬁnitions, we can deﬁne the central path to be the set of all the 0 -centered solutions. 8 One can show that this set constitutes an actual path

8 Strictly speaking, in the literature, the central path corresponds to 0 -centered solutions with the measures of all arcs being one.

8 Strictly speaking, in the literature, the central path corresponds to 0 -centered solutions with the measures of

in feasible space that spans all the 0 -centered solutions and passes arbitrarily close to (but never reaches) an optimal solution to our minimum cost ﬂow problem. This explains the name of “path- following” interior-point methods, as they start with some initial 0 -centered solution and gradually advance along the central path to get increasingly more optimal γ -centered solution for some small ﬁxed γ .

Traversing the Central Path with Electrical Flows

Motivated by this path-following approach, our algorithm for computing near-optimal solution to the minimum-cost ˆ σ -ﬂow problem will start with some 0 -centered solution ( f 0 , s 0 , ν 0 ) that has fairly large value of ˆ µ ( f 0 , s 0 , ν 0 ) (and thus is far from being optimal). Then, we will devise a sequence of solutions ( f t , s t , ν t ) , where t is the step index, that have increasingly smaller value of ˆ µ ( f t , s t , ν t ) (and thus, indirectly, the duality gap) while making sure that they always are ˆ γ - centered for some small constant ˆ γ := 1400 . This way, our algorithm will eventually converge to the desired close-to-optimal solution.

To implement this approach, we start with the following lemma that shows we can get the initial 0 -centered solution ( f 0 , s 0 , ν 0 ) – its proof appears in Appendix D.1.

Lemma 5.4. There exists an explicit 0 -centered primal-dual feasible solution ( f 0 , s 0 , ν 0 ) with e ν 0 e 3 it
 m and ˆ µ ( f 0 , s 0 , ν 0 ) = 1 .

Note that the bound on the total measure of the arcs ensures that the Invariant 5.2 is preserved. Furthermore, there is a slack of at least m remaining between e ν 0 and the upperbound of 4 m from Invariant 5.2. It will be used to accommodate future measure increases in our improved algorithm (see Section 6).

We now proceed to explaining how given some ˆ γ -centered solution ( f t , s t , ν t ) , we can modify it to obtain a ˆ γ -centered solution ( f t +1 , s t +1 , ν t +1 ) that has a smaller value of ˆ µ ( f t , s t , ν t ) .

The associated ﬂow ˆf . For a given solution ( f , s , ν ) let us call it σ -feasible , for some demand vector σ , if it is dual feasible (i.e., s ≥ 0 ) and if f is a feasible σ -ﬂow. (So, a ˆ σ -feasible solution is a solution that is primal-dual feasible for our minimum-cost ˆ σ -ﬂow problem.) Next, given a σ -feasible solution ( f , s , ν ) , let us deﬁne an associated electrical ﬂow ˆf to be the electrical σ -ﬂow in (the undirected projection of) G determined by resistances r that are given as

for arc e . (Whenever we use this deﬁnition, it will be always the case that all f e s are positive and thus the resistances r e are well-deﬁned.)

Making an improvement step.

The central object in our procedure for taking an improvement

step will be the electrical ﬂow ˆf t that is associated with the solution ( f t , s t , ν t ) . The fundamental property of this ﬂow is that it allows us to simultaneously update our solution ( f t , s t , ν t ) both in the primal (ﬂow) space – via the ﬂow ˆf t itself – and in the dual (line embedding) space – via the vertex potentials φ t that induced ˆf t (see (5)). (In Section 7, we provide a detailed description of the whole improvement step.)

As we will see, such a guided update not only decreases the duality gap of our solution, but also perfectly maintains its centering when only ﬁrst-order terms (i.e., terms linear in the updates) are accounted for. Unfortunately, the second-order terms (i.e., the ones depending on the product of primal and dual updates) can disturb the centering. So, to be able to control this deﬁciency, we need to ensure that the step size δ t that governs the “aggressiveness” of the improvement step is suﬃciently small.

Of course, on the other hand, it is important for us to have this step be as large as possible. After all, the extent of our duality gap improvement – and thus overall convergence rate of our algorithm – is directly proportional to this size. So, it is crucial for us to develop a good grasp on how the size of that step relates to the properties of the ﬂow ˆf t .

To this end, let us deﬁne, for some – not necessarily feasible – ﬂow f and a positive vector x > 0 , ρ ( f , x ) to be the vector of congestions inﬂicted in G by f with respect to capacities given by x . That is,

for each arc e in G .

Now, in Section 7, we present a precise implementation and analysis of our update step. (This im- plementation can be viewed as a direct analogue of the update steps of path-following interior-point methods.) The result of this analysis is presented in the following theorem, which, in particular, ties the congestion vector ρ ( ˆf t , f t ) inﬂicted by the electrical ﬂow ˆf t with respect to the primal solution t , to an upperbound on the size δ t of the improvement step.

Theorem 5.5. Let ( f t , s t , ν t ) be a solution that is ˆ γ -centered and ˆ σ -feasible, and let ˆf t be the associated electrical ﬂow. We can compute in O ( in)

 m ) time a ˆ γ -centered and ˆ σ -feasible solution ( f t +1 , s t +1 , ν t +1 ) with ˆ µ ( f t +1 , s t +1 , ν t +1 ) (1 δ t ) ˆ µ ( f t , s t , ν t ) , as long as,

Furthermore, we have that the measures do not change, i.e., ν t +1 = ν t , and if for each arc e , we deﬁne (1 + κ te ) := (1 − δ t ) s t +1 e f te f t +1 e s te = (1 − δ t ) r t +1 e r te and (1 + ¯ κ te ) := (1 − δ t ) f te f t +1 e to make κ t (resp. ¯ κ t ) reﬂect the relative change (scaled by (1 δ t ) ) of resistances r t (resp. ﬂows f t ) then κ t ∞ , ¯ κ t ∞ 12 and

κ t e , ¯ κ t e 4( δ t ρ ( ˆ f t , f t ) e + ˆ κ t e ) ,

for some vector ˆ κ t with ˆ κ t ν t , 2 116

So, we see that the allowed size δ t of the improvement steps is proportional to how much the guiding ﬂow ˆf t resembles the current primal solution f t . Thus, for example, if there is some arc e that ﬂows much larger ﬂow in ˆf t than in f t , i.e., an arc e with large value of ρ ( ˆf t , f t ) e , this arc will be severely penalized by the 4 -norm measuring the quality of the resemblance.

Also, it is worth pointing out that it is very important that the above bound is based on a
 4 instead, say b
 2 norm. In fact, one can show (see Lemma 6.8) that in case of our problem the &
 2 norm of congestion vector is always Ω( un:
 m 12 ) . So, using 2 norm would not lead to any improvement over the Ω( (rm
 m 12 ) iteration bound.

5.1 Bounding the Running Time

At this point, we want to present a fairly elementary proof of δ := Ω( m − 12 ) lowerbound on our allowed improvement step size δ t . Note that once we achieve that then, by Lemma 5.4 and Theorem 5.5, we will have that the value of our measure of progress ˆ µ ( f t , s t , ν t ) after T steps is at most

So, by setting T := δ − 1 log 8 int
 m = O ( (rm
 m 12 ) , we recover the O ( m 12 ) iterations convergence bound of interior-point methods. This leads to a simple Oo
 O ( (rn
 mδ − 1 ) = oO
 O ( m 32 ) -time procedure that produces a solution with duality gap at most

4 bin
 m ˆ µ ( f T , s T , ν T ) 4 ata
 m (1 δ ) T 1

our instance of near-perfect b -matching problem. Therefore, to conclude the analysis of the simple O ( m 32 ) -time algorithm for the near-perfect b -matching problem, it remains to establish the claimed lowerbound on δ t .

Congestion and energy. By Theorem 5.5, performing such lowerbounding of δ t boils down to upperbounding of
at
 ρ ( ˆf t , f t ) a
‘i
 ν t , 4 . To understand how the latter can be done, one should observe the following simple but crucial fact. (This fact follows from Fact 5.3 and deﬁnition of the resistances t

Fact 5.6. For any γ -centered solution ( f t , s t , ν t ) and any ﬂow ˆf in G we have that

r te ˆ f 2 e (1 + γ ) ν te ˆ µ ( f t , s t , ν t ) ρ ( ˆf , f t ) 2 e ,

for any arc e in E

Observe that the above inequalities state that – up to a (1 ± γ ) factor – the square of the congestion ρ ( ˆf , f t ) e incurred by an arc e in the ﬂow ˆf is upperbounded by

which corresponds to normalized (by ν te ˆ µ ( f t , s t , ν t ) ) contribution of the arc e to the energy E r t ( ˆf ) of the ﬂow ˆf with respect to resistances r t .

This simple connection between the congestion of an arc in ˆf and its contribution to the energy of that ﬂow that is provided by Fact 5.6 will be fundamental to the rest of our discussion. In particular, it gives us an intuition on why we even expect the guiding electrical ﬂows ˆ f t to inﬂict small congestion with respect to f t and thus allow us to take a larger step size. This intuition is

based on an observation that the main goal of electrical ﬂows is to minimize energy. So, by choosing the resistances appropriately, we in some sense align this goal with our goal of making as large step sizes as possible. Roughly speaking, we are employing here the c
 2 norm minimization oﬀered by electrical ﬂows to achieve the desired ty
 4 -minimization corresponding to larger step sizes.

Now, an immediate consequence of the above connection is an elementary way of upperbounding We
 ρ ( ˆf t , f t ) aie
 ν t , 4 : we just bound the 2 -energy of the guiding electrical ﬂow ˆf t that is associated with our solution ( f t , s t , ν t ) and exploit the generic relationship between ty
 2 and ty
 4 norms. To implement this approach, let us start with the following lemma that gives us a bound on the by
 2 -energy of the electrical ﬂow ˆf t .

Lemma 5.7. For any σ -feasible solution ( f , s , ν ) and associated electrical ﬂow ˆf , we have that

Proof. The fact that E r ( ˆf ) ≤ E r ( f ) follows directly from the deﬁnition of ˆf and the fact that electrical σ -ﬂow minimizes energy among all the σ -ﬂows (which includes f ). Now, by deﬁnition (14) of r and that of ˆ µ ( f , s , ν ) (10) we have that

where the last line follows by Invariant 5.2.

Once we establish this upperbound on 2 -energy, we simply use it to upperbound the 4 -energy of the congestion vector. Speciﬁcally, by applying Cauchy-Schwarz inequality and the fact that x ∞ x 1 , for any vector x , we get that

≥ Now, to bound the 2 norm (instead of 4 norm) of the congestion vector, we just note that by Fact 5.6 and Lemma 5.7

Now, to bound the

norm (instead of

norm) of the congestion vector, we just note that by Fact

and Lemma

e ν te ρ ( ˆf t , f t )

e

≤ e ν te r te f

e (

− ˆ γ ) ν te ˆ µ ( f t , s t , ν t )

= E r t ( ˆf t ) (

− ˆ γ )ˆ µ ( f t , s t , ν t )

≤ O ( m

) . (

)

Therefore, we can conclude with the following lowerbound on δ t .

Fact 5.8. For any t , δ t ≥ 1 O ( √ m )

It is worth pointing out that, as we discussed before, the fact that we settled here for an ty
 2 - norm-based (instead of an 4 -norm-based) dependence of δ t on the congestion vector ρ ( ˆf t , f t ) , this 1 O ( √ m ) lowerbound is the best possible to achieve with this approach. Therefore, to have any hope of obtaining an improvement that goes beyond this bound (as we will do in the next section), we crucially require to be working with 4 -norm-based (instead of only ty
 2 -norm-based) arguments.

An Improved Algorithm for Bipartite b -Matching Problem

After setting up our primal-dual framework and presenting the oO
 O ( m 32 ) -time algorithm in the pre- vious section, we can now proceed to developing our improved algorithm with the running time of O ( m 107 ) = Of
 O ( m 32 − η ) , for η := 114 o (1) .

− Given our analysis and discussion in the previous section, a tempting approach to obtaining such an improved bound could be trying to simply tighten our analysis performed there (e.g., by taking advantage of 4 -norm-based instead of only ty
 2 -norm-based arguments) and thus improve the worst-case lowerbound on δ t that we established (cf. Fact 5.8).

It turns out, however, that getting an improved bound is not merely a matter of performing a better analysis. In the worst-case, our O ( m − 12 ) bound is actually tight. After all, if there is an arc that incurs Ω( m 12 ) congestion in the associated electrical ﬂow, the resulting 4 -norm of the congestion vector will be Ω( m 12 ) . So, even though the connection between congestion and energy we established before (see Fact 5.6 and Lemma 5.7) tells us that there cannot be too many such arcs (as each one of them would need to contribute a very signiﬁcant, Ω(1) , fraction of the total energy of the electrical ﬂow), having just one such arc is already enough to prevent us from taking larger than O ( m − 12 ) improvement step.

Therefore, as we cannot rule out that such worst-case situation arises in each iteration of our algorithm 9 , getting our desired improvement requires developing a strategy that explicitly ensures that this is not the case (or, at least, not too often).

At a high level, our general approach to accomplishing this goal is based on “massaging” the solution that we maintain. That is, we devise and carefully combine two methods of altering our solutions. These methods, on one hand, signiﬁcantly improve the behavior of the associated electrical ﬂow while, on other hand, only slightly perturb the characteristics of that solution that are vital to recovering the desired near-perfect b -matching at the end.

The ﬁrst of these two methods is related to edge removal technique of Christiano et al. [CKM + 11]. Their technique is based on repeated removal from the graph of the edges that suﬀer too much con- gestion. As [CKM + 11] showed (via a simple energy-based argument), when such edge removal is applied to electrical ﬂows that guide multiplicative-weight-update-based optimization routine, one obtains a signiﬁcantly faster convergence to approximately optimal solution.

Unfortunately, as our primal-dual framework has much more delicate nature than the multiplicative- weight-update method, such removal of “bottlenecking” arcs would be too drastic and, in particular, could destroy the structure of our dual solution. Therefore, we apply a more careful approach.

Instead of removing arcs, we only perturb them by moderately increasing their lengths (and thus their slack variables). (Note that, by (14), increasing arc’s slack variable increases its resistance.) Furthermore, to avoid signiﬁcant distortion of the dual solution, we do not apply this perturbation to all “bottlenecking” arcs, but only the ones that are “heavy” in the primal solution (see Deﬁnition 6.7 below).

We then use a certain reﬁnement of the original energy-based argument of Christiano et al. [CKM + 11] (that needs, in particular, to deal with the fact that – in contrast to the multiplicative- weight-update-based framework of [CKM + 11] – in our framework the arc’s resistances can change

9 One would suspect, however, that such situations are indeed rare. This might be one explanation of why in practice interior-point methods are able to take most of its step sizes to be very large and thus converge much faster than indicated by the worst-case bound of O ( m 32 ) .

in a completely non-monotonic fashion) to show that the behavior of our guiding electrical ﬂows on such “heavy” arcs is indeed improved.

Now, our second method – that is somewhat complementary to the ﬁrst one and aims at accom- modating the “light” arcs – is based on an appropriate preconditioning of our solution by augmenting it with auxiliary arcs. The purpose of adding these arcs is to improve the connectivity (and thus electrical conductance) of the underlying solution (when treated as a graph with resistances) while changing the structure of our original solution in only minimal way (that can be ﬁxed later). We then show via a certain dual-based argument that existence of these auxiliary arcs ensures that “light” arcs are never the bottlenecking ones (and thus do need to be dealt with anymore). We proceed now to detailed description and analysis of our improved algorithm.

The Sets S l ( ˆf ) and θ -Smoothness

We start by specifying the behavior of associated electrical ﬂows that is “good” from our perspective. To this end, for a ﬂow ˆf in G , a solution ( f , s , ν ) , and integer l , let us deﬁne S l ( ˆf ) to be the set of all the arcs e such that

Now, we introduce a deﬁnition that will be fundamental to the rest of our discussion.

Deﬁnition 6.1. For some 0 ≤ θ ≤ 1 , a ﬂow ˆf , and solution ( f , s , ν ) (that will be always clear from the context), we say that ˆf is θ -smooth on some of arcs S E iﬀ, for any integer l log θ − 3 , we

Clearly, the θ -smoothness constraints the distribution of the arcs that suﬀer high congestion in . In particular, it implies that there is no arcs whose congestion ρ ( ˆf , f ) e is larger than θ √ m . Observe that the tight worst-case example for the lowerbound on δ t (cf. Fact 5.8) corresponds

to situation where the electrical ﬂow ˆf t associated with the maintained ˆ γ -centered solution solution ( f t , s t , ν t ) makes some arcs highly-congested, i.e., makes them suﬀer congestion of Ω( √ ‘
 m ) . How- ever, the above deﬁnition of θ -smoothness, forbids existence of such arcs. Therefore, the hope is that once our electrical ﬂows ˆf t are θ -smooth, a better lowerbound on δ t (and thus faster convergence) is possible. As the following lemma shows, this hope is indeed well-founded.

Lemma 6.2. Let ( f t , s t , ν t ) be a σ -feasible and ˆ γ -centered solution and let ˆf t be the associated electrical ﬂow that is θ -smooth, for some 0 θ 1 . We have that

Proof. By Theorem 5.5, in order to lowerbound δ t we need to upperbound the quantity

Me
 ρ ( ˆf t , f t ) Me
 4 ν t , 4 = e ν te ρ ( ˆf t , f t ) 4 e . To this end, note that e ν te ρ ( ˆf t , f t ) 4 e ≤ l ν t ( S l ( ˆf t )) m 2 2 4 l ≤ l Ae
 θ 3 2 3 l m 2 2 4 l ≤ l ≥(cid:98) log θ − 1 θ 3 m 2 2 l ≤ 4 θ 4 m 2 ,

where we used the θ -smoothness of ˆf (cf. Deﬁnition 6.1) and the fact that ely
 θ 3 2 3 l = 0 whenever l < log θ − 1 . So, the lemma follows once C δ > 0 is chosen to be an appropriately large constant.

In the light of the above lemma, if we somehow knew that all – or, at least, most of – the ﬂows ˆf that we compute are indeed θ -smooth for some θ = O ( m − η ) , we would immediately get the desired faster algorithm. Unfortunately, as we already discussed, it seems to be hard to argue that this is what happens in the worst-case. Therefore, to address this problem we develop a perturbation approach that we carefully apply to our maintained solutions to ensure that most of the ﬂows ˆf t is indeed θ -smooth for some small enough value of θ .

α -Stretching

One of the main operations that we will use to implement our perturbations is called α -stretching. To describe it, consider a solution ( f , s , ν ) that is γ -centered and a parameter α ≥ 0 . We deﬁne an α -stretching of an arc e to be an operation that returns a solution ( f , s , ν ) obtained from ( f , s , ν ) by, ﬁrst, increasing the length ˆ l e of the arc e (and thus the value of s e ) by αs e and, then, increasing the measure ν e of e by a factor of (1 + β ) , where

The remaining part of the solution remains the same.

The property of α -stretching that is key from our point of view, is that after applying it to some arc e its resistance r e := s e f e increases by a factor of exactly (1 + α ) . Furthermore, our choice of value of β is justiﬁed by the lemma below – its proof appears in Appendix E.1.

Lemma 6.3. If ( f , s , ν ) was a γ -centered solution with γ ≤ 12 then so will be ( f , s , ν ) and ˆ µ ( f , s , ν ) = ˆ µ ( f , s , ν ) . Furthermore, (1 γ ) α β (1 + γ ) α .

So, we see that applying α -stretching with this setting of β does not perturb our measure of progress ˆ µ ( f , s , ν ) , even though the duality gap f T s changes due to corresponding increase in measure. (Again, this is one reason why we chose ˆ µ ( f , s , ν ) to measure our progress.) On the other hand, besides the increase in measure, another undesirable byproduct of α -

On the other hand, besides the increase in measure, another undesirable byproduct of α - stretching is the increase of arc’s length. To mitigate the eﬀect of this process on the validity of our ﬁnal solution, we will ensure that the following invariant is maintained throughout the algorithm.

Invariant 6.4. The overall increase of arcs’ length due to α -stretching is at most O ( un
 m 12 − η ) and no individual arc has its total increase of length larger than 1 .

Maintaining this invariant will be important for two reasons. One simple lemma, whose proof appears in Appendix E.2.

Lemma 6.5. If Invariant 6.4 is preserved then for any σ -feasible solution ( f , s , ν ) , we have that e is at most 6 , for any arc e .

The other, and even more important one, is that as long as this invariant is preserved the ﬁnal close-to-optimal solution ( f t , s t , ν t ) to our perturbed problem still allows us to recover the desired near-perfect b -matching in the (original) graph G (or conclude that no perfect b -matching exists). More precisely, in Appendix E.3 we prove the following lemma.

Lemma 6.6. Provided Invariant 6.4 holds, given any feasible ˆ σ -ﬂow f in G whose cost is within additive 12 of the optimum, we can recover in O ( m ) time a (fractional) near-perfect b -matching in G , or conclude that no perfect b -matching exists in G .

Heavy Arcs

As we already mentioned, an important role in our improved algorithm is played by a classiﬁcation of arcs into two classes, “heavy” and “light”, depending on their current ﬂow in the primal solution. We make this classiﬁcation precise below.

Deﬁnition 6.7. Given a γ -centered solution ( f , s , ν ) with γ ≤ 12 , we call an arc e heavy if f e ≥ ν e F H , where

for some suﬃciently large constant C H > 1 that we will ﬁx later (see Lemma 6.15). We say that an arc is light if it is not heavy.

The motivation for the above classiﬁcation stems from a desire to control the increase in arc’s length due to an application of α -stretching. Namely, observe that if we α -stretch an heavy arc e then the increase in this arc’s length is by at most

where we used Fact 5.3. So, as long as we apply α -stretching operations only to heavy arcs – which essentially will be the case in our algorithm – we can guarantee that the resulting change in arc length is relatively small. This will be important to ensuring that Invariant 6.4 is never violated. Having introduced the above concepts, we are ready to proceed to presenting our improved algorithm. In this presentation, we ﬁx for the rest of this section ˆ θ := m − η , where

and C η is a suﬃciently large constant to be ﬁxed later.

We describe our algorithm in two stages. First, in Section 6.1, we present a variant of the algorithm that works under an ad-hoc assumption that all the electrical ﬂows ˆf t that we compute are always ˆ θ -smooth on the set of light arcs. (So, we need to deal there only with its possible non- ˆ θ - smoothness on the set of heavy arcs.) Then, in Section 6.2, we show how to apply a preconditioning technique to obtain an augmented version of our graph such that when we run our algorithm it is indeed true that the above ad-hoc assumption holds.

In this section, we work under an ad-hoc assumption that the electrical ﬂows ˆf that are associated with the maintained solutions ( f t , s t , ν t ) are always ˆ θ -smooth – with ˆ θ := m − η – on the set of arcs that are light with respect to that solution. We present an oO
 O ( (i
 m 32 − η ) -time algorithm for this setting.

ˆ θ -Improvement Phase

The core of this algorithm is an implementation of a primitive we call a ˆ θ -improvement phase . This primitive, given a ˆ σ -feasible and ˆ γ -centered solution ( f t 0 , s t 0 , ν t 0 ) , returns in oO
 O ( m 1+2 η ) time a ˆ σ -feasible and ˆ γ -centered solution ( f t f , s t f , ν t f ) such that

Observe that once we obtain an implementation of such a ˆ θ -improvement phase, we can get the desired improved algorithm as follows. We start with a ˆ σ -feasible and ˆ γ -centered solution ( f 0 , s 0 , ν 0 ) as in Lemma 5.4. Next, we apply T iterations of ˆ θ -improvement phase to it, with

Note that after doing this, we know that if ( f F , s F , ν F ) is the ﬁnal ˆ σ -feasible ˆ γ -centered solution we compute then

So, as long as we can show that ( f F , s F , ν F ) satisﬁes Invariants 5.2 and 6.4, we can use Lemma 6.6 to recover the desired near-perfect b -matching in G or conclude that no perfect b -matching exists in G . Also, the overall running time of this algorithm will indeed be Ol
 O ( T m 1+2 η ) = O ( un
 m 32 − η ) , as desired.

In the light of the above discussion, we just need to focus on implementing the ˆ θ -improvement phase, as well as, ensuring that running it for T iterations will not violate Invariants 5.2 and 6.4. Our implementation – presented in Figure 3 – is an iterative procedure. We maintain a ˆ σ - feasible ˆ γ -centered solution ( f t , s t , ν t ) – initially, ( f t , s t , ν t ) is equal to ( f t 0 , s t 0 , ν t 0 ) . Next, as long as ˆ µ ( f t , s t , ν t ) > ˆ λ ˆ µ ( f t 0 , s t 0 , ν t 0 ) we repeat the following iterative step. ˆf t t t t ˆ

If it is indeed the case then one can easily see that such ˆf needs to be 2ˆ θ -smooth (on the set of all the arcs). (This uses our ad-hoc assumption that all ˆf t we compute are always ˆ θ -smooth on the set of light arcs.) So, in this situation, we can just apply an interior-point method step – as described in Theorem 5.5 – to ( f t , s t , ν t ) with setting δ t := 1 2 C δ ˆ θ √ m . (Note that by Lemma 6.2 this

Figure 3: Implementation of ˆ θ -improvement phase via stretch-boosts

set the resulting ˆ σ -feasible and ˆ γ -centered solution ( f t +1 , s t +1 , ν t +1 ) as our current solution and proceed to next iterative step. Otherwise, that is, if ˆf t is not ˆ θ -smooth on the set of heavy arcs, then – by Deﬁnition 6.1 – there is an l ∗ log ˆ θ − 3 such that

set the resulting ˆ σ -feasible and ˆ γ -centered solution ( f t +1 , s t +1 , ν t +1 ) as our current solution and proceed to next iterative step.

Otherwise, that is, if ˆf is not ˆ θ -smooth on the set of heavy arcs, then – by Deﬁnition 6.1 – there is an l ∗ log ˆ θ − 3 such that

ν t ( S l ∗ ( ˆf t ) E tH ) > max ˆ θ 3 2 3 l ∗ , 1

where we used the fact that all measures of arcs are always at least one and E tH denotes the set of heavy arcs with respect to the solution ( f t , s t , ν t ) .

To cope with this situation, we perform 1 -stretching of all the arcs in S l ∗ ( ˆf ) ∩ E tH t . (Note that, by Lemma 6.3, this operation does not change the value of ˆ µ ( f t , s t , ν t ) and our solution remains ˆ σ -feasible and ˆ γ -centered.) We call this operation stretch-boosting and l ∗ will be referred to as the index of this stretch-boosting. After performing stretch-boosting, we proceed to the next iterative

This ﬁnishes the description of our implementation.

Analysis

To analyze the above procedure, let us note that due to our stopping condition, once this procedure terminates the resulting solution ( f t f , s t f , ν t f ) satisﬁes our requirements. Also, there will be at most ˆ θ − 2 progress steps executed. This is so, as 1 -stretching does not aﬀect the value of ˆ µ ( f t , s t , ν t and, by Theorem 5.5, each progress step decreases ˆ µ ( f t , s t , ν t ) by a factor of at least (1 − δ t ) = ˆ λ 1ˆ θ − 2 . Thus, as each of these steps runs in O ( (rn
 m ) time, the resulting total time of progress steps is O ( (Fre
 m ˆ θ − 2 ) = O ( m 1+2 η ) , as desired.

well as, on showing that calling our implementation of ˆ θ -improvement phase Ty
 T times does not violate Invariants 5.2 and 6.4.

We start with the former task. In this bounding of the number of stretch-boost operations, assume that Invariant 5.2 holds. We will justify this assumption later when proving that our desired invariants are indeed preserved by our algorithm.

To do the bounding, we consider the energy E r t ( ˆf t ) of the electrical ˆ σ -ﬂow ˆf t (determined by resistances r t given by (14)) that is associated with our current solution ( f t , s t , ν t ) . We treat this quantity as a potential function and show the following facts:

(a) E r t ( ˆf ) is always at least C E m ˆ µ ( f , s , ν ) and at most C E m ˆ µ ( f , s , ν ) , for some suﬃciently large constant C E >

– see Lemma

; (b) E r t ( ˆf t ) increases by a factor of at least (

+ C S ˆ θ

) , for some constant C S >

, whenever stretch-boosting step is applied – see Lemma

; (c) E r t ( ˆf t ) decreases by a factor of at most (

+ C P ˆ θ

ln m ) each time a progress step is executed, where C P >

is some suﬃciently large constant – see Lemma

Note that once the above statements are established, it must be the case that there is at most T s := C P C − 1 S ˆ θ − 2 ln C 2 E m = Ol
 O (ˆ θ − 2 ) stretch-boost operation overall. To see that, assume this was not the case, i.e., that there was more than T s stretch-boosts. Then, by the above statements and the fact that there is at most ˆ θ − 2 progress steps we would have that

which would violate the upperbound on energy r tf ( ˆf f ) established by statement (a).

In the light of the above, we can turn our attention to proving statements (a)-(c). We start with statement (a). This statement essentially follow from Lemma 5.7 and some simple energy- lowerbounding argument. The prove of the following lemma appears in Appendix E.4.

Lemma 6.8. Let ( f t , s t , ν t ) be a ˆ σ -feasible and ˆ γ -centered solution. Provided that Invariant 5.2 holds, we have that

where ˆf t is the electrical ˆ σ -ﬂow associated with the solution ( f t , s t , ν t ) and C E > 1 is a suﬃciently large constant.

Next, we proceed to analyzing the eﬀect of stretch-boosting on the energy E r t ( ˆf ) . Intuitively, by the connection between congestion and energy hinted by Fact 5.6, we know that the arcs with large congestion have to have unusually high contribution to the energy E r t ( ˆf t ) . So, as 1 -stretching eﬀectively doubles the resistances of such arcs, it is not surprising that it ends up signiﬁcantly increasing that energy. We make this formal – and thus establish statement (b) – in the lemma below. Its proof appears in Appendix E.5.

Lemma 6.9. Each stretch-boost increases r t ( ˆf t ) by a factor of at least

To complete our analysis, it remains to show that our potential E r t ( ˆf ) does not decrease too much during the progress steps. In other words, we prove statement (c).

Note that the diﬃculty here stems from the fact that, in principle, the resistances of arcs can change pretty arbitrarily during a progress step. They can either increase or decrease and even by a constant multiplicative factor, thus possibly leading to severe and very non-monotone energy ﬂuctuations.

The key reason that enables us to control that energy change after all, is that we perform the progress step only if the ﬂow ˆf t is ˆ θ -smooth. This is helpful in two ways. Firstly, because we can use it together with the connection between the change of the resistance of an arc and its congestion that we established in Theorem 5.5, to show that there is not too many arcs that signiﬁcantly change their resistance (see Lemma 6.10 below). Secondly (and even more importantly), our connection between congestion and energy, allows us to conclude that ˆ θ -smoothness implies that there is no small (measure-wise) set of arcs that contributes unusually high portion of the energy. So, even if some small set of arcs changes its resistances signiﬁcantly, it is not able to inﬂuence the overall energy by too much (see Lemma 6.11). (In a sense, this intuition is one of the main motivations for introducing the notion of ˆ θ -smoothness.) We, again, formalize this intuition below. λ

Now, we say that λ is τ -restricted , for some measure ν and τ 0 if for any l 0 ,

Now, the lemma below bounds the change of resistances during any of our progress steps.

Lemma 6.10. Let ˆf t be a 2ˆ θ -smooth electrical ﬂow associated with ( f t , s t , ν t ) . Let ( f t +1 , s t +1 , ν t +1 ) be the solution obtained by applying an interior-point method step – as in Theorem 5.5 – to ( f t , s t , ν t ) with δ t := (2 C δ ˆ θ √ am)
 m ) − 1 . Then the vectors κ t and ¯ κ t are all C R -restricted (with respect to ν t ) for some constant C R > 0 .

Proof. We will prove that both the vector δ t ρ ( ˆf , f t ) and the vector ˆ κ t are O (1) -restricted. It is easy to see that then the bound from Theorem 5.5 will imply that ¯ κ t and κ t are O (1) -restricted too. So, choosing large enough constant C R will prove the lemma. To this end, observe ˆ κ t is O (1) -restricted as ˆ κ t ν t , 2 by Theorem 5.5. On the other hand, note

for some l 1 and arc e , then e S l ve (
 ( ˆf t ) for some

l l + log δ t √ m + 2 l + log ˆ θ − 1 + O (1)

But by 2ˆ θ -smoothness of ˆf t , this means that the total measure of such arcs is at most

which establishes that δ t ρ ( ˆf t , f t ) is indeed O (1) -restricted. The lemma follows.

Using the above observation, we can now ﬁnish establishing property (c) by proving the following lemma whose appears in Appendix E.6.

Lemma 6.11. Let ˆf be a 2ˆ θ -smooth electrical ﬂow associated with the ˆ γ -centered solution ( f t , s t , ν t Let ( f t +1 , s t +1 , ν t +1 ) be the solution obtained by applying an interior-point methods step – as in Theorem 5.5 – to ( f t , s t , ν t ) with δ t := (2 C δ ˆ θ √ m ) − 1 . Then,

where ˆf t +1 is the electrical ﬂow associated with ( f t +1 , s t +1 , ν t +1 ) and C P > 1 is a suﬃciently large constant.

Now, as we completed the analysis of the running time of our ˆ θ -improvement phase implementation, we establish the remaining claim, i.e., we prove that executing the above procedure T times does not lead to violation of Invariants 5.2 and 6.4.

Bounding measure increase. To this end, let us ﬁrst focus on bounding the measure increases. By Lemma 6.3, we know that whenever we 1 -stretch an arc e , its measure increases by at most (1+ ˆ γ ) ν te . So, to bound the total measure increase it suﬃces to bound the total measure of arcs that are aﬀected by 1 -stretches across all the stretch-boost operations. (Here, if the same arc becomes 1 -stretched multiple times, in diﬀerent stretch-boosts, we account for its measure multiple times.) In order to do that, note that by Lemma 6.9, if ν i is the measure of the set of arcs that are 1 -stretched in i -th stretch-boost, we have that the total increase of energy resulting from that is at

Bounding measure increase.

In order to do that, note that by Lemma 6.9, if ν i is the measure of the set of arcs that are 1 -stretched in i -th stretch-boost, we have that the total increase of energy resulting from that is at least k

Also, by Lemma 6.8, we know that we have to have that in any single stretch-boost, the energy cannot increase by more than C 2 E factor. So, we have that

and thus ν i ≤ ν max := C 6 E ˆ θ 6 = O ( m 6 η ) , for each i . As a result, we can lowerbound the total increase of energy due to stretch-boosts by

Finally, by Lemma 6.8 and Lemma 6.11, as well as, the fact that we have at most ˆ θ − 2 progress steps, we know that the overall (multiplicative) increase of energy resulting from all the stretch- boosts can be at most

Therefore, as ˆ θ 2 ν 13 max is Ω(1) , we have that the total measure increase ν is at most

As a result, after executing at most T ˆ θ -improvement phases, the overall increase of measure can be bounded by

Now, given that by Lemma 5.4, we start with our measure being at most 3 m and thus have a slack of at least m measure left before Invariant 5.2 becomes violated, this overall increase will indeed not lead to violation of this invariant.

Bounding arc length increase. To show that Invariant 6.4 is preserved as well, let us ﬁrst note that the only way for length of arcs to increase is due to 1 -stretching occurring during stretch-boosts. Furthermore, we only 1 -stretch an arc if it is heavy. So, if a given (heavy) arc e gets 1 -stretched at some step t then its length increases by at most

Bounding arc length increase.

the other hand, by Lemma 6.3, the increase of measure of such arc is at least (1 − ˆ γ ) ν te . So, as ≥ 1 , the increase of measure of an arc is within a factor of O ( m 3 η √ m ) = O ( m − 4 η ) of increase of the

On the other hand, by Lemma 6.3, the increase of measure of such arc is at least (1 − ˆ γ ) ν te . So, as ν te ≥ 1 , the increase of measure of an arc is within a factor of O ( m 3 η √ m ) = O ( m − 4 η ) of increase of the length. So, as we just proved that the total measure increase is at most O ( un
 m 12 +3 η ) (cf. (26)), the desired bound of Oo
 O ( m 12 − η ) on the total length increase follows.

Finally, as each 1 -stretch increases the measure by a factor of at least (2 − ˆ γ ) ≥ 32 and – as we discussed above – we never 1 -stretch anymore an arc whose measure is bigger than ν max = O ( m 6 η ) , no single arc will get 1 -stretched more than O (log ν max ) = O (log m ) times. As a result, no single arc has its length increased by more that O ( m − 4 η log has
 m ) that is much smaller than 1 . Therefore, the Invariant 6.4 is also preserved. This concludes our analysis.

Preconditioning the Graph G

Our analysis from the previous section was crucially relying on the assumption that all the ﬂows ˆf t are always ˆ θ -smooth on the set of light arcs. Unfortunately, this assumption is not always valid.

Our analysis from the previous section was crucially relying on the assumption that all the ﬂows ˆf are always ˆ θ -smooth on the set of light arcs. Unfortunately, this assumption is not always valid. To cope with this problem, we develop a modiﬁcation of our algorithm that ensures that this ˆ θ -smoothness assumption holds after all. Roughly speaking, we achieve that by an appropriate preconditioning our solution at the beginning of each ˆ θ -improvement phase. This preconditioning is based on augmenting the graph G with additional, auxiliary arcs and correspondingly extending our solution on them. These arcs are very light (i.e., have small value f te of ﬂow ﬂowing through

them in augmented solution), while providing good connectivity (and thus relatively low eﬀective resistance) between diﬀerent vertices of the augmented graph.

The underlying intuition here is that the over-congestion of a light arc e is caused by amounts of ﬂow that are at most √ mF H (cf. Deﬁnition (6.7)) and thus are relatively small compared to the whole duality gap. So, by deploying these very light auxiliary arcs we encourage the electrical ﬂow ˆf t to reroute such over-congesting ﬂow from e and send it along auxiliary arcs. On the other hand. as the small value of this rerouted ﬂow is small, the perturbation of our desired (non-augmented) solution introduced by these rerouting is relatively minor. Thus, we are able to deal with it relatively easily at the end of the whole ˆ θ -improvement phase, while still ending up making overall progress on the quality of our solution.

Augmenting the Graph and the Solution

The exact implementation of our preconditioning is based on modifying the execution of ˆ θ -improvement phase that was presented in the previous section in the following way. Let ( f t 0 , s t 0 , ν t 0 ) be the ˆ γ - centered and ˆ σ -feasible solution at the beginning of some ˆ θ -improvement phase.

We start with augmenting the graph G by adding to it a new vertex ¯ v , as well as, a v copies of an arc ( v, ¯ v ) and a v copies of an arc (¯ v, v ) , for each vertex v of G other than v ∗ , where

is the total measure (with respect to ν t 0 ) of all the arcs adjacent to v in G . We will call these newly added arcs auxiliary and denote the augmented graph as ¯ G . Next, we extend the solution ( f t 0 , s t 0 , ν t 0 ) to that augmented graph ¯ G by assigning f t 0 := F A ,

f and ν t 0 := 1 to each auxiliary arc e , where

with C A being some suﬃciently large constant to be ﬁxed later, and the lengths of the auxiliary arcs being chosen so that the extended solution is still dual feasible. (As we will soon see, the actual lengths of auxiliary arcs are irrelevant.) Note that after this extension, the solution ( f t 0 , s t 0 , ν t 0 ) remains ˆ γ -centered, ˆ σ -feasible and the value of ˆ µ ( f t 0 , s t 0 , ν t 0 ) is unchanged. Also, observe that by Invariant 5.2, the number ¯ m of arcs of the augmented graph ¯ G is still only O ( m ) . So, relating various quantities – in particular, the running times of our procedures – to either m or ¯ m results in only a constant-factor discrepancy (that we will ignore in what follows).

Now, after the above preprocessing, we run the ˆ θ -improvement phase implementation, as de- scribed in the previous section, on the extended solution in the augmented graph ¯ G . (In Section 6.2, we will prove that the assumption that underlies the analysis from the previous section, i.e., that all the ﬂows ˆf t are ˆ θ -smooth on light arcs, is indeed valid.) The only further modiﬁcation here is that after each progress step we m 2 η | ¯ κ te | -stretch each auxiliary arc e with | ¯ κ te | ≥ ˆ θ 2 (cf. Theorem 5.5). We will call this stretch operation freezing . (Note that as α -stretching only increases the resistances of arcs, this modiﬁcation is compatible with the energy-based potential argument we employed in the previous section.) This freezing ensures that the ﬂows on auxiliary arcs do not change to signiﬁcantly in our solution and thus the impact of preconditioning provided by auxiliary

arcs on the quality of the ﬁnal solution is minimized. We make this more precise in the following lemma whose proof appears in Appendix E.7.

Lemma 6.12. During the whole ˆ θ -improvement phase, we have that for each auxiliary arc e , C − 1 F F A ≤ f te ≤ C F F A , for some constant C F > 0 . Also, the total increase of measure of auxil- iary arcs in that phase is at most O ( (me
 m 8 η ) .

Finally, once the execution of the above ˆ θ -improvement phase ﬁnishes, we end up with a γ centered and ˆ σ -feasible solution ( f t , s t , ν t ) such that ˆ µ ( f t , s t , ν t ) ≤ ˆ λ ˆ µ ( f t 0 , s t 0 , ν t 0 ) , as desired. However, this solution corresponds to the augmented graph ¯ G instead of to the original graph G .

To deal with this deﬁciency, we ﬁrst simply discard all the auxiliary arcs and correspondingly truncate the solution ( f t , s t , ν t ) to non-auxiliary arcs. Unfortunately, doing that might, in partic- ular, render that solution not ˆ σ -feasible. So, to alleviate this problem, in Section 6.2 below, describe a ﬁxing procedure that, given such a truncated solution, produces the intended solution ( f t f , s t f , ν t f ) that corresponds to the original graph G , is ˆ γ -centered, ˆ σ -feasible and

(Note that in our algorithm we are executing only T = Ol
 O ( m 12 − 3 η ) ˆ θ -improvement phases overall. So, this additional (1 + O ( m − 12 )) factor above is inconsequential.)

As we will see, a byproduct of this ﬁxing procedure is an increase in the measure of (non- auxiliary) arcs. However, we will show that this increase is bounded by O ( C F m C A T ) . Thus, taking C A to be suﬃciently large ensures that the resulting measure increases do not lead to violation of Invariant 5.2. (Note that the auxiliary arcs are always discarded at the end, so from the point of view of Invariant 5.2, it suﬃces that by Lemma 6.12 the measure of these arcs is always o ( m ) .)

In the light of the above discussion, all that remains is to describe and analyze the ﬁxing procedure and to show that one can indeed assume that all the electrical ﬂows ˆf t computed during such ˆ θ -improvement phase are ˆ θ -smooth on the set of light arcs.

Fixing Procedure

We start by describing and analyzing the ﬁxing procedure that we employ at the end of each ˆ θ - improvement phase. Recall that in this procedure we are given as input a ˆ γ -centered and ˆ σ -feasible solution ( f t , s t , ν t ) in the augmented graph ¯ G such that ˆ µ ( f t , s t , ν t ) ≤ ˆ λ ˆ µ ( f t 0 , s t 0 , ν t 0 ) . Our goal is to obtain a ˆ γ -centered ˆ σ -feasible solution ( f t f , s t f , ν t f ) in the original graph G that satisﬁes ˆ µ ( f t f , s t f , ν t f ) ˆ λ (1 + O ( m − 1 2 ))ˆ µ ( f t 0 , s t 0 , ν t 0 ) .

≤ We do this in two steps. First, we simply truncate the solution ( f t , s t , ν t ) to the original graph G by discarding all the auxiliary arcs and ﬂow on them. Let us denote the resulting solution as ( f , s , ν ) . It is not hard to see that this solution is still ˆ γ -centered. In the following lemma – whose proof appears in Appendix E.8 – we argue that also the value of ˆ µ ( f , s , ν ) has not increased by much.

Lemma 6.13. ˆ µ ( f , s , ν ) ˆ λ (1 + O ( iad
 m − 12 ))ˆ µ ( f t 0 , s t 0 , ν t 0 )

At this point, we know that the solution ( f Ff
 , s , ν ) is ˆ γ -centered and ˆ µ ( f Ff
 , s , ν ) is as small as needed. Unfortunately, this solution can still be not ˆ σ -feasible. Therefore, in the second step of our procedure, we address this last shortcoming. Our approach here requires introducing a certain simple operation. For a given some solution ( f , s , ν ) , as well as,

Therefore, in the second step of our procedure, we address this last shortcoming. Our approach here requires introducing a certain simple operation. For a given some solution ( f , s , ν ) , as well as,

some α ≥ 0 and an arc e , let us deﬁne α -widening of e (in ( f , s , ν ) ) as an operation in which we increase the value of f e by a factor of (1 + α ) and increase ν e by a factor of (1 + β ) , where β is given via (18).

We can view the α -widening operation as a counterpart of the α -stretching operation. In fact, one can see that due to symmetric nature of f e and s e and our choice of β , Lemma 6.3 also holds for α -widening operation. (Note that in the proof of Lemma 6.3 the roles of f e and s e are completely interchangeable.)

Now, our way of obtaining the desired solution ( f t f , s t f , ν t f ) is very simple. Let us denote by ¯ σ the actual demand vector of f and let ˜ σ := ˆ σ − ¯ σ be the vector of demand diﬀerences. We start with ( f F!
 , s , ν ) and for each vertex v of G other than v ∗ , we do the following. If ˜ σ v ≥ 0 (resp. ˜ σ v < 0 ), we apply α v -widening to the arc e ( v ) := ( v, v ∗ ) (resp. e ( v ) := ( v ∗ , v ) ) with α v := | ˜ σ v | f e .

We take ( f t f , s t f , ν t f ) to be the resulting solution. It is easy to see that this solution is ˆ σ -feasible now. Also, by Lemma 6.3, we know that this solution remains ˆ γ -centered and that ˆ µ ( f t f , s t f , ν t f ) = ˆ µ ( f , s , ν /)
 ) ≤ ˆ λ (1 + O ( Sad
 m − 12 ))ˆ µ ( f t 0 , s t 0 , ν t 0 ) , as needed. So, we just need to establish the claimed bound of O ( C F m ) on total measure increase resulting

≤ So, we just need to establish the claimed bound of O ( C F m C A T ) on total measure increase resulting from this procedure. To this end, note that by Lemma 6.3 this increase is at most

(1 + ˆ γ ) v = v ∗ α v ν te ( v ) = (1 + ˆ γ ) v = v ∗ | ˜ σ v | ν te ( v ) f e ( v ) ≤ (1 + ˆ γ ) 2 v = v ∗ | ˜ σ v | s e ( v ) ˆ µ ( f , s , ν ) = O   v = v ∗ | ˜ σ v | ˆ µ ( f , s , ν )   = O | ˆ σ − ¯ σ | 1 ˆ µ ( f , s , ν ) ,

where we used the Fact 5.3 and Invariant 6.4, as well as, we applied Lemma 6.5 to conclude that each s e ( v ) is O (1) .

Thus, in the light of the above, it only remains to bound ˆ σ ¯ σ

Lemma 6.14. ˆ σ ¯ σ 1 = O ( C F m ˆ µ ( f , s , ν Y)
 ) )

Proof. One can see that we can bound | ˆ σ − ¯ σ | 1 by bounding the total (additive) change of the ﬂow f t on all auxiliary arcs during the whole execution of ˆ θ -improvement procedure. Furthermore, as the ﬂow f t changes only during progress steps, and there is at most ˆ θ − 2 = m 2 η of them, it suﬃces to prove that in each progress step this change is at most O ( C F ˆ µ ( f , s , ν ) m 1 − 2 η C T )) .

Now, by Theorem 5.5 and Lemma 6.12, this (additive) change at step t can be bounded as

where S is the set of auxiliary arcs. By Cauchy-Schwarz inequality, we get that

where we used (16) and the fact that by Lemma 6.12 ν t ( S ) is O ( (=
 m ) . Similarly, we obtain that

≤ Plugging the above to bounds back into (29) and recalling that we always set δ t := (2 C δ ˆ θ √ m ) − 1 , we obtain that

| ˆ σ − ¯ σ | 1 ≤ 4 C F F A e ∈ S δ t ρ ( ˆf t , f t ) e + e ∈ S ˆ κ te ≤ O C F F A √ m C δ ˆ θ ≤ O C F ˆ µ ( f t 0 , s t 0 , ν t 0 ) m 1 − 2 η C A T ≤ O 7
 C F ˆ µ ( f , s , ν v)
 ) m 1 − 2 η C A T ~
 ,

where we utilized (28), as well as, the fact that, due to our stopping condition for ˆ θ -improvement phase, we can always assume that ˆ µ ( f t 0 , s t 0 , ν t 0 ) is O (ˆ µ ( f , s , ν )) . The lemma follows.

Clearly, by setting C A to be a suﬃciently large constant, we can ensure that the total measure increase due to ﬁxing procedure will not lead to violation of Invariant 5.2.

ˆ θ -smoothness on Light Arcs

As the ﬁnal step of our analysis, we prove now that in the course of our algorithm – after the modiﬁcations described above – all the electrical ﬂows ˆf t that we compute are indeed ˆ θ -smooth on the set of light arcs. That is, the assumption underlying the analysis performed in Section 6.1 is indeed justiﬁed.

To this end, let us ﬁx some ˆ σ -feasible and ˆ γ -centered solution ( f t , s t , ν t ) in our augmented graph ¯ G and let ˆf t be the associated electrical ˆ σ -ﬂow. For convenience, we drop from now on all the references to t in our notation.

Our proof will take advantage of the dual nature of electrical ﬂows. In particular, it will be instrumental for us to consider the vertex potentials φ that induce the electrical ﬂow ˆf via (5). The crucial property of these potentials is that they provide an embedding of all the vertices of ¯ G into a line. To make it precise, for a given arc e = ( u, v ) , let us denote by φ − e (resp. φ + e ): the value of φ u (resp. φ v ), if φ u ≤ φ v ; and the value of φ v (resp. φ u ), otherwise. In other words, φ − e (resp. φ + e ) is the coordinate of the left-most (resp. right-most) endpoint of e in this line embedding. Observe that by (5) and deﬁnition of resistances r (cf. (14)), we have that for a given arc

Observe that by (5) and deﬁnition of resistances r (cf. (14)), we have that for a given arc e = ( u, v ) , the distance ∆ e between the embeddings of its endpoints is

and thus by Fact 5.3

Furthermore, for two subsets T, U ¯ V of vertices of ¯ G , let us deﬁne the distance dist( T, U ) between

Furthermore, for two subsets T, U ⊆ ¯ V of vertices of ¯ G , let us deﬁne the distance dist( T, U ) between these sets to be

Also, let us call two such subsets T ⊆ ¯ V and U ⊆ ¯ V , (∆ , k ) -separated , for some ∆ > 0 and integer k ≥ 0 , if dist( T, U ) ≥ ∆ and min { a ( T ) , a ( U ) } ≥ k , where a ( U ) := v ∈ U a v and a v is deﬁned in (27).

Now, assume for the sake of contradiction that ˆf is not ˆ θ -smooth on the set of light arcs, i.e., there exists an l ∗ log ˆ θ − 3 such that

where S ∗ denotes S l ∗ ( ˆf ) \ E tH with the set S l ∗ ( ˆf ) deﬁned by (17) and E tH denotes the set of heavy arcs. Our main goal is to show that in this case there exist two subsets T, U ⊆ ¯ V of vertices that are (∆ ∗ , k ∗ ) -separated with

where C H is the constant from Deﬁnition 6.7, F A is given by (28), and C K is a suﬃciently large constant that does not depend on C H and will be set later. To motivate this goal, we prove the following lemma.

Lemma 6.15. If there exist T, U ¯ V that are (∆ ∗ , k ∗ ) -separated then

provided C H is chosen to be large enough.

Observe that the conclusion of this lemma violates the bound from Lemma 6.8. Thus, the resulting contradiction would allows us to conclude that ˆf indeed needs to be ˆ θ -smooth on the set of light arcs, as we wanted to prove.

Proof. Note that as dist( T, U ) ≥ ∆ ∗ , it must be the case that either dist( { ¯ v } , U ) ≥ ∆ 2 or dist( { ¯ v } , T ) ≥ ∆ ∗ 2 . (Recall that ¯ v is the special vertex of ¯ G that is adjacent to all the auxiliary arcs.) Let us assume – without loss of generality – that the ﬁrst case holds.

Now, as min { a ( T ) , a ( U ) } ≥ k ∗ , we know that, in particular, a ( U ) ≥ k ∗ . This, in turn, means that at least k ∗ of auxiliary arcs e must have ∆ e ≥ ∆ ∗ 2 . Furthermore, by Lemma 6.12, we know that all but O ( Said
 m 8 η ) of these arcs have measure 1 . So, as k ∗ is aX
 Ω( ad
 m 1 − 6 η ) , by ensuring that the constant C η in the deﬁnition of η ((19)) is big enough, we can conclude that the set ˆ S of auxiliary arcs with ∆ e ∆ ∗ 2 and ν e = 1 has size of at least k ∗ 2 .

So, by (30) and Lemma 6.12, we have that, for any such arc e in ˆ S ,

≥ 2 Now, the above inequality enables us to lowerbound the energy E r ( ˆf ) of the ﬂow ˆf using sole contribution of arcs in ˆ S . We get that

E r ( ˆf ) ≥ e ∈ ˆ S r e ˆ f

e ≥ e ∈ ˆ S (

− ˆ γ )ˆ µ ( f , s , ν ) ρ ( ˆf , f )

e ≥ (

− ˆ γ )ˆ µ ( f , s , ν ) | ˆ S | ∆ ∗ F A

C F ˆ µ ( f , s , ν ) ≥ ˆ µ ( f , s , ν ) k ∗ ∆ ∗ F A

C F ˆ µ ( f , s , ν )

≥ Ω ˆ µ ( f , s , ν ) iad
 m

−

η

l ∗ C

H m

η C

F C K

l ∗ \\
 ≥ Ω wa
 ˆ µ ( f , s , ν ) iid
 m C

H C

F C K ,

where we used the deﬁnition of r (14) and Fact 5.3.

So, once C H is chosen to be large enough constant – which we can always ensure to be the case – the lemma follows. (Note that at this point the constant C F is ﬁxed already and we will make sure that when we later set the constant C K , it does not depend on the value of C H .)

Finding the (∆ ∗ , k ∗ ) -separated Sets

In the light of the above, it remains to establish how condition (32) implies the existence of such (∆ ∗ , k ∗ ) -separated sets T ∗ and U ∗ . To this end, for a given x ∈ R , let us deﬁne V − x (resp. V + x ) to be the set of vertices v with φ v ≤ x (resp. φ v ≥ x ). Also, let E x denote the set of arcs e of ¯ G such that φ − e x φ + e .

≤ ≤ Now, let x ∗ be the smallest x such that a ( V − x ) ≥ k ∗ . If a ( V x ∗ +∆ ∗ ) ≥ k ∗ then taking T ∗ := V − x ∗ and U ∗ = V + x ∗ +∆ ∗ will clearly constitute the (∆ ∗ , k ∗ ) -separated sets we are looking for.

So, we can focus on the case that a ( V x ∗ +∆ ∗ ) < k ∗ . Let us then take T ∗ := V x ∗ ∩ V x ∗ +∆ ∗ . Note that, as 3 k ∗ is smaller than the number of all auxiliary arcs, we need to have a ( T ∗ ) ≥ k ∗ . Next, let us take U ∗ := V − x ∗ − ∆ ∗ ∪ V + x ∗ +2∆ ∗ . Clearly, dist( T ∗ , U ∗ ) ≥ ∆ ∗ . Therefore, once we show that a ( U ∗ ) ≥ k ∗ , T ∗ and U ∗ will constitute the desired (∆ ∗ , k ∗ ) -separated sets.

We proceed now to showing that indeed a ( U ∗ ) ≥ k ∗ . Let us deﬁne F ( x ) := e ∈ E x f e (resp. F ( x ) := e ∈ E x | ˆ f e | ) to be the total ﬂow of f (resp. ˆf ) ﬂowing through the arcs in E x . We will be interested in two quantities

where I ∗ is an interval [ x ∗ − ∆ ∗ , x ∗ + 2∆ ∗ ] . (Observe that if the interval I ∗ was not excluded, A would be equal to the energy r ( ˆf ) of the ﬂow ˆf .)

Lowerbounding A First, we want to lowerbound A . To this end, we note that by (30), for any e ∈ S ∗ (recall that S ∗ := S l ∗ ( ˆf ) \ E tH and thus, in particular, is contain only light arcs), we have that

where we also used (17), (33), and Deﬁnition 6.7. As the interval I ∗ has length 3∆ ∗ , this means that for any arc e ∈ S ∗ , the interval [ φ − e , φ + e ] \ I ∗ has length of at least

This, in turn, implies that even if we account for contributions of the arcs from S ∗ only, we have

A = R \ I ∗ F ( x ) dx ≥ 1 2 e ∈ S ∗ ∆ e | ˆ f e | ≥ (1 − ˆ γ )ˆ µ ( f , s , ν ) 2 e ∈ S ∗ ρ ( ˆf , f ) e ν e | ˆ f e | f e ≥ (1 − ˆ γ )ˆ µ ( f , s , ν ) 2 e ∈ S ∗ ρ ( ˆf , f ) 2 e ν e ≥ ˆ µ ( f , s , ν ) 5 e ∈ S ∗ ν e m 2 2 l ∗ = ˆ µ ( f , s , ν ) 5 · 2 2 l ∗ ν ( S ∗ ) iid
 m ≥ ˆ µ ( f , s , ν ) 5 ˆ θ 3 2 l ∗ m = ˆ µ ( f , s , ν ) 5 2 l ∗ m 1 − 3 η ,

where we used (17), (30), and (32).

Upperbounding A ∗ Now, we want to upperbound the value of A ∗ . To do that, let us deﬁne ¯ S to be the set of arcs that have at least one endpoint outside of the interval I ∗ . Note that by our way of setting up the auxiliary arcs and the fact that by Lemma 6.12 and (25), the total increase of measure of arcs during the ˆ θ -improvement phase is Ol
 O ( (ne
 m 8 η ) , we have that

So, if we are able to show that ν ( ¯ S ) ≥ 4 k ∗ = Ω( m 1 − 6 η ) and ensure again that the constant C η in deﬁnition of η (19) is large enough, we will prove that a ( U ∗ ) ≥ k ∗ , as desired. To establish such lowerbound on ν ( ¯ S ) , we use (30) and observe that

where we noted that the only arcs that can contribute to A ∗ are all in the set ¯ S . Therefore, by Fact 5.3 and Cauchy-Schwarz inequality, we have that

So, putting the above two bounds together, we get that

where we also used (16) and Lemma 5.7. At this point, our last needed observation is captured by the following lemma.

At this point, our last needed observation is captured by the following lemma.

Lemma 6.16. For any x R , we have that F ( x ) F ( x ) .

Notice that once the above lemma is established, we have that

and, as a result, we can put (34) and (36) together to obtain

ν ( ¯ S ) ≥ 1 m A ∗ 5ˆ µ ( f , s , ν ) 2 ≥ 1 m A 5ˆ µ ( f , s , ν ) 2 ≥ 1 m 2 l ∗ m 1 − 3 η 25 2 Ω(2 2 l ∗ m 1 − 6 η ) 4 k ∗ ,

Proof. The simple, but fundamental, observation we need to make here is that the ﬂow ˆf – being an electrical ˆ σ -ﬂow induced by vertex potentials φ via relationship (5) – is always ﬂowing in one direction, i.e., from left to right, with respect to the line embedding given by φ . This, together with the fact that ˆf is a ˆ σ -ﬂow, implies that

On the other hand, f is also a feasible ˆ σ -ﬂow, which means that the net inﬂow into V + x of f has to be at least v ∈ V + x ˆ σ v . This gives us that

as we wanted to establish.

Electrical Flows and the Central Path

In this section, we describe how we can use electrical ﬂows to advance our solution along the central path. In other words, we describe and analyze the implementation of the improvement step and thus prove Theorem 5.5. This implementation is directly inspired by – and, in fact, can be seen as a reinterpretation of – the improvement steps used in path-following method. t

Recall that in the improvement step, we are given a ˆ γ -centered ˆ σ -feasible solution ( f t , s t , ν t ) and our goal is to compute, in O ( (a)
 m ) time, a ˆ γ -centered ˆ σ -feasible solution ( f t +1 , s t +1 , ν t +1 ) with ˆ µ ( f t +1 , s t +1 , ν t +1 ) (1 δ t )ˆ µ ( f t , s t , ν t ) . (37)

We perform this improvement in two main steps. The ﬁrst one – the descent step – uses the electrical ﬂow ˆf t associated with ( f t , s t , ν t ) and the corresponding vertex potentials φ t that induce it, to perform a primal and dual update that results in a new, intermediate, solution ( ¯f t , ¯ s t , ¯ ν t ) . This intermediate solution is ˆ σ -feasible and has ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ (1 − δ t )ˆ µ ( f t , s t , ν t ) as desired, but it might be not ˆ γ -centered anymore. To ﬁx that, in the second – centering – step, we compute the desired solution ( f t +1 , s t +1 , ν t +1 ) out of ( ¯f t , ¯ s t , ¯ ν t ) by using another electrical ﬂow computation that again provides a primal and dual update.

We describe and analyze both of these steps below. Note that as each of these two steps requires only one computation of electrical ﬂow, it can be easily implemented to run in O ( (mt)
 m ) time, as needed.

Descent Step Let ˆf t be the electrical ˆ σ -ﬂow associated with the solution ( f t , s t , ν t ) and let φ t be the vertex potentials that induce ˆf t . Consider a new primal-dual solution ( ¯f t , ¯ s t , ¯ ν t ) given by

for each arc e = ( v, u ) in G , where δ t satisﬁes conditions of the theorem and we also used the deﬁnition (14) of the resistances that determine ˆf t , as well as, the relationship (5) between electrical ﬂow and the vertex potentials that induce it. Observe that as ¯f t is a convex combination of two ˆ σ -ﬂows – the ﬂows f t and ˆf t – it also is an

Observe that as ¯f t is a convex combination of two ˆ σ -ﬂows – the ﬂows f t and ˆf t – it also is an ˆ σ -ﬂow. Furthermore, as all ν te 1 , we have ρ ( ˆf t , f t ) ν t , 4 ρ ( ˆf t , f t ) ∞ and thus, for each arc e ,

¯ f te = (1 − δ t ) f te + δ t ˆ f te ≥ (1 − δ t ) f te − δ t | ˆ f te | = (1 − δ t − δ t ρ ( ˆf t , f t ) e ) f te ≥ (1 − 1 2 − ˆ γ ) f te > 0 , (41)

So, by deﬁnition (10) and the fact that ( δ t ρ ( ˆf , f t ) e ) 2 (1 − δ t ) 0 for all e , we see that

and this inequality would be an equality if the second-order terms (i.e., terms quadratic in δ t ) were ignored. (Also, if these terms were not present, the centrality of the solution would be preserved too.)

Finally, let us focus on analyzing the centrality of ( ¯f t , ¯ s t , ¯ ν t ) . To this end, note that by deﬁnition (11) and by (42) above we have

t , 2 ≤ ˆ¯ µ − (1 − δ )ˆ µ ( f , s , ν ) 1 ¯ ν t , 2 ≤ e ¯ ν te (ˆ¯ µ te − (1 − δ )ˆ µ ( f , s , ν )) = e ν te (1 − δ t )(ˆ µ te − ˆ µ ( f t , s t , ν t )) − ( δ t ρ ( ˆf t , f t ) e ) 2 (1 − δ t ) ˆ µ te 2 ≤ 2 (1 − δ t ) 2 e ν te (ˆ µ te − ˆ µ ( f t , s t , ν t )) 2 + e ν te ( δ t ρ ( ˆf t , f t ) e ) 4 (1 − δ t ) 2 (ˆ µ te ) 2 ≤ 2 (1 − δ t ) 2 ˆ µ t − ˆ µ ( f t , s t , ν t ) 1 2 ν t , 2 + (1 + ˆ γ ) 2 ˆ µ ( f t , s t , ν t ) 2 (1 − δ t ) 2 ( δ t ) 4 e ν te ρ ( ˆf t , f t ) ≤ 2 (1 − δ t ) 2 ˆ γ 2 ˆ µ ( f t , s t , ν t ) 2 + (1 + ˆ γ ) 2 ˆ µ ( f t , s t , ν t ) 2 (1 − δ t ) 2 ( δ t ) 4 e ν te ρ ( ˆf t , f t ) 4 e ≤ 2 (1 − δ t ) 2 ˆ γ 2 + (1 + ˆ γ ) 2 (1 − δ t ) 2 ( δ t ) 4 uv
 ρ ( ˆf t , f t ) Ve
 4 ν t , 4 ˆ µ ( f t , s t , ν t ) 2 ≤ 10ˆ γ 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) 2 .

In the above derivation, the ﬁrst inequality follows as the a
 µ − t 1 ν , 2 is always minimized by taking t = ˆ µ ( f , s , ν ) . We also used the fact that ( f t , s t , ν t ) is ˆ γ -centered, Fact 5.3 and the upperbound on δ t .

Therefore, we see that the price of making progress on the duality gap is that the centrality of our solution could deteriorate by a factor of at most three.

Centering Step To alleviate this possible increase of centrality, we apply a second step that restores the centrality back within the desired bounds while not increasing the duality gap (so to not to counter the progress on the duality gap that we just achieved). To this end, consider a ﬂow ¯f ∗ in G deﬁned as

for every arc e of G . Note that the ﬂow ¯f ∗ might (and actually will) not be feasible in G , as of ¯ f ∗ e can be negative. Now, consider a ﬂow ¯f given by

for each arc e . Observe that ¯f is feasible in G (i.e., ¯ f e 0 , for all e ) and

for each arc e . That is, ( ¯f , ¯ s t , ¯ ν t ) is 0 -centered with ˆ µ ( ¯f , ¯ s t , ¯ ν t ) = ˆ µ ( ¯f t , ¯ s t , ¯ ν t )

So, this solution would be a perfect candidate for ( f t +1 , s t +1 , ν t +1 ) except that the ﬂow ¯f does not need to be a ˆ σ -ﬂow and thus this solution might not be ˆ σ -feasible. To ﬁx that – and obtain our desired solution ( f t +1 , s t +1 , ν t +1 ) – let ˜ σ be the demand vector of the ﬂow ¯f ∗ , and consider an electrical ˜ σ -ﬂow ˜f t that corresponds to resistances

for each arc e and let ˜ φ be the corresponding vertex potentials. Let us deﬁne ( f t +1 , s t +1 , ν t +1 ) to be

Clearly, now f t +1 is a ˆ σ -ﬂow, as desired. Let us analyze its centrality. To this end, let us ﬁx some arc e , and notice that

ˆ µ t +1 e = f t +1 e s t +1 e ν t +1 e = ( ¯ f e + ˜ f te )(¯ s te − ¯ s te ¯ f e ˜ f te ) ν t +1 e = (¯ ν te ) − 1 ¯ f e ¯ s te + ¯ s te ˜ f te − ¯ s te ˜ f te − ¯ s te ¯ f e ( ˜ f te ) 2 = ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) − ¯ s te ¯ ν te ¯ f e ( ˜ f te ) 2 ,

where we used (46). So, we see in particular that

ˆ µ ( f t +1 , s t +1 , ν t +1 ) ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) (1 δ t )ˆ µ ( f t , s t , ν t )

Now, by our derivation above, we have that

To bound the resulting expression, let us note that by Cauchy-Schwarz inequality and the fact that measures are always at least 1 we have

Now, the key insight here is that by (47),

So, by bounding the energy of the electrical ﬂow ˜ f te we will be able to bound the centrality of our solution ˆ µ ( f t +1 , s t +1 , ν t +1 ) . To bound this energy, we will ﬁrst bound the energy E ˜r t ( ¯f ∗ ) of the ﬂow ¯f ∗ and use the fact that both ¯f ∗ and ˜f t are ˜ σ -ﬂows and thus, by deﬁnition, ˜f t is minimizing the energy among all the ˜ σ -ﬂows. Observe that by deﬁnition (44) of the ﬂow ¯f ∗ , the fact that ( ¯f t , ¯ s t , ¯ ν t ) is 3ˆ γ -centered – cf. (43)

Observe that by deﬁnition (44) of the ﬂow ¯f ∗ , the fact that ( ¯f t , ¯ s t , ¯ ν t ) is 3ˆ γ -centered – cf. (43) – and Fact 5.3, we have that

E ˜r t ( ¯f ∗ ) = e ¯ s te ¯ f e ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ˆ¯ µ te ¯ f te 2 ≤ e ¯ ν te ˆ¯ µ te ¯ f e (ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t )) 2 ¯ f te (1 − 3ˆ γ )ˆ¯ µ te ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ 1 (1 − 3ˆ γ ) e ¯ ν te (ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t )) 2 ¯ f te ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ¯ f e = 1 (1 − 3ˆ γ ) e ¯ ν te (ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t )) 2 ˆ¯ µ te ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) 2 ≤ (1 + 3ˆ γ ) (1 − 3ˆ γ ) e ¯ ν te (ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t )) 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) = (1 + 3ˆ γ ) (1 − 3ˆ γ ) ˆ¯ µ t − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) 1 2 ¯ ν t , 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ (1 + 3ˆ γ ) (1 3ˆ γ )9ˆ γ 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ 10ˆ γ 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ 20ˆ γ 2 ˆ µ ( f t +1 , s t +1 , ν t +1 ) ,

where we also used the deﬁnition (45) of the ﬂow ¯f . In the light of the above discussion, we can conclude that

as ˆ γ ≤ 120 . So, indeed ( f t +1 , s t +1 , ν t +1 ) is ˆ γ -centered. Now, to prove that ( f t +1 , s t +1 , ν t +1 ) is also ˆ σ -feasible, we just need to show that for any arc e ,

To this end, note that by (46) and (49) we have

Thus, indeed, we can conclude that we obtained a ˆ γ -centered ˆ σ -feasible solution ( f t +1 , s t +1 , ν t +1 ) with ˆ µ ( f t +1 , s t +1 , ν t +1 ) ≤ (1 − δ t )ˆ µ ( f t , s t , ν t ) , as desired. This concludes the proof of the ﬁrst part of the Theorem 5.5. The proof of the second part appears in Appendix F.

In this section, we show how given a fractional b -matching x in some bipartite graph G = ( P ∪ Q, E with m = | E | edges, one can ﬁnd in O ( m ) time an integral b -matching x ∗ in G whose size is at least x 1 . In other words, we prove Theorem 3.3.

Rounding Perfect Matchings

Let us ﬁrst consider the case when x is just a fractional perfect matching, i.e., b v = 1 for all vertices and the size | x | 1 of x is | b | 1 2 , i.e., the fractional degree of each vertex in x is 1 . We claim that in this case we can just use Theorem 2.4 to obtain an integral perfect matching in O ( m ) time.

To see why this is the case, consider a | P | × | Q | matrix M x in which rows and columns are indexed by vertices from P and Q , respectively, and the entries are given by M x p,q := x ( p,q ) if the edge ( p, q ) exists in G ; and 0 , otherwise. Observe that if x is perfect and all b v are equal to 1 then we need to have | P | = | Q | . Thus, M x is a square matrix. Furthermore, M x needs to be also doubly-stochastic, as for any row indexed by vertex p ∈ P (resp. column indexed by vertex q ∈ Q ), the sum q ∈ Q M x p,q (resp. p ye
 ∈ P M x p ,q ) of the entries in this row (resp. column) is equal to a
 e ∈ E ( p ) x e = b p = 1 (resp. e ∈ E ( q ) x e = b q = 1 ). So, invoking Theorem 2.4, we can obtain in O ( m ) time an integral matching x ∗ in the support of M x that is also the support of the edge set

O ( m ) time an integral matching x ∗ in the support of M x that is also the support of the edge set E of our graph G .

Rounding Non-Perfect Matchings

Now, to recover the desired integral matching in the case when x is not necessarily perfect (but still all b v are equal to 1 ), our ﬁrst step is to extend x to a perfect matching ¯ x in a certain augmented graph ¯ G that is created from G by adding some dummy edges and vertices to it. More precisely, let d P (resp. d Q ) be the total deﬁcits of vertices in P (resp. in Q ), i.e.,

Note that the size | x | 1 of x has to be exactly | P | − d P = | Q | − d Q . We add to the vertex set Q , d P (resp. to the vertex set P , d Q ) dummy vertices ¯ q 1 , . . . , ¯ q d P “
 (resp. ¯ p 1 , . . . , ¯ p d Q ). Next, we extend the fractional matching x to ¯ x by going over each non-dummy vertex p ∈ P (resp. q ∈ Q ) and fractionally matching it to the dummy vertices ¯ q 1 , . . . , ¯ q Ifa
 d P (resp. ¯ p 1 , . . . , ¯ p Pid
 d Q 21)
 ), so to ensure that its fractional degree becomes 1 and the fractional degree of dummy vertices never exceeds one. It is not hard to see that by employing a simple greedy approach we can achieve this goal in Of
 O ( m ) time and, furthermore, ensure that: (1) each non-dummy vertex is matched to at most two dummy vertices in ¯ x ; (2) at the end, there are at most two dummy vertices, say, ¯ p d Q and ¯ q d P rl:
 , (one on each side of the bipartition) that are yet not fully matched in ¯ x . To alleviate the latter problem, we just match these two dummy vertices to each other (one can check that their deﬁcits have to be equal) and take the set of edges ¯ E of our augmented graph ¯ G to be the support of the matching ¯ x . (Note that by property (1), the size of this support will be still O ( m ) .)

Clearly, ¯ x is a perfect matching in ¯ G , so we can use the Of
 O ( m ) -time procedure we described above to get an integral perfect matching ¯ x ∗ in that graph. Once we do that, we take our desired integral matching x ∗ in G to be ¯ x ∗ after we removed from it all the edges of ¯ x ∗ that are not in G i.e., all the edges that are incident to dummy vertices. Obviously, x ∗ is a feasible matching in G and it is integral. To see that its size is at least (cid:98)| x | 1 , note that, as there is at most d P + d Q a
 dummy vertices in ¯ G , there could be at most that many edges incident to these vertices in ¯ x ∗ . But, as ¯ x ∗ is perfect, its size is equal to

where we used the fact that | P | − d P = | Q | − d Q = | x | 1 . Thus, indeed after removing at most d P + d Q an
“oe
 edges from ¯ x ∗ , the resulting integral matching x ∗ will have its size | x ∗ | 1 to be at least x 1 , as desired.

Rounding b -Matchings

In the light of the above, it remains to show how to deal with the case when in the demand vector b there are some b v that are bigger than 1 (and thus some of the entries of x could be bigger than 1 , as well). To this end, let us observe ﬁrst that if there is an edge e = ( p, q ) with x e ≥ 1 , we can just subtract x e el
 copies of this edge from our matching right away, while decreasing the demands b p and b q of e ’s endpoints accordingly, i.e., by x e . (Note that by feasibility of x , b p , b q ≥ x e .) So, one can see that if ¯ x is the fractional matching x after we made such transformation and ¯b are the corresponding demands, then once we compute an integral ¯b -matching ¯ x ∗ of size at least (cid:98)| ¯ x | 1 from ¯ x , we can just add back these subtracted x e copies of edge e to ¯ x ∗ to obtain the desired integral b -matching x ∗ of size at least ¯ x 1 + x e = x 1 .

Therefore, we can assume from now on that in our b -marching x all x e s are smaller than one (but still we can have some demands b v to be bigger than one). To round such fractional b -matchings, for each vertex v ∈ V that has its demand b v bigger than 1 , we split it into b v vertices v 1 , . . . , v b v – each with demand one. Next, for every edge e that was previously incident to v , we connect it to the new vertices and distribute its fractional weight x e in x among these new vertices. Again, by applying a simple greedy approach we can ensure that each edge is connected to at most two among the vertices v 1 , . . . , v b v and none of these vertices has its fractional degree bigger than 1 . (Note that this means, in particular, that once we apply such splitting to all vertices with b v > 1 then the support of the corresponding “split” fractional matching is at most by a factor of four larger than the support of x .) Clearly, at this point, we are again in situation where we just need to round a fractional bipartite matching (with all demands being at most 1 ). Thus, we can use our rounding procedure we described above and recover the integral matching we are seeking. This ﬁnishes the proof of Theorem 3.3.

Acknowledgments. We are grateful to Andrew Goldberg, Jonathan Kelner, Lap Chi Lau, Gary Miller, Richard Peng, Seth Pettie, Daniel Spielman, and Shang-Hua Teng for a number of helpful discussions on this topic. We also thank Monika Henziger, Satish Rao, and Jens Vygen for useful feedback on the manuscript.

References

[ABMP91] H. Alt, N. Blum, K. Mehlhorn, and M. Paul. Computing a maximum cardinality match- ing in a bipartite graph in time O ( n 1 . 5 m/ log n ) . Inf. Process. Lett. , 37(4):237–240, 1991.

[AHK

] S. Arora, E. Hazan, and S. Kale. The multiplicative weights update method: a meta- algorithm and applications. Theory of Computing ,

(

):

–

,

[AHU

] A. V. Aho, J. E. Hopcroft, and J. D. Ullman. The Design and Analysis of Computer Algorithms . Addison-Wesley Longman Publishing Co., Boston, MA, USA,

st edition,

S. Boyd and L. Vandenberghe. Convex Optimization . Cambridge University Press, 2004.

J. Edmonds. Paths, trees, and ﬂowers. Canadian Journal of Mathematics , 17:449–467,

J. Egerváry. Matrixok kombinatorius tulajdonságairól. Matematikai és Fizikai Lapok

A. V. Goldberg and A. V. Karzanov. Maximum skew-symmetric ﬂows and matchings. Mathematical Programming , 100(3):537–568, 2004.

A. Goel, M. Kapralov, and S. Khanna. Perfect matchings in O(n log n) time in regular bipartite graphs. In STOC’10: Proceedings of the 42nd Annual ACM Symposium on Theory of Computing , pages 39–46, 2010.

J. Hopcroft and R. Karp. An n 5 / 2 algorithm for maximum matchings in bipartite graphs. SIAM Journal on Computing , 2(4):225–231, 1973.

[Hof

] A. J. Hoﬀman. Some recent applications of the theory of linear inequalities to extremal combinatorial analysis. In Proceedings of Symposia in Applied Mathematics , volume pages

–

,

[Kar

] A. V. Karzanov. O nakhozhdenii maksimal’nogo potoka v setyakh spetsial’nogo vida nekotorykh prilozheniyakh. Matematicheskie Voprosy Upravleniya Proizvodstvom ,

,

(in Russian; title translation: On ﬁnding maximum ﬂows in networks special structure and some applications). [KKL

] S. Khanna, T. C. Kwok, and L. C. Lau,

Personal communication. [KLOS

] J. A. Kelner, Y. T. Lee, L. Orecchia, and A. Sidford. An almost-linear-time algorithm for approximate max ﬂow in undirected graphs, and its multicommodity generalizations.

[KMP

] I. Koutis, G. L. Miller, and R. Peng. Approaching optimality for solving SDD tems. In FOCS’

: Proceedings of the

st Annual IEEE Symposium on Foundations of Computer Science , pages

–

,

[KMP

] I. Koutis, G. L. Miller, and R. Peng. A nearly m log n -time solver for SDD systems. In FOCS’

: Proceedings of the

nd Annual IEEE Symposium on Foundations of Computer Science , pages

–

,

[Kön

] D. König. Graphok és matrixok. Matematikai és Fizikai Lapok ,

:

–

,

[KOSZ

] J. A. Kelner, L. Orecchia, A. Sidford, and Z. A. Zhu. A simple, combinatorial algorithm for solving SDD systems in nearly-linear time. In STOC’

: Proceedings of the Annual ACM Symposium on the Theory of Computing , pages

–

,

[KRT

] V. King, S. Rao, and R. Tarjan. A faster deterministic maximum ﬂow algorithm. Journal of Algorithms ,

(

):

–

,

[Lau

] L. C. Lau,

Personal communication.

A. J. Hoﬀman. Some recent applications of the theory of linear inequalities to extremal combinatorial analysis. In Proceedings of Symposia in Applied Mathematics , volume 10, pages 113–127, 1960.

A. V. Karzanov. O nakhozhdenii maksimal’nogo potoka v setyakh spetsial’nogo vida i nekotorykh prilozheniyakh. Matematicheskie Voprosy Upravleniya Proizvodstvom , 5:81– 94, 1973. (in Russian; title translation: On ﬁnding maximum ﬂows in networks with special structure and some applications).

S. Khanna, T. C. Kwok, and L. C. Lau, 2013. Personal communication.

D. König. Graphok és matrixok. Matematikai és Fizikai Lapok , 38:116–119, 1931.

J. A. Kelner, L. Orecchia, A. Sidford, and Z. A. Zhu. A simple, combinatorial algorithm for solving SDD systems in nearly-linear time. In STOC’13: Proceedings of the 45th Annual ACM Symposium on the Theory of Computing , pages 911–920, 2013.

V. King, S. Rao, and R. Tarjan. A faster deterministic maximum ﬂow algorithm. Journal of Algorithms , 17(3):447–474, 1994.

L. C. Lau, 2013. Personal communication.

L. Lovász. On determinants, matchings and random algorithms. Fundamentals of Com- putation Theory , 565–574, 1979.

L. Lovász and D. M. Plummer. Matching Theory . Elsevier Science, 1986.

Y. T. Lee, S. Rao, and N. Srivastava. A new approach to computing maximum ﬂows using electrical ﬂows. In STOC’13: Proceedings of the 45th Annual ACM Symposium on the Theory of Computing , pages 755–764, 2013.

A. Mądry. Fast approximation algorithms for cut-based problems in undirected graphs. In FOCS’10: Proceedings of the 51st Annual IEEE Symposium on Foundations of Com- puter Science , pages 245–254, 2010.

A. Mądry. From Graphs to Matrices, and Back: New Techniques for Graph Algorithms . PhD thesis, Massachusetts Institute of Technology, 2011.

M. Mucha and P. Sankowski. Maximum matchings via Gaussian elimination. In FOCS’04: Proceedings of the 45th Annual IEEE Symposium on Foundations of Com- puter Science , pages 248–255, 2004.

S. Micali and V. V. Vazirani. An O ( (6/7
 | V |·| E | ) algoithm for ﬁnding maximum matching in general graphs. In FOCS’80: Proceedings of the 21st Annual IEEE Symposium on Foundations of Computer Science , pages 17–27, 1980.

J. B. Orlin. Max ﬂows in o(nm) time, or better. In STOC’13: Proceedings of the 45th Annual ACM Symposium on the Theory of Computing , pages 765–774, 2013.

M. O. Rabin and V. V. Vazirani. Maximum matchings in general graphs through ran- domization. J. Algorithms , 10(4):557–567, December 1989.

A. Schrijver. Combinatorial Optimization: Polyhedra and Eﬃciency . Springer, 2003.

J. Sherman. Nearly maximum ﬂows in nearly linear time. In FOCS’13: Proceedings of the 54th Annual IEEE Symposium on Foundations of Computer Science , 2013.

D. A. Spielman and S.-H. Teng. Solving sparse, symmetric, diagonally-dominant linear systems in time O ( m 1 . 31 ) . In FOCS’03: Proceedings of the 44th Annual IEEE Sympo- sium on Foundations of Computer Science , 2003.

D. A. Spielman and S.-H. Teng. Nearly-linear time algorithms for graph partitioning, graph sparsiﬁcation, and solving linear systems. In STOC’04: Proceedings of the 36th Annual ACM Symposium on the Theory of Computing , pages 81–90, 2004.

Society ,

:

–

,

[Vaz

] V. V. Vazirani. A theory of alternating paths and blossoms for proving correctness of the O ( | V || E | ) general graph matching algorithms. Combinatorica ,

(

):

–

,

[VW

] V. Vassilevska Williams. Multiplying matrices faster than Coppersmith-Winograd. In STOC’

: Proceedings of the

th Annual ACM Symposium on the Theory of Comput- ing ,

[Wri

] S. J. Wright. Primal-Dual Interior-Point Methods . Society for Industrial and Applied Mathematics,

[Ye

] Y. Ye. Interior Point Algorithms: Theory and Analysis . John Wiley & Sons,

V. V. Vazirani. A theory of alternating paths and blossoms for proving correctness of the O ( V E ) general graph matching algorithms. Combinatorica , 14 (1):71–109, 1994.

Y. Ye. Interior Point Algorithms: Theory and Analysis . John Wiley & Sons, 1997.

Proof of Lemma 2.1

Let C ∗ be the value of right-hand side of the equality we need to establish, and - for notational convenience - let us denote the energy E r ( f ∗ ) as E ∗ . So, our goal is to show that C ∗ = 1 /E ∗ and that taking ˜ φ attains the minimum C ∗ .

We start by noting that, for any vertex potentials φ , we have

where we used the fact that f ∗ is a σ -ﬂow (cf. (1)). Note that by the above calculations and the deﬁnition of ˜ φ we have

where we used (5) and the deﬁnition of energy (4). Therefore, we see that C ∗ 1 /E ∗ as

Now, let φ be the potential such that ( u,v ) ∈ E ( φ v − φ u ) r ( u,v ) = C ∗ and let ˆf with ˆ f ( u,v ) := φ v − φ u r ( u,v ) , for each ( u, v ) ∈ E , be the corresponding ﬂow induced via 5. (Note that in principle ˆf does not need to be a σ -ﬂow). From (51) we get that

where we again used (5) and the fact that σ T φ = 1 by deﬁnition.

We claim that the energy E r ( ˆf ) of ˆf (and thus the value of C ∗ ) is at least 1 /E ∗ . To this end, let us note that

E r ( ˆf ) = ˆf T Rˆf = ty
 f ∗ E ∗ + ˆf − f ∗ E ∗ T R f ∗ E ∗ + ˆf − f ∗ E ∗ = ( f ∗ ) T Rf ∗ ( E ∗ ) 2 − 2( f ∗ ) T E ∗ R ˆf − f ∗ E ∗ + ˆf − f ∗ E ∗ T R ˆf − f ∗ E ∗ . As we have seen in (54), ( f ∗ ) T Rˆf = 1 , thus ( f ∗ ) T E ∗ R ˆf − f ∗ E ∗ = 0 and we can write E r ( ˆf ) = ( f ∗ ) T Rf ∗ ( E ∗ ) 2 − 2( f ∗ ) T E ∗ R ˆf − f ∗ E ∗ + ˆf − f ∗ E ∗ T R ˆf − f ∗ E ∗ = 1 E ∗ + ˆf − f ∗ E ∗ T R ˆf − f ∗ E ∗ ≥ 1 E ∗ ,

≥ So, C ∗ ≥ 1 /E ∗ too and thus C ∗ = 1 /E ∗ . Also, by (52) and (53) we see that ˜ φ indeed attains the minimum, as desired.

B Proof of Corollary 3.4

Let f be a fractional feasible s - t ﬂow of value F in G and let us consider ﬁrst the case when F is integral. Recall that the reduction presented in Section 4 allows one to obtain in O ( m ) time an instance of bipartite b -matching problem – corresponding to some bipartite graph ¯ G – that has a property that if there exists a feasible s - t ﬂow of value F in G then ¯ G has a perfect b -matching. Now, the crucial observation is that the proof of that property presented in Section 4 is fully constructive and, in particular, provides an O ( m ) -time algorithm that produces such a perfect b -matching in ¯ G out of a feasible s - t ﬂow in G of value F . Furthermore, this construction also works for fractional ﬂows, it just produces a perfect b -matching that is fractional.

In the light of the above, we can simply apply this transformation to our ﬂow f and get a fractional perfect b -matching x in ¯ G . Next, we can use the rounding procedure from Theorem 3.3 to obtain in O ( m ) time a perfect b -matching x ∗ in ¯ G that is integral. (Note that since b is always integral, so is the size of any perfect b -matching.) This, in turn, allows us to utilize another property of the graph ¯ G that was established in Section 4. Namely, that out of any integral perfect b -matching in ¯ G , one can extract – in Ol
 O ( m ) time – an integral and feasible s - t ﬂow f ∗ in G of value F . Clearly, by combining all of the above steps, we get our desired integral s - t ﬂow.

Finally, to deal with the case when F is not integral, we just add an arc ( s, t ) to G , set its capacity to 1 , and put a ﬂow of h
 F − F ≤ 1 on it. Obviously, now we have a feasible s - t ﬂow of value F in such modiﬁed graph G and F bk
 is integral. Therefore, we can use our approach we described above to get an integral and feasible s - t ﬂow f ∗ in this graph and f ∗ will have a value of sm
 F ait
 . Note that f ∗ can have non-zero ﬂow on the arc ( s, t ) that we added, but as this arc has capacity of 1 , there can be exactly one unit of ﬂow on this arc. So, if we simply remove it from f ∗ , we will get an integral and feasible s - t ﬂow in the original graph G and the value of f ∗ will be F 1 = F , as desired. This concludes the proof of the corollary.

Appendix to Section 4

Correctness Analysis

It is easy to verify that the produced b -matching instance is indeed bipartite (we have edges only between diﬀerent sides of bipartition P and Q ), has exactly 2( m + n − 1) = Θ( m ) vertices, 3 m + n − 2 ≤ 4 m edges, and | b | 1 ≤ 4 | u | 1 . So, we just need to establish the claimed connection to existence of feasible s - t ﬂows in the graph G .

From Flow f to Perfect b -matching x

To this end, assume that there exists a feasible s - t ﬂow f in G of value F . To see that a perfect b -matching in ¯ G exists, consider a b -matching x that, for each arc e = ( u, v ) in G , takes exactly f e edges ( p e , q e ) and u e − f e edges ( q u , p e ) and ( q e , p v ) . Then, for every vertex v of G other than s and t , x takes e ∈ E + ( v ) f e copies of the edge ( p v , q v ) .

To see that x is indeed a perfect b -matching, observe that due to feasibility of f (cf. (2)), 0 ≤ f e ≤ u e for each arc e , and thus x ≥ 0 . Also, by the construction of x , all vertices p e and q e have exactly u e edges adjacent to them in x . So, they are fully matched. To see that all vertices p v and q v are fully matched too, consider some v = s, t . Indeed, by deﬁnition of x , we have exactly e ∈ E + ( v ) u e − f e + e ∈ E + ( v ) f e = e ∈ E + ( v ) u e = b p v (resp. e ∈ E − ( v ) u e − f e + e ∈ E − ( v ) f e = Mt
 e ∈ E − ( v ) u e = b q v ) edges adjacent to p v (resp. q v ), where we used the fact that e ∈ E + ( v ) f e = Mt
 e ∈ E − ( v ) f e , as f obeys ﬂow conservation constraints (1). Finally, in the case of vertex q s (resp. p t ) we have that their degree in x is exactly e ∈ E − ( s ) u e − f e = ( e ∈ E − ( s ) u e ) − F = b q s (resp. e ∈ E + ( t ) u e − f e = ( e ∈ E + ( t ) u e ) − F = b p t ), due to the value e ∈ E − ( s ) f e = e ∈ E + ( t ) f e of the ﬂow f being exactly F . So, indeed such x is perfect, as claimed.

From Perfect b -matching x to Flow f

Now, to see that given a perfect b -matching x in ¯ G we can quickly, i.e., in O ( m ) time, recover an s - t ﬂow of value F that is feasible in G , consider a ﬂow f given by f e = x ( p e ,q e ) for each arc e in G . That is, the ﬂow f e on an arc e is equal to the number of times a copy of an edge ( p e , q e ) appears in x . Note that as the demands b p e and b q e of the endpoints of each edge ( p e , q e ) are equal to u e , f is feasible in G .

Finally, to prove that f also preserves ﬂow conservation constraints (cf. (1)), note that as x is perfect, it has to be that for any vertex v and e ∈ E + ( v ) (resp. e ∈ E − ( v ) ) x ( p v ,q e ) = b q e − x ( p e ,q e ) = u e − f e (resp. x ( p e ,q v ) = b p e − x ( p e ,q e ) = u e − f e ). So, if we do not take into account the edges ( p v , q v ) , each vertex p v (resp. q v ) has exactly e ∈ E + ( v ) b q e − x ( p e ,q e ) = e ∈ E + ( v ) u e − f e (resp. e ∈ E − ( v ) b p e − x ( p e ,q e ) = e ∈ E − ( v ) u e − f e ) edges adjacent to it in x . This means, in particular, that in case of q s (resp. p t ) we need to have that e ∈ E − ( s ) u e − f e = b q s = ( e ∈ E − ( s ) u e ) − F (resp. e ∈ E + ( t ) u e − f e = b p t = ( e ∈ E + ( t ) u e ) − F ) and thus e ∈ E − ( s ) = F (resp. e ∈ E + ( t ) f e = F ), i.e., the value of f is F . Furthermore, for any vertex v other than s and t , as x is perfect, w need to have that e ∈ E + ( v ) u e = b p v = x ( p v ,q v ) + e ∈ E + ( v ) u e − f e (resp. e ∈ E − ( v ) u e = b q v = x ( p v ,q v ) + e ∈ E − ( v ) u e − f e ). Therefore, e ∈ E + ( v ) f e = x ( p v ,q v ) = e ∈ E − ( v ) f e , i.e., f obeys all ﬂow conservation constraints. So, indeed f is a feasible s - t ﬂow of value F in G , as desired.

Lastly, it is worth pointing out that even though in the above proof we assume that both the s - t ﬂow f and the b -matching x are integral, the proof goes through unchanged in the case when

f and x are fractional. We just will have that if f is fractional then so will be the corresponding b -matching x and vice versa.

Appendix to Section 5

Let us take s 0 to be the all-ones vector 1 (this corresponds to y 0 assigning zero value to all vertices). Next, let the ﬂow f 0 and measures ν 0 be deﬁned as follows.

For each arc of the form ( s p , t q ) in G , we give it a measure of one in ν 0 and a ﬂow of one unit is sent through it in f 0 . Now, for each vertex s p (resp. t q ) in G , let r p := | E − ( s p ) | − 1 − b p (resp. r q := | E + ( t q ) | − 1 − b q ). If r p ≥ 0 (resp. r q ≥ 0 ) then we put a ﬂow of one and measure of one on the arc ( s p , v ∗ ) (resp. ( v ∗ , t q ) ) and a ﬂow and measure of r p + 1 (resp. r q + 1 ) on the arc ( v ∗ , s p ) (resp. ( t q , v ∗ ) ). On the other hand, if r p < 0 (resp. r q < 0 ) then we put a ﬂow and measure of 1 − r p (resp. 1 − r q ) on the arc ( s p , v ∗ ) (resp. ( v ∗ , t q ) ) and a ﬂow and measure of one on the arc ( v ∗ , s ) (resp. ( t , v ∗ ) ).

One can verify that the resulting ﬂow f 0 is indeed a ˆ σ -ﬂow (again, one needs to use here the fact that p b p = q b q , as otherwise there is no perfect b -matching in G ) and thus the solution is primal-dual feasible.

Also, the total measure e ν 0 e of all the arcs is at most m + | b | 1 ≤ 3 sin.
 m . Finally, we have that ˆ µ 0 e = f 0 e s 0 e ν 0 e = 1 for all arcs e and thus the solution is indeed 0 -centered and ˆ µ ( f 0 , s 0 , ν 0 ) = 1 , as desired.

That (1 − γ ) α ≤ β ≤ (1 + γ ) α follows directly from Fact 5.3. Let us show now that ˆ µ ( f , s , ν ) = ˆ µ ( f , s , ν ) . To this end, let us deﬁne γ e so as

Now, to bound the centrality of ( f , s , ν ) , we need to bound the value of a
 ˆ µ − ˆ µ ( f , s , ν ,
 ) 1 ν , 2 . However, as ˆ µ ( f , s , ν ) = ˆ µ ( f , s , ν ) and the two solution coincide on all the arcs except e , it suﬃces to analyze the change in contribution of arc e to the centrality of the solution. Namely, we just need to show that

To this end, observe the right side of the above inequality is just

ν e f e s e ν e − ˆ µ ( f , s , ν ) = ν e γ 2 e ˆ µ ( f , s , ν ) 2 . So, we need to show that ν e ν e ˆ µ ( f , s , ν ) 2 ra
 f fils
 e s ~S
 e ν e − ˆ µ ( f , s , ν ) 2 = (1 + β ) (1 + α )(1 + γ e ) (1 + β ) − 1 2 ≤ γ 2 e . But this is true as (1 + β ) (1 + α )(1 + γ e ) (1 + β ) − 1 \!
 2 = ((1 + α )(1 + γ e ) − 1 − (1 + γ e ) α ) 2 1 + (1 + γ e ) α = γ 2 e 1 + (1 + γ e ) α ≤ γ 2 e where we used that fact that (1 + γ e ) 12 since, by Fact 5.3, (1 + γ e ) (1 γ ) 12 .

where we used that fact that (1 + γ e ) 12 since, by Fact 5.3, (1 + γ e ) (1 γ )

E.2 Proof of Lemma 6.5

Note that by construction of the graph G and by Invariant 6.4, we have that for any two vertices v , v in G there is a directed path from v to v , as well as, a one from v and v , with each one of them consisting of at most two arcs and having length at most 4 . As ( f , s , ν ) is σ -feasible then it is, in particular, dual feasible. So, this implies that if y is the embedding of the vertices of G into a line corresponding to the slack variables s , then | y v − y v | is at most 4 as well. Thus, we can conclude that for any arc e = ( v, v ) in G , we have that s e = ˆ l e − y v + y v ≤ ˆ l e + | y v − y v | is at most 6 , as

E.3 Proof of Lemma 6.6

Note ﬁrst that all the arcs in the original version of G have length 1 and α -stretching can only increase these lengths. This means that it is still true – as in the proof of Lemma 5.1 – that ˆ l ( f ) − | b | 1 2 is an upper bound on the total ﬂow between the vertices s p and t q that is not ﬂowing over the direct arcs ( s p , q t ) reﬂecting the original edges of G .

Furthermore, as by Invariant 6.4 the total increase in the length of the arcs of G is O ( m 12 − η ) , the cost ˆl ( f ∗ ) of the ﬂow that encodes the perfect b -matching in G (cf. the proof of Lemma 5.1), can increase to at most | b | 1 2 + O ( m 12 − η ) . (We use here the fact that f ∗ never ﬂows more than one unit of ﬂow through any of the arcs.) So, we can assume that the cost ˆl ( f ) of the ﬂow f we have is also | b | 1 + O ( m 1 2 − η ) , as otherwise we could conclude that no perfect b -matching exists in G .

2 However, then it must be the case that the total ﬂow in f that does not correspond to taking the direct arcs is at most O ( (i
 m 12 − η ) . Thus, the fractional b -matching obtained by taking only the ﬂow that uses these direct ﬂow-paths will still result in a near-perfect b -matching in G .

E.4 Proof of Lemma 6.8

Note ﬁrst that the upperbound follows directly from Lemma 5.7 as long as we ensure that C E > 4 (which indeed will be the case).

To establish the lowerbound, let us note ﬁrst that without loss of generality we can assume that in our b -matching instance G = ( P ∪ Q, E ) , | P | ≥ | Q | and thus, as our graph G is sparse, P = Ω( (fi)
 m ) . (Otherwise, we just exchange the roles of P and Q in what follows below.)

where E ( s p ) := E + ( s p ) ∪ E − ( s p ) is the set of all arcs incident to s p in G . In other words, ˜r t corresponds to setting to zero resistances (i.e., collapsing) of all the arcs that are not adjacent to some vertex in P ; and making the resistances of arcs that are adjacent to such s p equal to their original resistances in r t . This means, in particular, that ˜ r te ≤ r te , for each arc e , and thus, by Rayleigh Monotonicity principle (cf. Fact 2.2), we know that if ˜f t is the electrical ˆ σ -ﬂow determined by resistances ˜r t then

Therefore, we can just focus on lowerbounding E ˜r t ( ˜f ) . To this end, note that after collapsing all the arcs that were not adjacent to some vertex in P , we can think of G as a graph that consists only of vertices from P and a single vertex w ∗ that represents the remaining collapsed vertices. Furthermore, as there is no arcs in G between diﬀerent vertices s p , all the arcs in this collapsed graph are of the form ( s p , w ∗ ) or ( w ∗ , s p ) for some p ∈ P . t

where R p is the eﬀective resistance between vertex s p and w ∗ with respect to resistances ˜r t and the last equality follows as ˜f t is a ˆ σ -ﬂow and all arcs are connecting to w ∗ . Now, to lowerbound R p , for some p ∈ P , note that by deﬁnition of r t (14), the fact that ν te ≥ 1 for all e , and Fact 5.3, we have that

where F p := e ∈ E ( s p ) f te and we used the well-known formula for eﬀective resistance of a circuit that consists solely of parallel arcs.

So, all the above considerations allow us to observe that

where F = p F p and we used the fact that | ˆ σ s p | ≥ b p ≥ 1 , as well as, that for any n -dimensional vector x , ni =1 1 2 n 3 .

Thus, it remains to provide an upperbound on F . To this end, let us decompose the ﬂow f t into ﬂow-paths (whose endpoints are vertices s p and t q ) and ﬂow-cycles. Clearly, the total contribution of the ﬂow-paths to F can be at most | ˆ σ | 1 ≤ | b | 1 = O ( in)
 m ) , since our b -matching instance is balanced. On the other hand, as length of any ﬂow-cycle is at least two and each ﬂow-cycle contributes its whole volume to the duality gap ( f t ) T s t = e µ te (as ﬂow-cycles do not exist in optimal solution),

the total contribution of ﬂow-cycle to F is at most 12 e µ te . Thus, by (13) and Invariant 5.2, this contribution is at most 12 e µ te = 12 ˆ µ ( f t , s t , ν t )( e ν te ) ≤ 2 m ˆ µ ( f t , s t , ν t ) ≤ 2 m . Therefore, we can conclude that F = O ( (a)
 m ) and since P is Ω( (im)
 m ) we have

E ˜r t ( ˜f t ) ≥ (1 − ˆ γ )ˆ µ ( f t , s t , ν t ) | P | F 2 ≥ C − 1 E m ˆ µ ( f t , s t , ν t ) ,

where C E > 4 is an appropriately chosen constant.

Let us denote by r , ν , and ˆf , respectively, the resistances r t , measures ν t , and electrical ˆ σ -ﬂow ˆf t before stretch-boost and by r , ν , and ˆf the corresponding objects after stretch-boost. Also, let as deﬁne S ∗ := S l ∗ ( ˆf t ) ∩ E tH , where l ∗ is the index of the stretch-boost. In this notation, we want to show that

Clearly, the last inequality follows as ν e ≥ 1 for all arcs e . To see that the second inequality holds, observe that by (22) we have that

and thus

Therefore, once the ﬁrst inequality in (55) is established, our lemma will follow by choosing C S := 136 . So, let us proceed to establishing that inequality. By Lemma 2.1, we know that if φ ∗ is the vector of vertex potentials corresponding to the ﬂow ˆf and resistances r then

where φ v := φ ∗ v / E r ( ˆf ) , for each v , and ˆ σ T ˜ φ = 1 . Now, consider an arc e ∈ S ∗ . By (5), the deﬁnition of the sets S l ∗ ( ˆf t ) (17), and Fact 5.6, we have that

where we also used Lemma 5.7. In other words, the contribution of arc e to the sum in (56) constitutes at least ν e 18 · 2 2 l ∗ -fraction of this sum.

Next, observe that, by deﬁnition of 1 -stretching, we need to have that the resistance doubles, i.e., r e = 2 r e , for all the arcs e ∈ S ∗ , and remains the same for other arcs, i.e., r e = r e , for e / ∈ S ∗ . This means that

e =( u,v ) ∈ E ( φ v − φ u ) 2 r e = 1 2 e =( u,v ) ∈ S ∗ ( φ v − φ u ) 2 r e + e =( u,v ) ∈ E \ S ∗ ( φ v − φ u ) 2 r e = 1 E r ( ˆf ) − 1 2 e =( u,v ) ∈ S ∗ ( φ v − φ u ) 2 r e ≤ 1 E r ( ˆf ) 1 − ν ( S ∗ ) 36 · 2 2 l ∗ .

But, by Lemma 2.1, we know that the above estimation provides an upper bound on the value of 1 E r ( ˆf ) , i.e., we have

where we used the fact that ˆ σ T ˜ φ = 1 , by deﬁnition of ˜ φ . Multiplying both sides by E r ( ˆf ) E r ( ˆf ) 1 − ν ( S ∗ ) 36 · 2 l ∗ and noticing that 1 (1 + x ) for any x 0 , gives us the desired inequality in (55).

Let us denote the solution ( f t , s t , ν t ) by ( f , s , ν ) , the associated electrical ﬂow ˆf t by ˆf , and let r be the resistances r t corresponding to this solution (cf. (14)). Also, let ( f , s , ν /)
 ) , ˆf , and r denote these respective object after the interior-point method step is applied. In this notation, our goal is to show that

To perform such lowerbounding of the energy decrease, we proceed similarly as we did in the proof of Lemma 6.9. Namely, by Lemma 2.1, we know that

where φ e := φ ∗ e / E r ( ˆf ) and σ T ˜ φ = 1 . We want to show that if we keep the same vertex potentials ˜ φ and change the resistances to r then still the corresponding sum – as in the equation above – will not increase by too much (and thus provide a good upperbound on 1 E r ( ˆf ) ).

More speciﬁcally, recall that by Theorem 5.5, for any arc e ,

1 E r ( ˆf ) ≤ e =( u,v ) ∈ E ( φ v − φ u ) 2 r e ≤ e =( u,v ) ∈ E ( φ v − φ u ) 2 r e ≤ e =( u,v ) ∈ E (1 + 2 | κ te | )( φ v − φ u ) 2 r e ,

To establish this last claim, note that for any arc e , r e ( f e ) ˆf is just the fraction of energy of the

ﬂow ˆf (with respect to resistances r ) that is contributed by the arc e . So, by Fact 5.6 and Lemma 6.8, we have that

6.8, we have that r e ( ˆ f e ) 2 E r ( ˆf ) ≤ (1 + ˆ γ ) ν e ˆ µ ( f , s , ν ) ρ ( f , ˆf ) 2 e E r ( ˆf ) ≤ 2 C E ν e 2 2 k , (57) whenever e ∈ S k ( ˆf ) (cf. (17)), for some integer k . As a result, we can conclude that e | κ te | r e ( ˆ f e ) 2 E r ( ˆf ) ≤ 2 l e ∈ T l r e ( ˆ f e ) 2 2 l E r ( ˆf ) ≤ 2   l ≤(cid:98) log ˆ θ − 2 e ∈ T l r e ( ˆ f e ) 2 2 l E r ( ˆf ) + l ≥(cid:100) log ˆ θ − 2 e ∈ T l 2ˆ θ 2 r e ( ˆ f e ) 2 E r ( ˆf )   ≤ 2   l ≤(cid:98) log ˆ θ − 2 e ∈ T l ν e r e ( ˆ f e ) 2 2 l ν e E r ( ˆf )   + 4ˆ θ 2 ≤ 4 C E   l ≤(cid:98) log ˆ θ − 2 k e ∈ T l ∩ S k ( ˆf ) ν e 2 l 2 2 k   + 4ˆ θ 2 = 4 C E   l ≤(cid:98) log ˆ θ − 2 k ν ( T l ∩ S k ( ˆf )) 2 2 k + l   + 4 ˆ θ 2 , where T l denotes T κ t l (cf. (23)), (57), and the fact that l ≥(cid:100) log ˆ θ − 2 6
 e ∈ T l r e ( ˆ f e ) 2 E r ( ˆf ) ≤ e r e ( ˆ f e ) 2 E r ( ˆf ) = E r ( ˆf ) E r ( ˆf ) = 1 . Now, by 2ˆ θ -smoothness of ˆf (cf. Deﬁnition 6.1), we get that

Now, by 2ˆ θ -smoothness of ˆf (cf. Deﬁnition 6.1), we get that

ν ( T l S k ( ˆf )) ˆ θ 3 2 3( k +1)

for each l and k . Also, the fact that by Lemma 6.10 κ t is O (1) -restricted implies that, for any ﬁxed l ,

Therefore, we can see that for any l , we have

for some k = l +log ˆ θ − 1 + O (1) . Here, we used the fact that by (58), ν ( T l ∩ S k ( ˆf )) = ∅ , if k < 0 and that the expression we are bounding will be maximized if the set T l contains as many high-energy arcs as possible. (Note that due to the constraint ν ( T l ) = O (2 3 l ) and the bound (58), T l can then only contain all the arcs in sets S k ( ˆf ) for all k 0 up to k KM
 .) So, we can conclude that

To ﬁnish our overall bound, we just need to note that by our above derivation, as well as, the fact that T l = if l 0 (as κ t ∞ 12 ),

| κ te | r e ( ˆ f e ) 2 E r ( ˆf ) ≤ 4 C E  l =1 k ν ( T l ∩ S k ( ˆf )) 2 2 k + l  +4ˆ θ 2 ≤ 4 C E O (log ˆ θ − 2 ) O (ˆ θ 2 ) + ˆ θ 2 = C P ˆ θ 2 ln m,

as desired, once C P > 1 is chosen to be large enough.

Proof of Lemma 6.12

We start by bounding the increase of measure due to freezing. Let us ﬁx some progress step t and some auxiliary arc e that is in T l for some l ≤ log ˆ θ − 2 , where T l denotes T ¯ κ t l , as deﬁned in (23). (Note that only arcs in T l with l ≤ log ˆ θ − 2 can be frozen at step t .) By Lemma 6.3 and deﬁnition of T l , the increase of measure resulting from m 2 η | ¯ κ te | -stretching e is at most

However, by Lemma 6.10, we know that the vector ¯ κ t is C R -restricted. Therefore, the total contri- bution to measure increase of all the frozen arcs in T l is at most

Note that once we establish below that all auxiliary have always f te that is within a factor of C F of F A , the fact that F A is much smaller than F H will imply that all auxiliary arcs are always

light and thus never get stretch-boosted. So, the measure of auxiliary arc can increase only due to freezing and we have already bounded this increase above.

Now, to prove the ﬁrst part of the lemma, let us ﬁx some auxiliary arc e . Initially, f te is equal to F A . So, one just need to argue that the total multiplicative change of f te during the course of the ˆ θ -improvement phase execution is bounded by a constant.

To this end, note that the ﬂows on arcs change only during the progress steps. So, by Theorem 5.5, if we ﬁx some auxiliary arc e , its overall ﬂow changes by a factor of at most

Therefore, the total change of ﬂow of e during progress steps that have not resulted in freezing it, can bounded by

that is constant, as desired.

So, now we just need to focus on bounding the change of ﬂow on e resulting from the remaining progress steps, i.e., the ones in which it was frozen. To this end, recall that whenever | ¯ κ te | ≥ ˆ θ − 2 in some step t then freezing m 2 η | ¯ κ te | -stretches e . By Lemma 6.3, the resulting increase of measure of e is at least by a factor of

while the change of the ﬂow is by a factor of at most

Therefore, as the former factor is signiﬁcantly larger than the latter one, ¯ κ t ∞ ≤ 12 (by Theorem 5.5), and as from discussion above we know that once the measure of an arc becomes larger than R ˆ θ − 6 it will never be frozen again, the constant bound of the maximum multiplicative change of the ﬂow of an auxiliary arc follows. This concludes the proof of the lemma.

E.8 Proof of Lemma 6.13

By deﬁnition of ˆ µ ( f t , s t , ν t ) (cf. (10)), we have that

where S is the set of non-auxiliary arcs of ¯ G .

Now, observe that by deﬁnition of ˆ γ -centrality (cf. (11)) we have

λ ν t , 2 = a
 − ν , 2 ˆ µ ( f t , s t , ν t ) ≤ ˆ γ. So, by applying Cauchy-Schwarz inequality we get that e ∈ S ν te | λ e | ν t ( S ) ≤ e ∈ S ν te λ 2 e ν t ( S ) = λ 2 ν t , 2 ν t ( S ) ≤ ˆ γ 2 ν t ( S ) ≤ O ( iad
 m − 12 ) ,

≥ putting the above inequality and (59) together, the lemma follows.

Here, we discuss how one can adjust our algorithm developed in Sections 5–7 to nearly-linear electrical ﬂow computations that are only approximate – as in Theorem 2.3 – instead of

electrical ﬂow computations that are only approximate – as in Theorem 2.3 – instead of being exact. To this end, let us ﬁrst recall that we are using electrical ﬂow computations in two places of our algorithm. One is our improvement step described in Section 7. There, to make the descent step, we compute the electrical ﬂow ˆf t associated with our solution and then, to make the centering step, we compute the electrical ﬂow ˜f t . The other place where we use electrical ﬂow computations is to check the ˆ θ -smoothness condition (cf. Deﬁnition 6.1), that is to check which arcs are in the sets S l ( ˆf t ) , for l ≤ log ˆ θ − 3 . (Note that it is suﬃcient for us to know this classiﬁcation only approximately, say up to a constant factor.)

Observe that in all these three cases, we end up computing some electrical σ -ﬂows that are determined by some resistances r deﬁned as r e = s e f e (cf. (14)), for each arc e , and where ( f , s , ν ) is some γ -centered and ¯ σ -feasible solution with γ ≤ 12 and both | σ | 1 and | σ | 1 being O ( (=
 m ) . Further- more, we always have that 1 O ( m ) ≤ ˆ µ ( f , s , ν ) ≤ 1 , all variables s e are bounded by a constant (see Lemma 6.5), and the duality gap is O ( m ) . (All the deﬁnitions that are relevant here can be found in Section 5 and at the beginning of Section 6.)

This implies that, for any arc e , f e is always polynomially bounded in m . This is so since, given our polynomially-bounded demands, any ﬂow of value ω ( (m7)
 m ) would need to consist mostly of ﬂow-cycles, and such ﬂow-cycles would contribute to duality gap (as they cannot exist in optimal solution), which is always O ( m ) .

This, in turn, together with γ -centrality (see Fact 5.3) and Invariant 5.2, allows us to conclude that all the resistances

are within a polynomial in m factor of each other.

It is known (see, e.g., Theorem 2.3 in [CKM + 11]) that once all the resistances are within polyno- mial of each other, one can aﬀord very good (and fast) approximation to all the major characteristics of the electrical ﬂows (including good approximation to the ﬂow on each of the edges). In particular, one is able to easily perform (approximate) classiﬁcation of arcs into sets S l ( ˆf t ) , for l ≤ log ˆ θ − 3 . (Note that we want to classify here only arcs that contribute signiﬁcant portion of the total energy

most fundamental requirement there is that the ﬂows ˆf t and ˜f t that we compute are indeed elec- trical ﬂow, i.e., there are voltages that induce them via (5). After all, this is what ensures that our ﬁrst-order updates to the centrality are canceling out. The fact that these ﬂow might not have the exact demands we requested is of lesser importance. The only eﬀect of the latter will be that our improvement steps will end up perturbing the ˆ σ -feasibility of our maintained solution. However, given that we have polynomially bounded resistance ratio and logarithmic dependence on error, we can always make these perturbation very small and just ﬁx them at the end of each ˆ θ -improvement steps via the ﬁxing procedure that we already employ to ﬁx the eﬀects of the preconditioning – see Section 6.2.

In the light of the above, we can conclude that indeed, having approximate, instead of exact, electrical ﬂow computations is acceptable for our algorithm, at least as long the dependence of the running time on the error is only logarithmic (which is the case here).

Appendix to Section 7

To prove the second part of the theorem, note ﬁrst that indeed ν t +1 = ¯ ν t = ν t . Next, we can check that the cumulative changes of the vectors f t and s t are equal to

f t +1 e = (1 − δ t ) 1 + δ t ˆ f te (1 − δ t ) f te 1 − ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ˆ¯ µ te 1 + ˜ f te ¯ f e t\
 f te s t +1 e = 1 − δ t ˆ f te (1 − δ t ) f te 1 − ˜ f te ¯ f e s te , for each arc e in G . As a result, by (14), we have that for each arc e , (1 − δ t ) r t +1 e = (1 − δ t ) s t +1 e f t +1 e = 1 − δ t ˆ f te (1 − δ t ) f te 1 − ˜ f te ¯ f e s te 1 + δ t ˆ f te (1 − δ t ) f te 1 − ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ˆ¯ µ te 1 + ˜ f te ¯ f e f te .

for each arc e in G . As a result, by (14), we have that for each arc e ,

Recall that from the discussion above we already know that, for each arc e , | δ t ˆ f te (1 − δ t ) f te | = δ t ρ ( ˆf t , f t ) e (1 − δ t ) ≤ 2 √ ˆ γ ≤ 110 (cf. (41)), | ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ˆ¯ µ te | ≤ ˆ γ (1 − ˆ γ ) ≤ 140 (cf. Fact 5.3), and | ˜ f te ¯ f e | = ρ ( ˜ f t , ¯ f Fy
 ) e ≤ (cf. (50)). So, as r s te , we have that

Recall that from the discussion above we already know that, for each arc e , δ f te (1 − δ t ) f te

and by performing a simple Taylor expansion approximation we can obtain that

Clearly, this means, in particular, that κ te ∞ ≤ 2( 210 + 140 + 140 ) = 12 , as desired. So, we just need to show that ˆ κ t ν t , 2 116 too. To this end, observe that

ˆ κ t 2 ν t , 2 ≤ 2 e ν te oF
 (ˆ¯ µ te − ˆ µ ( ¯f t , ¯ s t , ¯ ν t )) 2 (ˆ¯ µ te ) 2 + ρ ( ˜f t , ¯f ) 2 e ≤ 2 ˆ¯ µ t − ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) 1 2 ¯ ν t , 2 (1 − ˆ γ ) 2 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) 2 + 1 ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) e ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ρ ( ˜f t , ¯f z)
 ) 2 e ≤ 2 9ˆ γ 2 + E ˜r t ( ˜f t ) ˆ µ ( ¯f t , ¯ s t , ¯ ν t ) ≤ 1 256 ,

as desired, where we used a combination of Fact 5.3, the fact that ( ¯f t , ¯ s t , ¯ ν t ) is 3ˆ γ -centered, as well as, equations (46) and (49). This concludes the proof of the theorem.