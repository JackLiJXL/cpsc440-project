Navigating Central Path with Electrical Flows: from Flows to
Matchings, and Back
(Preliminary draft)
Aleksander Mądry∗
EPFL
aleksander.madry@epﬂ.ch
Abstract
We present an �O(m
10
7 ) = �O(m1.43)-time1 algorithm for the maximum s-t ﬂow and the
minimum s-t cut problems in directed graphs with unit capacities. This is the ﬁrst improvement
over the sparse-graph case of the long-standing O(m min{√m, n2/3}) running time bound due to
Even and Tarjan [ET75] and Karzanov [Kar73]. By well-known reductions, this also establishes
an �O(m
10
7 )-time algorithm for the maximum-cardinality bipartite matching problem. That, in
turn, gives an improvement over the celebrated O(m√n) running time bound of Hopcroft and
Karp [HK73] and Karzanov [Kar73] whenever the input graph is suﬃciently sparse.
At a very high level, our results stem from acquiring a deeper understanding of interior-point
methods – a powerful tool in convex optimization – in the context of ﬂow problems, as well as,
utilizing certain interplay between maximum ﬂows and bipartite matchings.
The core of our approach comprises a primal-dual algorithm for (near-)perfect bipartite b-
matching problem.
This algorithm is inspired by path-following interior-point methods and
employs electrical ﬂow computations to gradually improve the quality of maintained solution
by advancing it toward (near-)optimality along so-called central path. To analyze this process,
we establish a formal connection that ties its convergence rate to the structure of corresponding
electrical ﬂows. Then, we exploit that connection to obtain a convergence guarantee for our
algorithm that improves upon the well-known barrier of Ω(√m) iterations corresponding to
the generic worst-case performance bounds for interior-point-method-based algorithms. This
improvement is based on reﬁning certain insights into behavior of electrical ﬂows that stem
from the work of Christiano et al. [CKM+11] and combining them with a new technique for
preconditioning primal-dual solutions.
The ﬁnal ingredient of our approach is a simple reduction of the maximum s-t ﬂow problem
to the bipartite b-matching problem. This reduction is then composed with the recent sub-
linear-time algorithm for ﬁnding perfect matchings in regular graphs of Goel et al. [GKK10], to
derive an eﬃcient procedure for rounding fractional s-t ﬂows and bipartite matchings.
∗Part of this work was done when the author was with Microsoft Research New England.
1We recall that �O(f) denotes O(f logc f), for some constant c.
arXiv:1307.2205v3  [cs.DS]  24 Oct 2013

1
Introduction
The maximum s-t ﬂow problem and its dual, the minimum s-t cut problem, are two of the most fun-
damental and extensively studied graph problems in combinatorial optimization [Sch03, AMO93].
They have a wide range of applications (see [AMOR95]), are often used as subroutines in other
algorithms (see, e.g., [AHK12, She09]), and a number of other important problems – e.g., bipartite
matching problem [CLRS09] – can be reduced to them. Furthermore, these two problems were often
a testbed for development of fundamental algorithmic tools and concepts. Most prominently, the
Max-Flow Min-Cut theorem [EFS56, FF56] constitutes the prototypical primal-dual relation.
Several decades of extensive work resulted in a number of developments on these problems (see
Goldberg and Rao [GR98] for an overview) and many of their generalizations and special cases.
Still, despite all this eﬀort, the basic problem of computing maximum s-t ﬂow and minimum s-t cut
in general graphs has resisted progress for a long time. In particular, the current best running time
bound of O(m min{m
1
2 , n
2
3 } log(n2/m) log U) (with U denoting the largest integer arc capacity)
was established over 15 years ago in a breakthrough paper by Goldberg and Rao [GR98] and this
bound, in turn, matches the O(m min{m
1
2 , n
2
3 }) bound for unit-capacity graphs that Even and
Tarjan [ET75] – and, independently, Karzanov [Kar73] – put forth over 35 years ago.
Recently, however, important progress was made in the context of undirected graphs. Christiano
et al. [CKM+11] developed an algorithm that allows one to compute a (1+ε)-approximation to the
undirected maximum s-t ﬂow (and the minimum s-t cut) problem in �O(mn
1
3 ε−11/3) time. Their
result relies on devising a new approach to the problem that combines electrical ﬂow computations
with multiplicative weights update method (see [AHK12]). Later, Lee et al. [LRS13] presented a
quite diﬀerent – but still electrical-ﬂow-based – algorithm that employs purely gradient-descent-
type view to obtain an �O(mn1/3ε−2/3)-time (1 + ε)-approximation for the case of unit capacities.
Finally, very recently, this line of work was culminated by Sherman [She13] and Kelner et al.
[KLOS13] who independently showed how to integrate non-Euclidean gradient-descent methods
with fast poly-logarithmic-approximation algorithms for cut problems of Mądry [Mąd10] to get an
O(m1+o(1)ε−2)-time (1 + ε)-approximation to the undirected maximum ﬂow problem.
Finally, we note that, in parallel to the above work that is focused on designing weakly-
polynomial algorithms for the maximum s-t ﬂow and minimum s-t cut problems, there is also
a considerable interest in obtaining running time bounds that are strongly-polynomial, i.e., that do
not depend on the values of arc capacities. The current best such bound is O(mn) and it follows
by combining the algorithms of King et al. [KRT94] and Orlin [Orl13].
Bipartite Matching Problem.
Another problem that we will be interested in is the (maximum-
cardinality) bipartite matching problem – a fundamental assignment problem with numerous appli-
cations (see, e.g., [AMO93, LP86]) and long history. Already in 1931, König [Kön31] and Egerváry
[Ege31] provided ﬁrst constructive characterization of maximum matchings in bipartite graphs. This
characterization can be turned into a polynomial-time algorithm. Then, in 1973, Hopcroft and Karp
[HK73] – and, independently, Karzanov [Kar73] – devised the celebrated O(m√n)-time algorithm.
Till date, this bound is the best one known in the regime of relatively sparse graphs. It can be
improved, however, when the input graph is dense, i.e., when m is close to n2. In this case, one can
combine the algebraic approach of Rabin and Vazirani [RV89] – that itself builds on the work of
Tutte [Tut47] and Lovász [Lov79] – with matrix-inversion techniques of Bunch and Hopcroft [BH74]
to get an algorithm that runs in O(nω) time (see [Muc05]), where ω ≤ 2.3727 is the exponent
1

of matrix multiplication [CW90, VW12]. Also, later on, Alt et al. [ABMP91], as well as, Feder
and Motwani [FM95] developed combinatorial algorithms that oﬀer a slight improvement – by a
factor of, roughly, logn
n2
m – over the O(m√n) bound of Hopcroft and Karp whenever the graph is
suﬃciently dense.
Finally, it is worth mentioning that there was also a lot of developments on the (maximum-
cardinality) matching problem in general, i.e., not necessarily bipartite, graphs. Starting with the
pioneering work of Edmonds [Edm65], these developments led to bounds that essentially match the
running time guarantees that were previously known only for bipartite case. More speciﬁcally, the
running time bound of O(m√n) for the general-graph case was obtained by Micali and Vazirani
[MV80, Vaz94] (see also [GT91] and [GK04]). While, building on the algebraic characterization of
the problem due to Rabin and Vazirani [RV89], Mucha and Sankowski [MS04] and then Harvey
[Har09] gave O(nω)-time algorithms for general graphs.
1.1
Our Contribution
In this paper, we develop a new algorithm for solving maximum s-t ﬂow and minimum s-t cut
problems in directed graphs. More precisely, we prove the following theorem.
Theorem 1.1. Let G = (V, E) be a directed graph with m arcs and unit capacities. For any two
vertices s and t, one can compute an integral maximum s-t ﬂow and minimum s-t cut of G in
�O(m
10
7 ) time.
This improves over the long-standing O(m min{√m, n2/3}) running time bound due to Even and
Tarjan [ET75] and, in particular, ﬁnally breaks the Ω(n
3
2 ) running time barrier for sparse directed
graphs.
Furthermore, by applying a well-known reduction (see [CLRS09]), our new algorithm gives the
ﬁrst improvement on the sparse-graph case of the seminal O(m√n)-time algorithms of Hopcroft-
Karp [HK73] and Karzanov [Kar73] for the maximum-cardinality bipartite matching problem.
Theorem 1.2. Let G = (V, E) be an undirected bipartite graph with m edges, one can solve the
maximum-cardinality bipartite matching problem in G in �O(m
10
7 ) time.
This, again, breaks the 40-years-old running time barrier of Ω(n
3
2 ) for this problem in sparse graphs.
Additionally, we design a simple reduction of the maximum s-t ﬂow problem to perfect bipartite
b-matching problem (see Theorem 3.1).
(This reduction can be seen as an adaptation of the
reduction of the maximum vertex-disjoint s-t-path problem to the bipartite matching problem due
to Hoﬀman [Hof60] – cf. Section 16.7c in [Sch03].2) As the reduction in the other direction is well-
known already, this establishes an algorithmic equivalence of these two problems. We also show (see
Theorem 3.3 and Corollary 3.4) how this reduction, together with the sub-linear-time algorithm for
perfect matching problem in regular bipartite graphs of Goel et al. [GKK10], leads to an eﬃcient,
nearly-linear time, rounding procedure for s-t ﬂows.3
Finally, our main technical contribution is a primal-dual algorithm for (near-)perfect bipartite
b-matching problem (see Theorem 3.2). This iterative algorithm draws on ideas underlying interior-
point methods and the electrical ﬂow framework of Christiano et al. [CKM+11]. It employs electrical
2We thank Lap Chi Lau [Lau13] for pointing out this similarity.
3Recently, it came to our attention that a very similar rounding result was independently obtained by Khanna et
al. [KKL13].
2

ﬂow computations to gradually improve the quality of maintained solution by advancing it toward
(near-)optimality along so-called central path.
We develop a way of analyzing this algorithm’s rate of convergence by relating it to the structure
of the corresponding electrical ﬂows (see Theorem 5.5). This understanding enables us to devise a
way of perturbing (see Section 6.1) and preconditioning (see Section 6.2) our intermediate solutions
to ensure a convergence in only �O(m
3
7 ) iterations and thus improve over the well-known barrier of
Ω(m
1
2 ) iterations that all the previous interior-point-methods-based algorithms suﬀer from. (To the
best of our knowledge, this is the ﬁrst time that this barrier was broken for a natural optimization
problem.)
We also note that most of this understanding of convergence behavior of interior-point methods
can be carried over to general LP setting. Therefore, we are hopeful that our techniques can be
extended and will eventually lead to breaking the Ω(m
1
2 ) iterations barrier for general interior-point
methods.
1.2
Our Approach
The core of our approach comprises two components. One of them is combinatorial in nature and
exploits an intimate connection between the maximum s-t ﬂow problem and bipartite matching
problem. The other one is more linear-algebraic and relies on interplay of interior-point methods
and electrical ﬂows.
Maximum ﬂows and bipartite matchings.
The combinatorial component shows that not
only one can reduce bipartite matching problem to the maximum s-t ﬂow problem, but also that a
reduction in the other direction exists. Namely, one can reduce, in a simple and purely combinatorial
way, the maximum s-t ﬂow problem to a certain variant of bipartite matching problem (see Theorem
3.1). Once this reduction is established, it allows us to shift our attention to the matching problem.
Also, as a byproduct, this reduction – together with the algorithm of Goel et al. [GKK10] –
yields a fast procedure for rounding fractional maximum ﬂows (see Corollary 3.4). This enables us
to focus on obtaining solutions that are only nearly-optimal, instead of being optimal.
Bipartite Matchings and Electrical Flows.
The other component is based on using the
interior-point method framework in conjunction with nearly-linear time electrical ﬂow computa-
tions, to develop a faster algorithm for the bipartite matching problem.
The point of start here is a realization that the recent approaches to approximating undirected
maximum ﬂow [CKM+11, LRS13, She13, KLOS13], despite achieving impressive progress, have
fundamental limitations that make them unlikely to yield improvements for the exact undirected or
(approximate) directed setting.4 Very roughly speaking, these limitations stem from the fact that,
at their core, all these algorithms employ some version of gradient-descent method that relies on
purely primal arguments, while almost completely neglecting the dual aspect of the problem. It
is well-understood, however, that getting a running time guarantee that depends logarithmically,
instead of polynomially, on ε−1 – and such dependence is a prerequisite to making progress in
directed setting – one needs to also embrace the dual side of the problem and take full advantage
of it.
4Note that it is known – see, e.g., [Mąd11] – that computing exact maximum s-t ﬂow in undirected graphs is
algorithmically equivalent to computing the exact or approximate maximum s-t ﬂow in directed graph.
3

Interior-point methods and fast algorithms.
The above realization motivates us to consider
a more sophisticated approach, one that is inherently primal-dual and achieves logarithmic depen-
dence on ε−1: interior-point methods. These methods constitute a powerful optimization paradigm
that is a cornerstone of convex optimization (see, e.g., [BV04, Wri97, Ye97]) and already led to
development of polynomial-time exact algorithms for a variety of problems. Unfortunately, despite
all its advantages and successes in tackling hard optimization tasks, this paradigm has certain short-
comings in the context of designing fast algorithms. The main reason for that is the fact that each
iteration of interior-point method requires solving of a linear system, a task for which the current
fastest general-purpose algorithm runs in O(nω) = O(n2.3727) time [AHU74, CW90, VW12]. So,
this bound becomes a bottleneck if one was aiming for, say, even sub-quadratic-time algorithm.
Fortunately, it turns out that there is a way to circumvent this issue. Namely, even though
the above bound is the best one known in general, one can get a better running time when dealing
with some speciﬁc problem. This is achieved by exploiting the special structure of the corresponding
linear systems. A prominent (and most important from our point of view) example here is the family
of ﬂow problems. Daitch and Spielman [DS08] showed that in the context of ﬂow problems one can
use the power of fast (approximate) Laplacian system solvers [ST04, KMP10, KMP11, KOSZ13] to
solve the corresponding linear systems in nearly-linear time. This enabled [DS08] to develop a host
of �O(m
3
2 )-time algorithms for a number of important generalizations of the maximum ﬂow problem
for which there was no such algorithms before.
Unfortunately, this bound of �O(m
3
2 ) time turns out to also be a barrier if one wants to obtain
even faster algorithms. The new diﬃculty here is that the best worst-case bound on the number
of iterations needed for an interior-point method to converge to near-optimal solution is Ω(m1/2).
Although it is widely believed that this bound is far from optimal, it seems that our theoretical
understanding of interior-point method convergence is still insuﬃcient to make any progress on this
front. In fact, improving this state of aﬀairs is a major and long-standing challenge in mathematical
programing.
Beyond the Ω(m
1
2 ) barrier.
Our approach to circumventing this Ω(m
1
2 ) barrier and obtaining
the desired �O(m
10
7 )-time algorithm for the bipartite b-matching problem consists of two stages.
First one – presented in Section 5 – corresponds to setting up a primal-dual framework for
solving the near-perfect b-matching problem. This framework is directly inspired by the principles
underlying path-following interior-point methods and, in some sense, is equivalent to them. In it,
we start with some initial sub-optimal solution (that is encoded as a minimum-cost ﬂow problem
instance) and gradually improve its quality up to near-optimality. These gradual improvements are
guided by certain electrical ﬂow computations – the ﬂows are used to update the primal solution
and the corresponding voltages update the dual one – and our solution ends up following a special
trajectory in the feasible space: so-called central path.
We analyze the performance of this optimization process by establishing a formal connection
that ties the size of each improvement step to a certain characteristic of the corresponding electrical
ﬂow. Very roughly speaking, this size (and thus the resulting rate of convergence) is directly related
to how much the electrical ﬂow we compute resembles the current primal solution (which is also a
ﬂow). Once this connection is established, a simple energy-based argument immediately recovers
the generic O(m
1
2 ) iterations bound known for interior-point methods. So, as each electrical ﬂow
computation can be performed in �O(m) time, this gives an overall �O(m
3

the generic O(m
1
2 ) iterations bound known for interior-point methods. So, as each electrical ﬂow
computation can be performed in �O(m) time, this gives an overall �O(m
3
2 )-time algorithm.
Finally, to improve upon the above O(m
1
2 ) iterations bound and deliver the desired O(m
10
7 )-
4

time procedure, in Section 6, we devise two techniques: perturbation of arcs – that can be seen as
a reﬁnement of the edge removal technique of Christiano et al. [CKM+11]; and solution precon-
ditioning – a way of adding auxiliary arcs to the solution to improve its conductance properties.
We show that by a careful composition of these techniques, one is able to ensure that the guiding
electrical ﬂows align better with the primal solution – thus allowing taking larger progress steps and
guaranteeing faster convergence – while keeping the unwanted impact of these modiﬁcations on the
quality of ﬁnal solution minimal. The analysis of this process constitutes the technical core of our
result and is based on understanding of the interplay between the interior-point method and both
the primal and dual structure of electrical ﬂows.
We believe that this approach of understanding interior-point methods through the lens of
electrical ﬂows is a promising direction and our result is just a ﬁrst step towards realizing its full
potential.
1.3
Organization
We begin the technical part of the paper in Section 2 where we present some preliminaries on
maximum ﬂow problem, electrical ﬂows, and bipartite (b-)matching problem, as well as, introduce
some theorems we will need in the sequel. In Section 3, we provide a general outline of our results
and the structure of our proof.
In Section 4, we describe the reduction of maximum s-t ﬂow problem to the bipartite b-matching
problem. Next, in Sections 5 and 6, we explain how our path-following algorithms and electrical
ﬂows can be used to get an improved algorithm for the bipartite b-matching problem, with Section 7
presenting the analysis of our path-following primitive. Finally, we conclude in Section 8 by showing
how to round fractional b-matchings to integral ones.
2
Preliminaries
In this section, we introduce some basic notation and deﬁnitions we will need later.
2.1
σ-Flows and the Maximum s-t Flow Problem
Throughout this paper, we denote by G = (V, E, u) a directed graph with vertex set V , arc set E
(we allow parallel arcs), and (non-negative) integer capacities ue, for each arc e ∈ E. We usually
deﬁne m = |E| to be the number of arcs of the graph in question and n = |V | to be the number of
its vertices. Each arc e of G is an ordered pair (u, v), where u is its tail and v is its head.
The basic notion of this paper is the notion of a σ-ﬂow in G, where σ ∈ Rn, with �
v σv = 0, is
the demand vector. By a σ-ﬂow in G we understand any vector f ∈ Rm that assigns values to arcs
G and satisﬁes the ﬂow conservation constraints:
�
e∈E+(v)
fe −
�
e∈E−(v)
fe = σv,
for each vertex v ∈ V .
(1)
Here, E+(v) (resp.
E−(v)) is the set of arcs of G that are leaving (resp.
entering) vertex v.
Intuitively, these constraints enforce that the net balance of the total in-ﬂow into vertex v and the
total out-ﬂow out of that vertex is equal to σv, for every v ∈ V .
5

Furthermore, we say that a σ-ﬂow f is feasible in G iﬀ f obeys the non-negativity and capacity
constraints:
0 ≤ fe ≤ ue,
for each arc e ∈ E.
(2)
One type of σ-ﬂows that will be of special interest to us are s-t ﬂows, where s (the source) and t
(the sink) are two distinguish vertices of G. Formally, a σ-ﬂow f is an s-t ﬂow iﬀ its demand vector
σ is equal to F · χs,t for some F ≥ 0 – we call F the value of f – and the demand vector χs,t that
has −1 (resp. 1) at the coordinate corresponding to s (resp. t) and zeros everywhere else.
Now, the maximum s-t ﬂow problem corresponds to a task of ﬁnding for a given graph G =
(V, E, u), a source s, and a sink t, a feasible s-t ﬂow f ∗ in G of maximum value F. We call such a
ﬂow f ∗ that maximizes F the maximum s-t ﬂow of G and denote its value by F ∗.
Sometimes, we will be also interested in (uncapacitated) minimum-cost σ-ﬂow problem (with
non-negative costs). In this problem, we have a directed graph G with inﬁnite capacities on arcs
(i.e., ue = +∞, for all e) and certain (non-negative) length (or cost) le assigned to each arc e. Our
goal is to ﬁnd a feasible σ-ﬂow f in G whose cost l(f ) := �
e lefe is minimal. (Note that as we have
inﬁnite capacities here, the feasibility constraint (2) just requires that fe ≥ 0 for all arcs e.)
Finally, one more problem that will be relevant in this context is the minimum s-t cut problem.
In this problem, we are given a directed graph G = (V, E, u) with integer capacities, as well as,
a source s and sink t, and our task is to ﬁnd an s-t cut C ⊆ V in G minimizes the capacity
u(C) := �
E−(C) ue among all s-t cuts. Here, a cut C ⊆ V is an s-t cut iﬀ s ∈ C and t /∈ C, and
E−(C) is the set of all arcs (u, v) with u ∈ C and v /∈ C. It is well-known [EFS56, FF56] that
the minimum s-t cut problem is the dual of the maximum s-t problem and, in particular, that the
capacity of the minimum s-t cut is equal to the value of the maximum s-t ﬂow, as well as, that
given a maximum s-t ﬂow one can easily obtain the corresponding minimum s-t cut.
2.2
Undirected Graphs
Although the focus of our results is on directed graphs, it will be crucial for us to consider undirected
graphs too. To this end, we view an undirected graph G = (V, E, u) as a directed one in which the
ordered pair (u, v) ∈ E does not denote an arc anymore, but an (undirected) edge (u, v) and the
order just speciﬁes an orientation of that edge from u to v. (Even though we use the same notation
for these two diﬀerent types of graphs, we will always make sure that it is clear from the context
whether we deal with directed graph that has arcs, or with undirected graph that has edges.) From
this perspective, the deﬁnitions of σ-ﬂow f that we introduced above for directed graphs transfer
over to undirected setting almost immediately. The only (but very crucial) diﬀerence is that in
undirected graphs a feasible ﬂow can have some of fes being negative - this corresponds to the ﬂow
ﬂowing in the direction that is opposite to the edge orientation. As a result, the feasibility condition
(2) becomes
|fe| ≤ ue,
for each arc e ∈ E.
(3)
Also, the set E+(v) (resp. E−(v)) denotes now the set of incident edges that are oriented towards
(resp. away) from v, and E(v) := E+(v)∪E−(v) is just the set of all edges incident to v, regardless
of their orientation.
Finally, given a directed graph G = (V, E, u), by its projection ¯G we understand an undirected
graph that arises from treating each arc of G as an edge with the corresponding orientation. Note
that if G had two arcs (u, v) and (v, u) then ¯G will have two parallel edges (u, v) and (v, u) that
have opposite orientation and, possibly, diﬀerent capacities.
6

2.3
Electrical Flows and Potentials
A notion that will play a fundamental role in this paper is the notion of electrical ﬂows. Here, we
just brieﬂy review some of the key properties that we will need later. For an in-depth treatment we
refer the reader to [Bol98].
Consider an undirected graph G and some vector of resistances r ∈ Rm that assigns to each
edge e its resistance re > 0. For a given σ-ﬂow f in G, let us deﬁne its energy (with respect to r)
Er(f ) to be
Er(f ) :=
�
e
ref2
e = f T Rf ,
(4)
where R is an m × m diagonal matrix with Re,e = re, for each edge e.
For a given undirected graph G, a demand vector σ, and a vector of resistances r, we deﬁne
an electrical σ-ﬂow in G (that is determined by resistances r) to be the σ-ﬂow that minimizes
the energy Er(f ) among all σ-ﬂows in G. As energy is a strictly convex function, one can easily
see that such a ﬂow is unique. Also, we emphasize that we do not require here that this ﬂow is
feasible with respect to capacities of G (cf. (3)). Furthermore, whenever we consider electrical ﬂows
in the context of a directed graph G, we will mean an electrical ﬂow – as deﬁned above – in the
(undirected) projection ¯G of G.
One of very useful properties of electrical ﬂows is that it can be characterized in terms of vertex
potentials inducing it. Namely, one can show that a σ-ﬂow f in G is an electrical σ-ﬂow determined
by resistances r iﬀ there exist vertex potentials φv (that we collect into a vector φ ∈ Rn) such that,
for any edge e = (u, v) in G that is oriented from u to v,
fe = φv − φu
re
.
(5)
In other words, a σ-ﬂow f is an electrical σ-ﬂow iﬀ it is induced via (5) by some vertex potential
φ. (Note that orientation of edges matters in this deﬁnition.)
Using vertex potentials, we are able to express the energy Er(f ) (see (4)) of an electrical σ-ﬂow
f in terms of the potentials φ inducing it as
Er(f ) =
�
e=(u,v)
(φv − φu)2
re
.
(6)
One of the consequences of this characterization of electrical ﬂows via vertex potentials is that
one can view the energy of an electrical σ-ﬂow as being a result of optimization not over all the
σ-ﬂows but rather over certain set of vertex potentials. Namely, we have the following lemma that,
for completeness, we prove in the Appendix A.
Lemma 2.1. For any graph G = (V, E), any vector of resistances r, and any demand vector σ,
1
Er(f ∗) =
min
φ|σT φ=1
�
e=(u,v)∈E
(φv − φu)2
re
,
where f ∗ is the electrical σ-ﬂow determined by r in G. Furthermore, if φ∗ are the vertex potentials
corresponding to f ∗ then the minimum is attained by taking φ to be equal to ˜φ := φ∗/Er(f ∗).
7

Note that the above lemma provides a convenient way of lowerbounding the energy of an elec-
trical σ-ﬂow. One just needs to expose any vertex potentials φ such that σT φ = 1 and this will
immediately constitute an energy lowerbound. Also, another basic but useful property of electrical
σ-ﬂows is captured by the following fact.
Fact 2.2 (Rayleigh Monotonicity). For any graph G = (V, E), demand vector σ and any two vectors
of resistances r and r ′ such that re ≥ r′
e, for all e ∈ E, we have that if f (resp. f ′) is the electrical
σ-ﬂow determined by r (resp. r ′) then
Er(f ) ≥ Er′(f ′).
2.4
Laplacian Solvers
A very important algorithmic property of electrical ﬂows is that one can compute very good ap-
proximations of them in nearly-linear time. Below, we brieﬂy describe the tools enabling that.
To this end, let us recall that electrical σ-ﬂow is the (unique) σ-ﬂow induced by vertex potentials
via (5). So, ﬁnding such a ﬂow boils down to computing the corresponding vertex potentials φ. It
turns out that computing these potentials can be cast as a task of solving certain type of linear
system called Laplacian systems. To see that, let us deﬁne the edge-vertex incidence matrix B being
an n × m matrix with rows indexed by vertices and columns indexed by edges such that
Bv,e =





1
if e ∈ E+(v),
−1
if e ∈ E−(v),
0
otherwise.
Now, we can compactly express the ﬂow conservation constraints (1) of a σ-ﬂow f (that we view
as a vector in Rm) as
Bf = σ.
On the other hand, if φ are some vertex potentials, the corresponding ﬂow f induced by φ via
(5) (with respect to resistances r) can be written as
f = R−1BT φ,
where again R is a diagonal m × m matrix with Re,e := re, for each edge e.
Putting the two above equations together, we get that the vertex potentials φ that induce the
electrical σ-ﬂow determined by resistances r are given by a solution to the following linear system
BR−1BT φ = Lφ = σ,
(7)
where L := BR−1BT is the (weighted) Laplacian L of G (with respect to the resistances r). One
can easily check that L is an n × n matrix indexed by vertices of G with entries given by
Lu,v =





�
e∈E(v) 1/re
if u = v,
−1/re
if e = (u, v) ∈ E, and
0
otherwise.
(8)
One can see that the Laplacian L is not invertible, but – as long as, the underlying graph is
connected – it’s null-space is one-dimensional and spanned by all-ones vector. As we require our
8

demand vectors σ to have its entries sum up to zero (otherwise, no σ-ﬂow can exist), this means
that they are always orthogonal to that null-space. Therefore, the linear system (7) has always a
solution φ and one of these solutions5 is given by
φ = L†σ,
where L† is the Moore-Penrose pseudo-inverse of L.
Now, from the algorithmic point of view, the crucial property of the Laplacian L is that it is
symmetric and diagonally dominant, i.e., for any v ∈ V , �
u̸=v |Lu,v| ≤ Lv,v. This enables us to
use fast approximate solvers for symmetric and diagonally dominant linear systems to compute an
approximate electrical σ-ﬂow. Namely, building on the work of Spielman and Teng [ST03, ST04],
Koutis et al. [KMP10, KMP11] designed an SDD linear system solver that implies the following
theorem. (See also recent work of Kelner et al. [KOSZ13] that presents an even simpler nearly-
linear-time Laplacian solver.)
Theorem 2.3. For any ε > 0, any graph G with n vertices and m edges, any demand vector σ,
and any resistances r, one can compute in �O(m log m log ε−1) time vertex potentials ˜φ such that
∥ ˜φ−φ∗∥L ≤ ε∥φ∗∥L, where L is the Laplacian of G, φ∗ are potentials inducing the electrical σ-ﬂow
determined by resistances r, and ∥φ∥L :=
�
φT Lφ.
To understand the type of approximation oﬀered by the above theorem, observe that ∥φ∥2
L =
φT Lφ is just the energy of the ﬂow induced by vertex potentials φ. Therefore, ∥ ˜φ − φ∗∥L is the
energy of the electrical ﬂow ¯f that “corrects” the vertex demands of the electrical ˜σ-ﬂow induced
by potentials ˜φ, to the ones that are dictated by σ. So, in other words, the above theorem tells
us that we can quickly ﬁnd an electrical ˜σ-ﬂow ˜f in G such that ˜σ is a slightly perturbed version
of σ and ˜f can be corrected to the electrical σ-ﬂow f ∗ that we are seeking, by adding to it some
electrical ﬂow ¯f whose energy is at most ε fraction of the energy of the ﬂow f ∗. (Note that electrical
ﬂows are linear, so we indeed have that f ∗ = ˜f + ¯f .) As we will see, this kind of approximation is
completely suﬃcient for our purposes.
2.5
Bipartite b-Matchings
A fundamental graph problem that constitutes both an application of our results, as well as, one of
the tools we use to establish them, is the (maximum-cardinality) bipartite b-matching problem. In
this problem, we are given an undirected bipartite graph G = (V, E) with V = P ∪ Q – where P
and Q are the two sets of bipartition – as well as, a demand vector b that assigns to every vertex v
an integral and positive demand bv. Our goal is to ﬁnd a maximum cardinality multiset M of the
edges of G that forms a b-matching. That is, we want to ﬁnd a multi-set M of edges of G that is
of maximum cardinality subject to a constraint that, for each vertex v ∈ V , the number of edges of
M that are incident to v is at most bv. (When bv = 1 for every vertex v, we will simply call such
M a matching.)
We say that a b-matching M is perfect iﬀ every vertex in V has exactly bv edges incident to
it in M. Note that a perfect b-matching - if it exists in G - has to necessarily be of maximum
cardinality. Also, if a graph has a perfect b-matching then it must be that �
v∈P bv = �
v∈Q bv.
5Note that the linear system (7) will have many solutions, but each two of them are equivalent up to a translation.
So, as the formula (5) is translation-invariant, each of these solutions will yield the same unique electrical σ-ﬂow.
9

Now, by the perfect bipartite b-matching problem we mean a task in which we need to either ﬁnd
the perfect b-matching in G or conclude that it does not exist.
Finally, by a fractional solution to a b-matching problem, we understand an |E|-dimensional
vector x that allocates non-negative value of xe to each edge e and is such that for every vertex v
of G, the sum �
e∈E(v) xe of (fractional) incident edges in x is at most bv. Also, we deﬁne the size
of a fractional b-matching x to be |x|1.
An interesting class of graphs that is guaranteed to always have a perfect matching are bipartite
graphs that are d-regular, i.e., that have the degree of each vertex equal to d. A remarkable algorithm
of Goel et al. [GKK10] shows that one can ﬁnd a perfect matching in such graphs in time that is
proportional only to number of its vertices and not edges. (Note that a d-regular bipartite graph has
exactly dn
2 edges and thus this number can be much higher than n when d is large.) In particular,
they prove the following theorem that we will use later.
Theorem 2.4 (see Theorem 4 in [GKK10]). Given an n × n doubly-stochastic matrix M with m
non-zero entries, one can ﬁnd a perfect matching in the support of M in O(n log2 n) expected time
with O(m) preprocessing time.
3
From Flows to Matchings, and Back
As we already mentioned, our results stem from exploiting the interplay between the maximum s-t
ﬂow and bipartite b-matching problem, as well as, from understanding the performance of interior-
point methods – when applied to these two problems – via the structure of corresponding electrical
ﬂows. To highlight these elements, we decompose the proof of our main theorem (Theorem 1.1)
into three natural parts.
Reducing Maximum Flow to b-Matching
First, we focus on analyzing the relationship between the maximum s-t ﬂow and the (maximum-
cardinality) bipartite b-matching problem. It is well-known that the latter can be reduced to the
former in a simple way. As it turns out, however, one can also go the other way – there is a simple,
combinatorial reduction from the maximum ﬂow problem to the task of ﬁnding a perfect bipartite
b-matching.6
Before making this precise, let us introduce one deﬁnition. Consider a b-matching problem
instance corresponding to a bipartite graph G = (V, E) with P and Q (V = P ∪ Q) being two sides
of the bipartition. For any edge e = (p, q) ∈ E, let us deﬁne the thickness d(e) of that edge to be
d(e) := min{bp, bq}. (So, d(e) is an upper bound on the value of xe in any feasible b-matching x.)
We say that a b-matching instance is balanced iﬀ
�
e∈E
d(e) ≤ 4|b|1.
(9)
Now, in Section 4, we establish the following result.
6One can view this as one possible explanation of why the techniques used in the context of bipartite matchings
and maximum ﬂows are so similar.
10

Theorem 3.1. If one can solve a balanced instance of a perfect bipartite b-matching problem in
a (bipartite) graph with ¯n vertices and ¯m edges in T(¯n, ¯m, |b|1) time, then one can solve the max-
imum s-t ﬂow problem in a graph G = (V, E, u) with m arcs and capacity vector u in �O((m +
T(Θ(m), 4m, 4|u|1)) log |u|1) time.
This connection between maximum ﬂows and bipartite matchings is useful in two ways. Firstly,
it enables us to reduce the main problem we want to solve – the maximum s-t ﬂow problem with
unit capacities – to a seemingly simpler one: the perfect bipartite b-matching problem. Secondly,
the fact that this reduction works also for fractional instances provides us with an ability to lift
our b-matching rounding procedure that we develop later (see Theorem 3.3) to the maximum ﬂow
setting (see Corollary 3.4).
The Algorithm for Near-Perfect b-Matching Problem
Once the above reduction is established, we can proceed to designing an improved algorithm for the
perfect bipartite b-matching problem. This algorithm consists of two parts.
The ﬁrst one – constituting the technical core of our paper – is related to the (fractional)
near-perfect bipartite b-matching problem, a certain relaxation of the perfect bipartite b-matching
problem. To describe this task formally, let us call a b-matching x near-perfect if its size |x|1 is at
least |b|1
2 − �O(m
3
7 ), i.e., it is within �O(m
3
7 ) additive factor of the size of a perfect b-matching. Now,
given a bipartite graph G = (P ∪ Q, E) and demand vector b, the near-perfect b-matching problem
is a task of either ﬁnding a near-perfect b-matching in G or concluding that no perfect b-matching
exists in that graph.
Our goal is to design an algorithm that solves this near-perfect b-matching problem in �O(m
10
7 )
time. To this end, in Sections 5 and 6 we prove the following theorem.
Theorem 3.2. Let G = (V, E) with V = P ∪ Q be an undirected bipartite graph with n vertices
and m edges and let b be a demand vector that corresponds to a balanced b-matching instance
with |b|1 = O(m). In �O(m
10
7 ) time, one can either ﬁnd a fractional near-perfect b-matching x or
conclude that no perfect b-matching exists in G.
(Observe that whenever we have an instance of maximum s-t ﬂow problem that has ¯m arcs and
unit capacities, |u|1 is exactly ¯m. So, if we apply the reduction from Theorem 3.1 to that instance
then the resulting b-matching problem instance will be balanced, have m ≤ 4 ¯m edges, as well as,
|b|1 ≤ 4|u|1 = 4 ¯m ≤ 2m. Therefore, we will be able to apply the above Theorem 3.2 to it.)
At a very high level, our algorithm for the near-perfect b-matching problem is inspired by the
way the existing interior-point method path-following algorithms (see, e.g., [Ye97, Wri97, BV04])
can be used to solve it. Basically, our algorithm is an iterative method that starts with some initial,
far-from-optimal solution and then gradually improves this maintained solution to near-optimality
(pushing it along so-called central path) using appropriate electrical ﬂows as a guidance. We then
show how to tie the convergence rate of this process to the structure of the guiding electrical ﬂows.
At that point, one can use a simple energy-bounding argument to establish a generic convergence
bound that yields an (unsatisfactory) �O(m
3
2 )-time algorithm.
To improve upon this bound and deliver the desired �O(m
10
7 )-time algorithm, we show how one
can appropriately “shape” these guiding electrical ﬂows to make their guidance more eﬀective and
thus guarantee faster convergence. Very roughly speaking, it turns out there is a way of changing
11

the maintained solution to make it essentially the same from the point of view of our b-matching
instance, while dramatically improving the quality of corresponding electrical ﬂows that guide it.
Our way of executing this idea is based on a careful composition of two techniques. One of
them corresponds to perturbing, in a certain way, the arcs that are most signiﬁcantly distorting the
structure of electrical ﬂow – this technique can be viewed as a reﬁnement of edge removal technique
of Christiano et al. [CKM+11]. The other technique corresponds to preconditioning the whole
solution by adding additional, auxiliary, arcs to it. These arcs are chosen so to signiﬁcantly improve
the conductance properties of the solution (when viewed as a graph with resistances) while not
leading to too signiﬁcant deformation of the ﬁnal obtained solution.
Rounding Near-Perfect b-Matchings
Finally, our ﬁnal step on our way towards solving the perfect b-matching problem (and thus the
maximum s-t ﬂow problem) is related to turning the approximate and fractional answer returned
by the algorithm from Theorem 3.2 into an exact and integral one. To this end, note that if that
algorithm returned a near-perfect b-matching that was integral, there would be a standard way to
either turn it into a perfect b-matching or conclude that no such perfect b-matching exists. Namely,
one could just use repeated augmenting path computations. It is well-known that given an integral
b-matching, one can perform, in O(m) time, an augmenting path computation that either results in
increasing the size of our b-matching by one, or concludes that no further augmentation is possible
(and thus no perfect b-matching exists). So, as our initial near-perfect b-matching has size at least
|b|1
2 − �O(m
3
7 ), after at most �O(m
3
7 ) iterations, i.e., in time �O(m
10
7 ), we would get the desired answer.
Unfortunately, the above approach can fail completely once our near-perfect b-matching is frac-
tional. This is so, as in this case we do not have any meaningful lowerbound on the progress on the
size of the b-matching brought by the augmenting path computation.
Therefore, to deal with this issue, we develop the last ingredient of our algorithm: a nearly-
linear time procedure that allows one to round fractional b-matchings. More precisely, in Section 8,
building on the work of Goel et al. [GKK10] (see Theorem 2.4), we establish the following theorem.
Theorem 3.3. Let G = (V, E) be an undirected bipartite graph with m edges and let b be a demand
vector, if x is a fractional b-matching in G of size k = |x|1 then one can ﬁnd in �O(m) time an
integral b-matching in G of size ⌊k⌋.
Clearly, if we apply the above rounding method to the fractional near-perfect matching x com-
puted by the algorithm from Theorem 3.2, it will give us an integral b-matching x ∗ whose size is
still at least |b|1
2 − �O(m
3
7 ). So, the augmenting path-based approach we outlined above will let us
obtain the desired integral and exact answer to the perfect b-matching problem within the desired
time bound.
In the light of all the above, we see that combining all the above pieces indeed yields an �O(m
10
7 )-
time algorithm for the perfect bipartite b-matching problem in graphs with |b|1 = O(m). Now,
using the reduction from Theorem 3.1, this gives us the analogous algorithm for the maximum s-t
ﬂow problem in unit-capacity graphs and that, in turn, results in an algorithm for the bipartite
matching problem. So, both Theorem 1.1 and Theorem 1.2 hold.
12

Rounding s-t Flows
Finally, we mention the other byproduct of our techniques – the fast rounding procedure for ﬂows.
Namely, using the reduction described in Theorem 3.1 and the rounding from Theorem 3.3 we can
obtain a fast rounding procedure not only for fractional b-matchings but also for fractional s-t ﬂows.
Speciﬁcally, the proof of the following corollary appears in Appendix B.
Corollary 3.4. Let G = (V, E, u) be a directed graph with capacities and let f be some feasible
fractional s-t ﬂow in G of value F. In �O(m) time, we can obtain out of f an integral s-t ﬂow f ∗ of
value ⌊F⌋ that is feasible in G.
Again, we note that a very similar rounding result was independently obtained by Khanna et al.
[KKL13].
4
From Maximum Flows to Perfect Matchings
In this section, we show how to reduce the maximum s-t ﬂow problem in a directed capacitated
graph G = (V, E, u) to solving O(log |u|1) balanced instances of the perfect bipartite b-matching
problem, i.e., we prove Theorem 3.1. We note that our reduction can be seen as an adaptation of
the reduction of the maximum vertex-disjoint s-t path problem to the bipartite matching problem
due to Hoﬀman [Hof60] – cf. Section 16.7c in [Sch03].
To this end, let G = (V, E, u) with n = |V | vertices and m = |E| arcs, as well as, the source s
and sink t be our input instance of the maximum s-t ﬂow problem. Without loss of generality, we
can assume that there is no arcs entering s and no arcs leaving t, as these arcs do not aﬀect the
maximum s-t ﬂow. Also, let F ∗ be the value of the maximum s-t ﬂow in G.
4.1
The Reduction
We show that for any integral value of F, we can setup, in �O(m) time, a balanced bipartite b-
matching problem instance, for some demands b and bipartite graph ¯G = (P ∪ Q, ¯E), such that:
(1) there will be a perfect b-matching in ¯G if there is a feasible s-t ﬂow of value F in G; and (2)
given a perfect b-matching in ¯G one can recover in �O(m) time an s-t ﬂow of value F that is feasible
in G. Observe that once such a reduction is designed, Theorem 3.1 will follow by noticing that
1 ≤ F ∗ ≤ |u|1 and applying a simple binary search strategy to ﬁnd the value of F ∗ and extract the
corresponding maximum s-t-ﬂow.
Given the input graph G = (V, E, u), source s, sink t and the value of F, the construction of
our desired balanced bipartite b-matching instance ¯G = (P ∪ Q, ¯E) is as follows. First, for each arc
e ∈ E, we create two vertices pe ∈ P and qe ∈ Q and an edge (pe, qe) between them, as well as, we
set the demand bpe and bqe of these vertices to ue. Next, for every vertex v of G other than s and
t, we add a vertex pv to P and a vertex qv to Q. Also, we create an edge (pv, qv), as well as, an
edge (pv, qe) (resp. (qv, pe)) for every arc e that is incoming to (resp. outgoing of) v in G. We set
the demands bpv (resp. bqv) to be equal to �
e∈E+(v) ue (resp. �
e∈E−(v) ue). Finally, we create a
vertex qs ∈ Q (resp. pt ∈ P) and add an edge (qs, pe) (resp. (qe, pt) for each arc e that is leaving
s (resp. incoming to t) in G. We put the demand bqs (resp. bpt) to be (�
e∈E−(s) ue) − F (resp.
(�
e∈E+(t) ue) − F). (Note that we can assume here that both these quantities are non-negative as
both �
e∈E−(s) ue and �
e∈E+(t) ue are obvious upperbounds on the value of F ∗.)
13

s
t
e2
e3
e4
e5
e1
1
3
2
2
3
a)
b)
qe3
pt
qe4
pe3
pe4
pe5
qe5
qv2
pv2
qe2
v2
v1
pe2
qs
pe1
qe1
qv1
pv1
2
2
1
1
3
3
2
2
3
3
3
3
4
3
2
3
Figure 1: a) An example directed s-t ﬂow instance G. Numbers next to arcs denote their capacities.
b) The b-matching instance corresponding to the example from a) in case of F = 2. Here, numbers
next to vertices denote their demands.
An example s-t ﬂow instance and the corresponding instance of the bipartite b-matching can be
found in Figure 1.
To see that this instance is balanced, note that every edge h of ¯G that is incident to some vertex
pe or qe has its thickness d(h) equal to ue = bpe = bqe. So, the contribution of these edges to the
total thickness �
h∈ ¯E d(h) of edges of ¯G is at most 3 �
e∈E ue ≤ 3
2|b|1. On the other hand, the only
edges that are not incident to some pe or qe are the ones of the form (pv, qv). However, the total
contribution of these edges to the total thickness is at most
�
v̸=s,t
min{
�
e∈E+(v)
ue,
�
e∈E−(v)
ue} ≤
�
v̸=s,t
�
e∈E+(v) ue + �
e∈E−(v) ue
2
≤ |u|1 ≤ |b|1,
as needed.
Now, the proof of correctness of this reduction appears in Appendix C.
5
Basic �O(m
3
2)-Time Algorithm for Bipartite b-Matching Problem
Over the next two sections, we prove Theorem 3.2. That is, we present an algorithm for the near-
perfect bipartite b-matching problem in the setting where the input instance is balanced (see (9))
and |b|1 is O(m). In what follows we assume, for convenience, that |b|1 is at most 2m and that the
graph G is sparse, i.e., m = O(n).7
7It is easy to see that these assumptions are made without loss of generality. Whenever |b|1 is O(m), one can
ensure that |b|1 ≤ 2m and m = O(n) by adding an appropriate – but still O(m) – number of dummy copies of
complete bipartite K6,6 graph with uniform demands. Adding each such dummy isolated copy brings the ratio of
|b|1 and m, as well as, of m to n down towards 18
12, while never leading to violation of the balance condition (9) and
preserving the b-matching structure of the original input graph.
14

In this section, we show a basic algorithm that runs in �O(m
3
2 ) time. Later, in Section 6, we
reﬁne this algorithm to obtain the desired running time of �O(m
10
7 ).
For the sake of clarity, in our description and analysis we assume that the nearly-linear time
Laplacian system solver (see Theorem 2.3) always returns an exact solution, i.e., all the electrical
σ-ﬂows we compute are exact. We discuss how to handle the approximate nature of the solver’s
output in Appendix E.9.
From b-Matching to Min-Cost σ-ﬂow
Let us ﬁx our instance of the bipartite b-matching problem in bipartite graph G = (V, E) with
V = P ∪ Q. We will solve our b-matching instance by reducing it to a task of ﬁnding a minimum-
cost ˆσ-ﬂow in a certain related directed graph �G = (�V , �E,ˆl) with ˆl being a length vector.
a)
b)
p1
p2
p3
p4
q1
q2
q3
v∗
sp1
sp2
sp3
sp4
tq1
tq2
tq3
2
1
4
2
1
3
1
-2
-1
-3
-1
4
1
2
0
Figure 2: a) An example instance of bipartite b-matching problem.
Numbers next to vertices
represent their demands.
b) The minimum-cost ˆσ-ﬂow problem instance corresponding to the
example from a). All arcs have cost ˆle equal to 1 and the numbers next to vertices denote their
demands in ˆσ. There are two parallel copies of the arc (sp1, tq1) and three parallel copies of the
arc (sp3, tq3). Also, each dashed arc represents two arcs that have the same endpoints but opposite
orientation.
The reduction is performed as follows (see Figure 2 for an example). The vertex set �V of the
graph �G consist of a special vertex v∗, as well as, vertices sp (resp. tq), for every vertex p ∈ P (resp.
q ∈ Q) of the graph G. Next, for every edge e = (p, q) in G, we add to �G d(e) copies of an arc
(sp, tq), where we recall that d(e) := min{bp, bq} is the thickness of e. Finally, for each vertex p ∈ P
(resp. q ∈ Q) of G, we add to �G arcs (sp, v∗) and (v∗, sp) (resp. (v∗, tq) and (tq, v∗)). We set the
lengths ˆle of all arcs e to 1.
To gain some intuition on this reduction, note that if a perfect b-matching indeed exists in G
then the ﬂow that encodes it in �G is fully supported on the arcs (sp, tq) and does not send more
than one unit of ﬂow on any of these arcs. So, the purpose of including the extra vertex v∗ and the
arcs incident to it is to support (and appropriately penalize) the initial and intermediate solutions
as they approach optimality.
Also, observe that this new graph hasˆ:= n + 1 vertices and, due to our b-matching instance
15

being balanced, we have that the total number �m of arcs is at most
2n +
�
e=(p,q)∈G
d(e) ≤ 2n + O(m) = O(m).
So, bounding our running time in terms of �m provides a bound in terms of the number of edges m
of our original b-matching instance that is asymptotically the same.
Now, consider a demand vector ˆσ that has surplus of bp at each vertex sp, a deﬁcit of bq at
each vertex tq and a zero demand at vertex v∗. (Note that such a demand vector will be valid,
i.e., �
v ˆσv = 0, as we can assume that �
p bp = �
q bq – otherwise it would be impossible to have
a perfect b-matching in G.) We claim that any near-optimal ˆσ-ﬂow gives us a solution to our
near-perfect b-matching instance. (Recall from Section 3 that a b-matching is near-perfect if its
size is at least |b|1
2 − �O( �m
3
7 ). Although, in the lemma below it suﬃces that we have a slack of only
1
2 instead of �O( �m
3
7 ).)
Lemma 5.1. Given any feasible ˆσ-ﬂow f in �G whose cost ˆl(f ) is within additive 1
2 of the optimum,
in �O( �m) time, we can either compute a (fractional) near-perfect b-matching x in G or conclude
that no perfect b-matching exists in G.
Proof. First, observe that if there exists a perfect b-matching x ∗ in G then a ﬂow f ∗ that just puts,
for each e = (p, q) of G,
x∗
e
d(e) ≤ 1 units of ﬂow on each (of d(e)) copies of the arc (sp, tq) in �G,
is a feasible ˆσ-ﬂow with cost |b|1
2 . (Recall that in the minimum-cost problem we assume that arc
capacities are inﬁnite, thus feasibility condition (2) boils down to non-negativity of all f∗
e s.) So, we
can assume that our ˆσ-ﬂow f has its cost ˆl(f ) at most |b|1
2 + 1
2. (Otherwise, we know that there is
no perfect b-matching in G.)
Now, given any feasible ˆσ-ﬂow in �G, we can decompose it into a collection of ﬂow-paths and
ﬂow-cycles, where each of these ﬂow-paths transports some amount of ﬂow from some vertex sp to
some vertex tq. By our construction of the graph �G, each such ﬂow-path has to have a length at
least 1. On the other hand, if this ﬂow-path is indeed of length exactly 1 then it has to correspond
to a single arc (sp, tq) that reﬂects the existence of edge (p, q) in G. As a result, our feasible ˆσ-ﬂow
f in �G has to have its cost ˆl(f ) to be at least |b|1
2
and, furthermore, ˆl(f )− |b|1
2
is an upper bound on
the total amount of ﬂow in f that is not transported over the direct one-arc ﬂow paths (and thus
passes through the vertex v∗).
So, as we argued that the cost of f has to be at most |b|1
2 + 1
2, there is only at most 1
2 units of
ﬂow in f that passes through the vertex v∗. Now, to extract the desired (fractional) near-perfect
b-matching x, we just take xe = f(sp,tq), for each edge e = (p, q) in G. Clearly, the size of such
fractional matching is at least |b|1
2 − 1
2, which is well above our lowerbound of |b|1
2 − �O(m
3
7 ) for a
near-perfect matching. Also, our construction works in �O( �m) time, as desired.
Slack Variables
In the light of the above, our goal now is to compute the near-optimal solution to our minimum-
cost ˆσ-ﬂow problem instance in the graph �G. Our approach to this task is inspired by so-called
path-following interior-point methods [Ye97, Wri97, BV04]. At a very high level, we will start with
certain initial solution that is far from being optimal, and then we will gradually improve – in an
16

iterative manner – its quality until close-to-optimal solution is obtained. This gradual improvement
will be performed in a very speciﬁc way. It will always try to push the current solution further down
so-called central path.
Before we can deﬁne the central path, let us ﬁrst mention that, in general, there are two natural
ways of tracking the progress of a current solution towards optimality. One of them is purely primal
and relies on just maintaining a feasible solution f and comparing its cost against some estimate of
the cost of the optimal solution. The second one – and the one that we will actually use here – is
based on primal-dual paradigm. Namely, in addition to maintaining a feasible primal solution f , we
will also keep a dual feasible solution y. This dual solution provides an embedding of all the vertices
in �G into a line, i.e., y just assigns a real number yv to each vertex v of �G. Its feasibility condition
is that for any arc e = (v, w) of �G it should be the case that its slack variable se := ˆle − yw + yv
is always non-negative, i.e., that the length of the arc e in this embedding is never larger than its
length according to the length vector ˆl.
Before we proceed further, we note that the dual solution y is uniquely determined – up to a
translation – by the vector s (given the length vector ˆl). So, for notational convenience, from now
on, we will describe the dual solutions in terms of the vector s instead of y.
Duality Gap
It is not hard to see that any feasible dual solution s provides a lower-bound on the cost of the
optimal solution (after all, this is just a consequence of weak duality). In particular, one has that
for any pair (f , s) of feasible primal and dual solutions, the so-called duality gap, i.e., the diﬀerence
between the upper bound on the value of optimal solution that is provided by the primal solution
f and the lower bound provided by the dual solution s is exactly
f T s = µT 1 =
�
e
µe,
where µe := fese, for each arc e, and 1 is all-ones vector (of dimension �m).
This means that one can obtain a close-to-optimal solution by devising a procedure that (quickly)
converges to a pair of primal and dual solutions (f , s) whose duality gap |µ|1 is small (in our case,
at most 1
2).
γ-Centered Solutions and the Central Path
To describe in more detail the convergence process we will employ, let us associate with each arc e a
measure νe ≥ 1. One can view νe as a certain notion of importance of a given arc. (The motivation
behind introducing this notion will be clear later.) We will always make sure that the measures of
arcs are not smaller than 1 and also that their total sum is never too large. That is, we will make
sure to maintain the following invariant.
Invariant 5.2. We have that νT 1 = �
e νe ≤ 4 �m and for each arc e, νe ≥ 1.
We want to note that when discussing the preservation of the above invariant we will only
focus on ensuring that the upperbound is not violated. The fact that νe ≥ 1 for all arcs e will be
automatically enforced as we will make sure that the initial measure of all the arcs is always at least
1 and our algorithm will never decrease any measures – they only might increase.
17

γ-centered solutions.
Now, let us deﬁne, for each arc e, ˆµe := µe
νe = fese
νe
to be the normalized
value of µe and let
ˆµ(f , s, ν) :=
�
�e fese
e νe
=
�
�e µe
e νe
=
�
�e νeˆµe
e νe
(10)
be the weighted average value of ˆµe with weights given by the measures ν.
We will call a solution (f , s, ν) (where ν represents the associated measures) γ-centered, for
some γ ≥ 0, if
∥ˆµ − ˆµ(f , s, ν)1∥ν,2 =
��
e
νe(ˆµe − ˆµ(f , s, ν))2 ≤ γˆµ(f , s, ν),
(11)
where, for a given vector x ∈ R �m,
∥x∥ν,p :=
��
e
νexp
e
� 1
p
,
(12)
i.e., ∥x∥ν,p is the ℓp-norm of the vector x reweighed by the measures ν.
Note that in a 0-centered solution (f , s, ν) we have all ˆµe equal to ˆµ(f , s, ν). More generally, a
simple but very useful observation is that
Fact 5.3. For any γ-centered solution (f , s, ν) we have that
(1 − γ)ˆµ(f , s, ν) ≤ ˆµe = fese
νe
≤ (1 + γ)ˆµ(f , s, ν),
for each arc e.
ˆµ(f , s, ν) as a measure of progress.
The quantity ˆµ(f , s, ν) will be important to us for one
more reason. It will constitute our measure of progress on the quality of our maintained solution.
To see why it indeed can serve this role, recall that by Invariant 5.2 we have that
f T s =
�
e
µe = ˆµ(f , s, ν)(
�
e
νe) ≤ 4ˆµ(f , s, ν) �m.
(13)
So, if our goal is to obtain a solution whose duality gap is at most 1
2 we just need to make sure that
the corresponding value of ˆµ(f , s, ν) is at most
1
8 �m.
The main reason why we choose to measure our progress in terms of ˆµ(f , s, ν) instead of the
actual duality gap f T s is that in our algorithm we will sometime end up increasing measures of
arcs. Such increases lead to an increase of the duality gap, so measuring our progress in terms of
f T s would require dealing with such local non-monotonicity of this quantity. Continently, once we
focus on keeping track of ˆµ(f , s, ν) (and ensure that Invariant 5.2 is never violated), these issues
will be avoided.
The central path.
Finally, after introducing the above deﬁnitions, we can deﬁne the central path
to be the set of all the 0-centered solutions.8 One can show that this set constitutes an actual path
8Strictly speaking, in the literature, the central path corresponds to 0-centered solutions with the measures of all
arcs being one.
18

in feasible space that spans all the 0-centered solutions and passes arbitrarily close to (but never
reaches) an optimal solution to our minimum cost ﬂow problem. This explains the name of “path-
following” interior-point methods, as they start with some initial 0-centered solution and gradually
advance along the central path to get increasingly more optimal γ-centered solution for some small
ﬁxed γ.
Traversing the Central Path with Electrical Flows
Motivated by this path-following approach, our algorithm for computing near-optimal solution to
the minimum-cost ˆσ-ﬂow problem will start with some 0-centered solution (f 0, s0, ν0) that has
fairly large value of ˆµ(f 0, s0, ν0) (and thus is far from being optimal).
Then, we will devise a
sequence of solutions (f t, st, νt), where t is the step index, that have increasingly smaller value
of ˆµ(f t, st, νt) (and thus, indirectly, the duality gap) while making sure that they always are ˆγ-
centered for some small constant ˆγ :=
1
400. This way, our algorithm will eventually converge to the
desired close-to-optimal solution.
To implement this approach, we start with the following lemma that shows we can get the initial
0-centered solution (f 0, s0, ν0) – its proof appears in Appendix D.1.
Lemma 5.4. There exists an explicit 0-centered primal-dual feasible solution (f 0, s0, ν0) with
�
e ν0
e ≤ 3 �m and ˆµ(f 0, s0, ν0) = 1.
Note that the bound on the total measure of the arcs ensures that the Invariant 5.2 is preserved.
Furthermore, there is a slack of at least �m remaining between �
e ν0 and the upperbound of 4 �m from
Invariant 5.2. It will be used to accommodate future measure increases in our improved algorithm
(see Section 6).
We now proceed to explaining how given some ˆγ-centered solution (f t, st, νt), we can modify it
to obtain a ˆγ-centered solution (f t+1, st+1, νt+1) that has a smaller value of ˆµ(f t, st, νt).
The associated ﬂow ˆf
t.
For a given solution (f , s, ν) let us call it σ-feasible, for some demand
vector σ, if it is dual feasible (i.e., s ≥ 0) and if f is a feasible σ-ﬂow. (So, a ˆσ-feasible solution
is a solution that is primal-dual feasible for our minimum-cost ˆσ-ﬂow problem.) Next, given a
σ-feasible solution (f , s, ν), let us deﬁne an associated electrical ﬂow ˆf to be the electrical σ-ﬂow
in (the undirected projection of) �G determined by resistances r that are given as
re := se
fe
=
µe
(fe)2 ,
(14)
for arc e. (Whenever we use this deﬁnition, it will be always the case that all fes are positive and
thus the resistances re are well-deﬁned.)
Making an improvement step.
The central object in our procedure for taking an improvement
step will be the electrical ﬂow ˆf
t that is associated with the solution (f t, st, νt). The fundamental
property of this ﬂow is that it allows us to simultaneously update our solution (f t, st, νt) both in
the primal (ﬂow) space – via the ﬂow ˆf
t itself – and in the dual (line embedding) space – via the
vertex potentials �φ
t that induced ˆf
t (see (5)). (In Section 7, we provide a detailed description of
the whole improvement step.)
19

As we will see, such a guided update not only decreases the duality gap of our solution, but also
perfectly maintains its centering when only ﬁrst-order terms (i.e., terms linear in the updates) are
accounted for. Unfortunately, the second-order terms (i.e., the ones depending on the product of
primal and dual updates) can disturb the centering. So, to be able to control this deﬁciency, we
need to ensure that the step size δt that governs the “aggressiveness” of the improvement step is
suﬃciently small.
Of course, on the other hand, it is important for us to have this step be as large as possible.
After all, the extent of our duality gap improvement – and thus overall convergence rate of our
algorithm – is directly proportional to this size. So, it is crucial for us to develop a good grasp on
how the size of that step relates to the properties of the ﬂow ˆf
t.
To this end, let us deﬁne, for some – not necessarily feasible – ﬂow f and a positive vector x > 0,
ρ(f , x) to be the vector of congestions inﬂicted in �G by f with respect to capacities given by x.
That is,
ρ(f , x)e := |fe|
xe
,
(15)
for each arc e in �G.
Now, in Section 7, we present a precise implementation and analysis of our update step. (This im-
plementation can be viewed as a direct analogue of the update steps of path-following interior-point
methods.) The result of this analysis is presented in the following theorem, which, in particular, ties
the congestion vector ρ(ˆf
t, f t) inﬂicted by the electrical ﬂow ˆf
t with respect to the primal solution
f t, to an upperbound on the size δt of the improvement step.
Theorem 5.5. Let (f t, st, νt) be a solution that is ˆγ-centered and ˆσ-feasible, and let ˆf
t be the
associated electrical ﬂow.
We can compute in �O( �m) time a ˆγ-centered and ˆσ-feasible solution
(f t+1, st+1, νt+1) with ˆµ(f t+1, st+1, νt+1) ≤ (1 − δt)ˆµ(f t, st, νt), as long as,
0 < δt ≤ min
�
√ˆγ
∥ρ(ˆf
t, f t)∥νt,4
, 1
2
�
.
Furthermore, we have that the measures do not change, i.e., νt+1 = νt, and if for each arc e, we
deﬁne (1 + κt
e) := (1−δt)st+1
e
ft
e
ft+1
e
ste
= (1−δt)rt+1
e
rte
and (1 + ¯κt
e) := (1−δt)ft
e
ft+1
e
to make κt (resp. ¯κt) reﬂect the
relative change (scaled by (1 − δt)) of resistances r t (resp. ﬂows f t) then ∥κt∥∞, ∥¯κt∥∞ ≤ 1
2 and
|κt
e|, |¯κt
e| ≤ 4(δtρ(ˆf
t, f t)e + ˆκt
e),
for some vector ˆκt with ∥ˆκt∥νt,2 ≤ 1
16.
So, we see that the allowed size δt of the improvement steps is proportional to how much the
guiding ﬂow ˆf
t resembles the current primal solution f t. Thus, for example, if there is some arc e
that ﬂows much larger ﬂow in ˆf
t than in f t, i.e., an arc e with large value of ρ(ˆf
be severely penalized by the ℓ4-norm measuring the quality of the resemblance.t, f t)e, this arc will
Also, it is worth pointing out that it is very important that the above bound is based on ℓ4
instead, say ℓ2 norm. In fact, one can show (see Lemma 6.8) that in case of our problem the ℓ2
norm of congestion vector is always Ω( �m
1
2 ). So, using ℓ2 norm would not lead to any improvement
over the Ω( �m
1
2 ) iteration bound.
20

5.1
Bounding the Running Time
At this point, we want to present a fairly elementary proof of δ := Ω( �m− 1
2 ) lowerbound on our
allowed improvement step size δt. Note that once we achieve that then, by Lemma 5.4 and Theorem
5.5, we will have that the value of our measure of progress ˆµ(f t, st, νt) after T steps is at most
ˆµ(f T , sT , νT ) ≤
T
�
t=1
(1 − δt) ≤ (1 − δ)T .
So, by setting T := δ−1 log 8 �m = �O( �m
1
2 ), we recover the O( �m
1
interior-point methods. This leads to a simple �O( �mδ−1) = �O(m2 ) iterations convergence bound of
3
2 )-time procedure that produces a
solution with duality gap at most
4 �mˆµ(f T , sT , νT ) ≤ 4 �m(1 − δ)T ≤ 1
2,
where we used Invariant 5.2 (see (13)). This, in turn, by Lemma 5.1 provides us with a solution to
our instance of near-perfect b-matching problem.
Therefore, to conclude the analysis of the simple �O(m
3
2 )-time algorithm for the near-perfect
b-matching problem, it remains to establish the claimed lowerbound on δt.
Congestion and energy.
By Theorem 5.5, performing such lowerbounding of δt boils down to
upperbounding ∥ρ(ˆf
t, f t)∥νt,4. To understand how the latter can be done, one should observe the
following simple but crucial fact. (This fact follows from Fact 5.3 and deﬁnition of the resistances
r t (14).)
Fact 5.6. For any γ-centered solution (f t, st, νt) and any ﬂow ˆf in �G we have that
rt
e ˆf2
e = st
ftee
ˆf2
e ≥ (1 − γ)νt
e
ˆµ(f t, st, νt)
(fte)2
ˆf2
e = (1 − γ)νt
eˆµ(f t, st, νt)ρ(ˆf , f t)2
e,
and, similarly,
rt
e ˆf2
e ≤ (1 + γ)νt
eˆµ(f t, st, νt)ρ(ˆf , f t)2
e,
for any arc e in �E.
Observe that the above inequalities state that – up to a (1 ± γ) factor – the square of the
congestion ρ(ˆf , f t)e incurred by an arc e in the ﬂow ˆf is upperbounded by
rt
e ˆf2
e
νteˆµ(f t, st, νt),
which corresponds to normalized (by νt
eˆµ(f t, st, νt)) contribution of the arc e to the energy Ert(ˆf )
of the ﬂow ˆf with respect to resistances r t.
This simple connection between the congestion of an arc in ˆf and its contribution to the energy
of that ﬂow that is provided by Fact 5.6 will be fundamental to the rest of our discussion.
In
particular, it gives us an intuition on why we even expect the guiding electrical ﬂows ˆf
t to inﬂict
small congestion with respect to f t and thus allow us to take a larger step size. This intuition is
21

based on an observation that the main goal of electrical ﬂows is to minimize energy. So, by choosing
the resistances appropriately, we in some sense align this goal with our goal of making as large step
sizes as possible. Roughly speaking, we are employing here the ℓ2 norm minimization oﬀered by
electrical ﬂows to achieve the desired ℓ4-minimization corresponding to larger step sizes.
∥ρ(ˆfNow, an immediate consequence of the above connection is an elementary way of upperbounding
t, f t)∥νt,4: we just bound the ℓ2-energy of the guiding electrical ﬂow ˆf
t that is associated with
our solution (f t, st, νt) and exploit the generic relationship between ℓ2 and ℓ4 norms.
To implement this approach, let us start with the following lemma that gives us a bound on the
ℓ2-energy of the electrical ﬂow ˆf
t.
Lemma 5.7. For any σ-feasible solution (f , s, ν) and associated electrical ﬂow ˆf , we have that
Er(ˆf ) ≤ Er(f ) ≤ 4 �mˆµ(f , s, ν).
Proof. The fact that Er(ˆf ) ≤ Er(f ) follows directly from the deﬁnition of ˆf and the fact that
electrical σ-ﬂow minimizes energy among all the σ-ﬂows (which includes f ).
Now, by deﬁnition (14) of r and that of ˆµ(f , s, ν) (10) we have that
Er(f ) =
�
e
se
fe
f2
e =
�
e
sefe = ˆµ(f , s, ν)(
�
e
νe) ≤ 4 �mˆµ(f , s, ν),
where the last line follows by Invariant 5.2.
Once we establish this upperbound on ℓ2-energy, we simply use it to upperbound the ℓ4-energy
of the congestion vector. Speciﬁcally, by applying Cauchy-Schwarz inequality and the fact that
∥x∥∞ ≤ |x|1, for any vector x, we get that
∥ρ(ˆf
t, f t)∥4
νt,4 =
�
e
νt
eρ(ˆf
t, f t)4
e ≤
��
e
�
νteρ(ˆf
t, f t)2
e
�2
≤
��
e
νt
eρ(ˆf
t, f t)2
e
�2
= ∥ρ(ˆf
t, f t)∥4
νt,2,
where we also used the fact that νt
e ≥ 1.
Now, to bound the ℓ2 norm (instead of ℓ4 norm) of the congestion vector, we just note that by
Fact 5.6 and Lemma 5.7
��
e
νt
eρ(ˆf
t, f t)2
e
�2
≤
��
e
νt
ert
ef2
e
(1 − ˆγ)νteˆµ(f t, st, νt)
�2
=
�
Ert(ˆf
t)
(1 − ˆγ)ˆµ(f t, st, νt)
�2
≤ O( �m2).
(16)
Therefore, we can conclude with the following lowerbound on δt.
Fact 5.8. For any t, δt ≥
1
O(
√
�m).
It is worth pointing out that, as we discussed before, the fact that we settled here for an ℓ2-
norm-based (instead of an ℓ4-norm-based) dependence of δt on the congestion vector ρ(ˆf
t, f t), this
1
O(
√
�m) lowerbound is the best possible to achieve with this approach. Therefore, to have any hope
of obtaining an improvement that goes beyond this bound (as we will do in the next section), we
crucially require to be working with ℓ4-norm-based (instead of only ℓ2-norm-based) arguments.
22

6
An Improved Algorithm for Bipartite b-Matching Problem
After setting up our primal-dual framework and presenting the �O(m
3
2 )-time algorithm in the pre-
vious section, we can now proceed to developing our improved algorithm with the running time of
�O(m
10
7 ) = �O(m
3
2 −η), for η := 1
14 − o(1).
Given our analysis and discussion in the previous section, a tempting approach to obtaining
such an improved bound could be trying to simply tighten our analysis performed there (e.g., by
taking advantage of ℓ4-norm-based instead of only ℓ2-norm-based arguments) and thus improve the
worst-case lowerbound on δt that we established (cf. Fact 5.8).
It turns out, however, that getting an improved bound is not merely a matter of performing
a better analysis. In the worst-case, our O( �m− 1
2 ) bound is actually tight. After all, if there is
an arc that incurs Ω( �m
1
2 ) congestion in the associated electrical ﬂow, the resulting ℓ4-norm of the
congestion vector will be Ω( �m
1
2 ). So, even though the connection between congestion and energy
we established before (see Fact 5.6 and Lemma 5.7) tells us that there cannot be too many such
arcs (as each one of them would need to contribute a very signiﬁcant, Ω(1), fraction of the total
energy of the electrical ﬂow), having just one such arc is already enough to prevent us from taking
larger than O( �m− 1
2 ) improvement step.
Therefore, as we cannot rule out that such worst-case situation arises in each iteration of our
algorithm9, getting our desired improvement requires developing a strategy that explicitly ensures
that this is not the case (or, at least, not too often).
At a high level, our general approach to accomplishing this goal is based on “massaging” the
solution that we maintain.
That is, we devise and carefully combine two methods of altering
our solutions. These methods, on one hand, signiﬁcantly improve the behavior of the associated
electrical ﬂow while, on other hand, only slightly perturb the characteristics of that solution that
are vital to recovering the desired near-perfect b-matching at the end.
The ﬁrst of these two methods is related to edge removal technique of Christiano et al. [CKM+11].
Their technique is based on repeated removal from the graph of the edges that suﬀer too much con-
gestion. As [CKM+11] showed (via a simple energy-based argument), when such edge removal is
applied to electrical ﬂows that guide multiplicative-weight-update-based optimization routine, one
obtains a signiﬁcantly faster convergence to approximately optimal solution.
Unfortunately, as our primal-dual framework has much more delicate nature than the multiplicative-
weight-update method, such removal of “bottlenecking” arcs would be too drastic and, in particular,
could destroy the structure of our dual solution. Therefore, we apply a more careful approach.
Instead of removing arcs, we only perturb them by moderately increasing their lengths (and thus
their slack variables). (Note that, by (14), increasing arc’s slack variable increases its resistance.)
Furthermore, to avoid signiﬁcant distortion of the dual solution, we do not apply this perturbation
to all “bottlenecking” arcs, but only the ones that are “heavy” in the primal solution (see Deﬁnition
6.7 below).
We then use a certain reﬁnement of the original energy-based argument of Christiano et al.
[CKM+11] (that needs, in particular, to deal with the fact that – in contrast to the multiplicative-
weight-update-based framework of [CKM+11] – in our framework the arc’s resistances can change
9One would suspect, however, that such situations are indeed rare. This might be one explanation of why in
practice interior-point methods are able to take most of its step sizes to be very large and thus converge much faster
than indicated by the worst-case bound of O( �m
3
2 ).
23

in a completely non-monotonic fashion) to show that the behavior of our guiding electrical ﬂows on
such “heavy” arcs is indeed improved.
Now, our second method – that is somewhat complementary to the ﬁrst one and aims at accom-
modating the “light” arcs – is based on an appropriate preconditioning of our solution by augmenting
it with auxiliary arcs. The purpose of adding these arcs is to improve the connectivity (and thus
electrical conductance) of the underlying solution (when treated as a graph with resistances) while
changing the structure of our original solution in only minimal way (that can be ﬁxed later). We
then show via a certain dual-based argument that existence of these auxiliary arcs ensures that
“light” arcs are never the bottlenecking ones (and thus do need to be dealt with anymore).
We proceed now to detailed description and analysis of our improved algorithm.
The Sets Sl(ˆf ) and θ-Smoothness
We start by specifying the behavior of associated electrical ﬂows that is “good” from our perspective.
To this end, for a ﬂow ˆf in �G, a solution (f , s, ν), and integer l, let us deﬁne Sl(ˆf ) to be the set of
all the arcs e such that
√
�m
2l+1 < ρ(ˆf , f )e ≤
√
�m
2l ,
(17)
i.e., the collection of all the arcs whose congestion in the ﬂow ˆf (with respect to capacities given by
f ) is between
√
�m
2l+1 and
√
�m
2l .
Now, we introduce a deﬁnition that will be fundamental to the rest of our discussion.
Deﬁnition 6.1. For some 0 ≤ θ ≤ 1, a ﬂow ˆf , and solution (f , s, ν) (that will be always clear from
the context), we say that ˆf is θ-smooth on some of arcs S ⊆ �E iﬀ, for any integer l ≤ log θ−3, we
have that
ν(Sl(ˆf ) ∩ S) ≤ ⌊θ323l⌋,
where ν(S′) := �
e∈S′ νe. Furthermore, we simply say that ˆf is θ-smooth if S = �E, i.e., S contains
all the arcs.
Clearly, the θ-smoothness constraints the distribution of the arcs that suﬀer high congestion in
ˆf . In particular, it implies that there is no arcs whose congestion ρ(ˆf , f )e is larger than θ
√
�m.
Observe that the tight worst-case example for the lowerbound on δt (cf. Fact 5.8) corresponds
to situation where the electrical ﬂow ˆf
t associated with the maintained ˆγ-centered solution solution
(f t, st, νt) makes some arcs highly-congested, i.e., makes them suﬀer congestion of Ω(
√
�m). How-
ever, the above deﬁnition of θ-smoothness, forbids existence of such arcs. Therefore, the hope is that
once our electrical ﬂows ˆf
t are θ-smooth, a better lowerbound on δt (and thus faster convergence)
is possible. As the following lemma shows, this hope is indeed well-founded.
Lemma 6.2. Let (f t, st, νt) be a σ-feasible and ˆγ-centered solution and let ˆf
t be the associated
electrical ﬂow that is θ-smooth, for some 0 ≤ θ ≤ 1. We have that
δt ≥
1
Cδθ
√
�m
,
for some suﬃciently large constant Cδ ≥ 1.
24

Proof. By Theorem 5.5, in order to lowerbound δt we need to upperbound the quantity
∥ρ(ˆf
t, f t)∥4
νt,4 =
�
e
νt
eρ(ˆf
t, f t)4
e.
To this end, note that
�
e
νt
eρ(ˆf
t, f t)4
e
≤
�
l
νt(Sl(ˆf
t)) �m2
24l ≤
�
l
⌊θ323l⌋ �m2
24l ≤
�
l≥⌊log θ−1⌋
θ3 �m2
2l
≤ 4θ4 �m2,
where we used the θ-smoothness of ˆf
t (cf. Deﬁnition 6.1) and the fact that ⌊θ323l⌋ = 0 whenever
l < ⌊log θ−1⌋. So, the lemma follows once Cδ > 0 is chosen to be an appropriately large constant.
In the light of the above lemma, if we somehow knew that all – or, at least, most of – the ﬂows ˆf
t
that we compute are indeed θ-smooth for some θ = O( �m−η), we would immediately get the desired
faster algorithm. Unfortunately, as we already discussed, it seems to be hard to argue that this
is what happens in the worst-case. Therefore, to address this problem we develop a perturbation
approach that we carefully apply to our maintained solutions to ensure that most of the ﬂows ˆf
t is
indeed θ-smooth for some small enough value of θ.
α-Stretching
One of the main operations that we will use to implement our perturbations is called α-stretching.
To describe it, consider a solution (f , s, ν) that is γ-centered and a parameter α ≥ 0. We deﬁne an
α-stretching of an arc e to be an operation that returns a solution (f ′, s′, ν′) obtained from (f , s, ν)
by, ﬁrst, increasing the length ˆle of the arc e (and thus the value of se) by αse and, then, increasing
the measure νe of e by a factor of (1 + β), where
β :=
αfese
νeˆµ(f , s, ν).
(18)
The remaining part of the solution remains the same.
The property of α-stretching that is key from our point of view, is that after applying it to some
arc e its resistance re := se
fe increases by a factor of exactly (1 + α). Furthermore, our choice of
value of β is justiﬁed by the lemma below – its proof appears in Appendix E.1.
Lemma 6.3. If (f , s, ν) was a γ-centered solution with γ ≤
1
2 then so will be (f ′, s′, ν′) and
ˆµ(f ′, s′, ν′) = ˆµ(f , s, ν). Furthermore, (1 − γ)α ≤ β ≤ (1 + γ)α.
So, we see that applying α-stretching with this setting of β does not perturb our measure of
progress ˆµ(f , s, ν), even though the duality gap f T s changes due to corresponding increase in
measure. (Again, this is one reason why we chose ˆµ(f , s, ν) to measure our progress.)
On the other hand, besides the increase in measure, another undesirable byproduct of α-
stretching is the increase of arc’s length. To mitigate the eﬀect of this process on the validity of our
ﬁnal solution, we will ensure that the following invariant is maintained throughout the algorithm.
Invariant 6.4. The overall increase of arcs’ length due to α-stretching is at most �O( �m
1
2 −η) and no
individual arc has its total increase of length larger than 1.
25

Maintaining this invariant will be important for two reasons. One is captured by the following
simple lemma, whose proof appears in Appendix E.2.
Lemma 6.5. If Invariant 6.4 is preserved then for any σ-feasible solution (f , s, ν), we have that
se is at most 6, for any arc e.
The other, and even more important one, is that as long as this invariant is preserved the ﬁnal
close-to-optimal solution (f t, st, νt) to our perturbed problem still allows us to recover the desired
near-perfect b-matching in the (original) graph G (or conclude that no perfect b-matching exists).
More precisely, in Appendix E.3 we prove the following lemma.
Lemma 6.6. Provided Invariant 6.4 holds, given any feasible ˆσ-ﬂow f in �G whose cost is within
additive 1
2 of the optimum, we can recover in �O( �m) time a (fractional) near-perfect b-matching in
G, or conclude that no perfect b-matching exists in G.
Heavy Arcs
As we already mentioned, an important role in our improved algorithm is played by a classiﬁcation
of arcs into two classes, “heavy” and “light”, depending on their current ﬂow in the primal solution.
We make this classiﬁcation precise below.
Deﬁnition 6.7. Given a γ-centered solution (f , s, ν) with γ ≤ 1
2, we call an arc e heavy if fe ≥
νeFH, where
FH := C−1
H �m
1
2 −3η ˆµ(f , s, ν),
for some suﬃciently large constant CH > 1 that we will ﬁx later (see Lemma 6.15). We say that an
arc is light if it is not heavy.
The motivation for the above classiﬁcation stems from a desire to control the increase in arc’s
length due to an application of α-stretching. Namely, observe that if we α-stretch an heavy arc e
then the increase in this arc’s length is by at most
αse ≤ α(1 + γ)νeˆµ(f , s, ν)
fe
≤ CH(1 + γ)α �m3η
√
�m
,
where we used Fact 5.3. So, as long as we apply α-stretching operations only to heavy arcs – which
essentially will be the case in our algorithm – we can guarantee that the resulting change in arc
length is relatively small. This will be important to ensuring that Invariant 6.4 is never violated.
Having introduced the above concepts, we are ready to proceed to presenting our improved
algorithm. In this presentation, we ﬁx for the rest of this section ˆθ := �m−η, where
η := 1
14 − Cη
log log n
log n
(19)
and Cη is a suﬃciently large constant to be ﬁxed later.
We describe our algorithm in two stages.
First, in Section 6.1, we present a variant of the
algorithm that works under an ad-hoc assumption that all the electrical ﬂows ˆf
t that we compute
are always ˆθ-smooth on the set of light arcs. (So, we need to deal there only with its possible non-ˆθ-
smoothness on the set of heavy arcs.) Then, in Section 6.2, we show how to apply a preconditioning
technique to obtain an augmented version of our graph such that when we run our algorithm it is
indeed true that the above ad-hoc assumption holds.
26

6.1
Perturbing Heavy Arcs
In this section, we work under an ad-hoc assumption that the electrical ﬂows ˆf
t that are associated
with the maintained solutions (f t, st, νt) are always ˆθ-smooth – with ˆθ := �m−η – on the set of arcs
that are light with respect to that solution. We present an �O( �m
3
2 −η)-time algorithm for this setting.
ˆθ-Improvement Phase
The core of this algorithm is an implementation of a primitive we call a ˆθ-improvement phase.
This primitive, given a ˆσ-feasible and ˆγ-centered solution (f t0, st0, νt0), returns in �O( �m1+2η) time
a ˆσ-feasible and ˆγ-centered solution (f tf , stf , νtf ) such that
ˆµ(f tf , stf , νtf ) ≤ ˆλˆµ(f t0, st0, νt0),
(20)
where ˆλ :=
�
1 −
1
2Cδ ˆθ
√
�m
�ˆθ−2
and Cδ is the constant from Lemma 6.2.
Observe that once we obtain an implementation of such a ˆθ-improvement phase, we can get
the desired improved algorithm as follows.
We start with a ˆσ-feasible and ˆγ-centered solution
(f 0, s0, ν0) as in Lemma 5.4. Next, we apply �T iterations of ˆθ-improvement phase to it, with
�T := 2Cδ ˆθ3√
�m ln 8 �m = O( �m
1
2 −3η log �m).
(21)
Note that after doing this, we know that if (f F , sF , νF ) is the ﬁnal ˆσ-feasible ˆγ-centered solution
we compute then
ˆµ(f F , sF , νF ) ≤ ˆλ
�T ˆµ(f 0, s0, ν0) =
�
1 −
1
2Cδ ˆθ
√
�m
�2Cδ ˆθ
√
�m ln 8 �m
≤
1
8 �m.
So, as long as we can show that (f F , sF , νF ) satisﬁes Invariants 5.2 and 6.4, we can use Lemma
6.6 to recover the desired near-perfect b-matching in G or conclude that no perfect b-matching
exists in G. Also, the overall running time of this algorithm will indeed be �O( �T �m1+2η) = �O( �m
3
2 −η),
as desired.
Implementation of ˆθ-Improvement Phase via Stretch-boosts
In the light of the above discussion, we just need to focus on implementing the ˆθ-improvement
phase, as well as, ensuring that running it for �T iterations will not violate Invariants 5.2 and 6.4.
Our implementation – presented in Figure 3 – is an iterative procedure. We maintain a ˆσ-
feasible ˆγ-centered solution (f t, st, νt) – initially, (f t, st, νt) is equal to (f t0, st0, νt0). Next, as long
as ˆµ(f t, st, νt) > ˆλˆµ(f t0, st0, νt0) we repeat the following iterative step.
We ﬁrst check if the electrical ﬂow ˆf
t associated with (f t, st, νt) is ˆθ-smooth on the set of heavy
arcs.
If it is indeed the case then one can easily see that such ˆf
t needs to be 2ˆθ-smooth (on the set
of all the arcs). (This uses our ad-hoc assumption that all ˆf
t we compute are always ˆθ-smooth on
the set of light arcs.) So, in this situation, we can just apply an interior-point method step – as
described in Theorem 5.5 – to (f t, st, νt) with setting δt :=
1
2Cδ ˆθ
√
�m. (Note that by Lemma 6.2 this
setting of δt is valid.) For future reference, we call this step a progress step. After executing it, we
27

Input
: A ˆσ-feasible and ˆγ-centered solution (f t0, st0, νt0)
Output: A ˆσ-feasible and ˆγ-centered solution (f tf , stf , νtf ) with ˆµ(f t, st, νt) ≤ ˆλˆµ(f t0, st0, νt0)
Initialize t ← t0
while ˆµ(f t, st, νt) > ˆλˆµ(f t0, st0, νt0) do
Compute the electrical ˆσ-ﬂow ˆf
t associated with (f t, st, νt)
if ˆf
t is ˆθ-smooth on heavy arcs then
Apply interior-point method step from Theorem 5.5 to (f t, st, νt) with δt :=
1
2Cδ ˆθ
√
�
m
Save the resulting solution as (f t+1, st+1, νt+1)
(∗ progress step ∗)
else
Let l∗ ≤ log ˆθ−3 be such that νt(Sl∗(ˆf
t) ∩ Et
H) > max{ˆθ323l∗, 1}
foreach arc e in Sl∗(ˆf
t) ∩ Et
H do apply 1-stretching to e
(∗ stretch-boost ∗)
endSave the resulting solution as (f t+1, st+1, νt+1)
endt ← t + 1
Output (f t, st, νt) as the solution (f tf , stf , νtf )
Figure 3: Implementation of ˆθ-improvement phase via stretch-boosts
set the resulting ˆσ-feasible and ˆγ-centered solution (f t+1, st+1, νt+1) as our current solution and
proceed to next iterative step.
Otherwise, that is, if ˆf
t is not ˆθ-smooth on the set of heavy arcs, then – by Deﬁnition 6.1 –
there is an l∗ ≤ log ˆθ−3 such that
νt(Sl∗(ˆf
t) ∩ Et
H) > max{ˆθ323l∗, 1},
(22)
where we used the fact that all measures of arcs are always at least one and Et
H denotes the set of
heavy arcs with respect to the solution (f t, st, νt).
To cope with this situation, we perform 1-stretching of all the arcs in Sl∗(ˆf
t)∩Et
Ht. (Note that,
by Lemma 6.3, this operation does not change the value of ˆµ(f t, st, νt) and our solution remains
ˆσ-feasible and ˆγ-centered.) We call this operation stretch-boosting and l∗ will be referred to as the
index of this stretch-boosting. After performing stretch-boosting, we proceed to the next iterative
step.
This ﬁnishes the description of our implementation.
Analysis
To analyze the above procedure, let us note that due to our stopping condition, once this procedure
terminates the resulting solution (f tf , stf , νtf ) satisﬁes our requirements. Also, there will be at
most ˆθ−2 progress steps executed. This is so, as 1-stretching does not aﬀect the value of ˆµ(f t, st, νt)
ˆλand, by Theorem 5.5, each progress step decreases ˆµ(f t, st, νt) by a factor of at least (1 − δt) =
1
ˆθ−2 . Thus, as each of these steps runs in �O( �m) time, the resulting total time of progress steps is
�O( �mˆθ−2) = �O( �m1+2η), as desired.
Therefore, we can just focus on bounding the number of stretch-boost operations executed, as
28

well as, on showing that calling our implementation of ˆθ-improvement phase �T times does not violate
Invariants 5.2 and 6.4.
We start with the former task. In this bounding of the number of stretch-boost operations, we
assume that Invariant 5.2 holds. We will justify this assumption later when proving that our two
desired invariants are indeed preserved by our algorithm.
To do the bounding, we consider the energy Ert(ˆf
t) of the electrical ˆσ-ﬂow ˆf
t (determined by
resistances r t given by (14)) that is associated with our current solution (f t, st, νt). We treat this
quantity as a potential function and show the following facts:
(a) Ert(ˆf
t) is always at least C−1
E �mˆµ(f t, st, νt) and at most CE �mˆµ(f t, st, νt), for some suﬃciently
large constant CE > 1 – see Lemma 6.8;
(b) Ert(ˆf
t) increases by a factor of at least (1 + CS ˆθ2), for some constant CS > 0, whenever a
stretch-boosting step is applied – see Lemma 6.9;
(c) Ert(ˆf
t) decreases by a factor of at most (1 + CP ˆθ2 ln �m) each time a progress step is executed,
where CP > 0 is some suﬃciently large constant – see Lemma 6.11.
Note that once the above statements are established, it must be the case that there is at most
Ts := CP C−1
S ˆθ−2 ln C2
E �m = �O(ˆθ−2) stretch-boost operation overall. To see that, assume this was
not the case, i.e., that there was more than Ts stretch-boosts. Then, by the above statements and
the fact that there is at most ˆθ−2 progress steps we would have that
Ertf (ˆf
tf ) > (1 + CS ˆθ2)TsErt0(ˆf
t0)
(1 + CP ˆθ2 ln �m)ˆθ−2
≥ (1 + CS ˆθ2)Ts �mˆµ(f t0, st0, νt0)
CE �mCP
≥ CE �mˆµ(f tf , stf , νtf ),
which would violate the upperbound on energy Ertf (ˆf
tf ) established by statement (a).
So, it must be then indeed the case that there is at most Ts = �O(ˆθ−2) stretch-boosts, which
gives the desired �O(ˆθ−2 �m) = �O( �m1+2η) total running time bound.
In the light of the above, we can turn our attention to proving statements (a)-(c). We start
with statement (a). This statement essentially follow from Lemma 5.7 and some simple energy-
lowerbounding argument. The prove of the following lemma appears in Appendix E.4.
Lemma 6.8. Let (f t, st, νt) be a ˆσ-feasible and ˆγ-centered solution. Provided that Invariant 5.2
holds, we have that
C−1
E �mˆµ(f t, st, νt) ≤ Ert(ˆf
t) ≤ CE �mˆµ(f t, st, νt),
where ˆf
t is the electrical ˆσ-ﬂow associated with the solution (f t, st, νt) and CE > 1 is a suﬃciently
large constant.
Next, we proceed to analyzing the eﬀect of stretch-boosting on the energy Ert(ˆf
t). Intuitively,
by the connection between congestion and energy hinted by Fact 5.6, we know that the arcs with
large congestion have to have unusually high contribution to the energy Ert(ˆf
t). So, as 1-stretching
eﬀectively doubles the resistances of such arcs, it is not surprising that it ends up signiﬁcantly
increasing that energy. We make this formal – and thus establish statement (b) – in the lemma
below. Its proof appears in Appendix E.5.
29

Lemma 6.9. Each stretch-boost increases Ert(ˆf
t) by a factor of at least
�
1 + CS ˆθ2 �
νt(Sl∗(ˆf
t) ∩ Et
H)
� 1
3
�
≥
�
1 + CS ˆθ2�
,
for some constant CS > 0.
To complete our analysis, it remains to show that our potential Ert(ˆf
t) does not decrease too
much during the progress steps. In other words, we prove statement (c).
Note that the diﬃculty here stems from the fact that, in principle, the resistances of arcs can
change pretty arbitrarily during a progress step. They can either increase or decrease and even
by a constant multiplicative factor, thus possibly leading to severe and very non-monotone energy
ﬂuctuations.
The key reason that enables us to control that energy change after all, is that we perform the
progress step only if the ﬂow ˆf
t is ˆθ-smooth. This is helpful in two ways. Firstly, because we can
use it together with the connection between the change of the resistance of an arc and its congestion
that we established in Theorem 5.5, to show that there is not too many arcs that signiﬁcantly change
their resistance (see Lemma 6.10 below). Secondly (and even more importantly), our connection
between congestion and energy, allows us to conclude that ˆθ-smoothness implies that there is no
small (measure-wise) set of arcs that contributes unusually high portion of the energy. So, even
if some small set of arcs changes its resistances signiﬁcantly, it is not able to inﬂuence the overall
energy by too much (see Lemma 6.11). (In a sense, this intuition is one of the main motivations for
introducing the notion of ˆθ-smoothness.) We, again, formalize this intuition below.
First, for a given vector λ and an integer l, let us deﬁne T λ
l
to be the set of all arcs such that
1
2l+1 ≤ |λe| ≤ 1
2l .
(23)
Now, we say that λ is τ-restricted, for some measure ν and τ ≥ 0 if for any l ≥ 0,
ν(T λ
l ) ≤ τ23l.
(24)
Now, the lemma below bounds the change of resistances during any of our progress steps.
Lemma 6.10. Let ˆf
t be a 2ˆθ-smooth electrical ﬂow associated with (f t, st, νt). Let (f t+1, st+1, νt+1)
be the solution obtained by applying an interior-point method step – as in Theorem 5.5 – to (f t, st, νt)
with δt := (2Cδ ˆθ
√
�m)−1. Then the vectors κt and ¯κt are all CR-restricted (with respect to νt) for
some constant CR > 0.
Proof. We will prove that both the vector δtρ(ˆf
t, f t) and the vector ˆκt are O(1)-restricted. It is
easy to see that then the bound from Theorem 5.5 will imply that ¯κt and κt are O(1)-restricted
too. So, choosing large enough constant CR will prove the lemma.
To this end, observe ˆκt is O(1)-restricted as ∥ˆκt∥νt,2 by Theorem 5.5. On the other hand, note
that if
δtρ(ˆf
t, f t)e ≥ 1
2l ,
for some l ≥ 1 and arc e, then e ∈ Sl′(ˆf
t) for some
l′ ≤ l + log δt√
�m + 2 ≤ l + log ˆθ−1 + O(1).
30

But by 2ˆθ-smoothness of ˆf
t, this means that the total measure of such arcs is at most
⌊ˆθ−323l′⌋ ≤ O(23l),
which establishes that δtρ(ˆf
t, f t) is indeed O(1)-restricted. The lemma follows.
Using the above observation, we can now ﬁnish establishing property (c) by proving the following
lemma whose appears in Appendix E.6.
Lemma 6.11. Let ˆf
t be a 2ˆθ-smooth electrical ﬂow associated with the ˆγ-centered solution (f t, st, νt).
Let (f t+1, st+1, νt+1) be the solution obtained by applying an interior-point methods step – as in
Theorem 5.5 – to (f t, st, νt) with δt := (2Cδ ˆθ
√
�m)−1. Then,
Ert+1(ˆf
t+1) ≥ (1 + CP θ2 ln �m)−1Ert(ˆf
t),
where ˆf
t+1 is the electrical ﬂow associated with (f t+1, st+1, νt+1) and CP > 1 is a suﬃciently large
constant.
Preservation of Invariants 5.2 and 6.4
Now, as we completed the analysis of the running time of our ˆθ-improvement phase implementation,
we establish the remaining claim, i.e., we prove that executing the above procedure �T times does
not lead to violation of Invariants 5.2 and 6.4.
Bounding measure increase.
To this end, let us ﬁrst focus on bounding the measure increases.
By Lemma 6.3, we know that whenever we 1-stretch an arc e, its measure increases by at most
(1+ ˆγ)νt
e. So, to bound the total measure increase it suﬃces to bound the total measure of arcs that
are aﬀected by 1-stretches across all the stretch-boost operations. (Here, if the same arc becomes
1-stretched multiple times, in diﬀerent stretch-boosts, we account for its measure multiple times.)
In order to do that, note that by Lemma 6.9, if νi is the measure of the set of arcs that are
1-stretched in i-th stretch-boost, we have that the total increase of energy resulting from that is at
least
k
�
i=1
(1 + CS ˆθ2ν
31
i ).
Also, by Lemma 6.8, we know that we have to have that in any single stretch-boost, the energy
cannot increase by more than C2
E factor. So, we have that
(1 + CS ˆθ2ν
31
i ) ≤ C2
E
and thus νi ≤ νmax := C6
E ˆθ6 = O( �m6η), for each i.
As a result, we can lowerbound the total increase of energy due to stretch-boosts by
k
�
i=1
(1 + CS ˆθ2ν
31
i ) ≥ (1 + CS ˆθ2ν
1
3max)
ν
νmax ,
where ν := �
i νi.
31

Finally, by Lemma 6.8 and Lemma 6.11, as well as, the fact that we have at most ˆθ−2 progress
steps, we know that the overall (multiplicative) increase of energy resulting from all the stretch-
boosts can be at most
(1 + CS ˆθ2ν
1
3max)
ν
νmax ≤
k
�
i=1
(1 + CS ˆθ2ν
31
i ) ≤ C2
E(1 + CP ˆθ2 log �m)
ˆθ−2.
Therefore, as ˆθ2ν
1
3max is Ω(1), we have that the total measure increase ν is at most
ν ≤ �O(νmax) = �O( �m6η).
(25)
As a result, after executing at most �T ˆθ-improvement phases, the overall increase of measure can
be bounded by
�T · �O( �m6η) = �O( �m
1
2 +3η) < �m.
(26)
Now, given that by Lemma 5.4, we start with our measure being at most 3 �m and thus have a slack
of at least �m measure left before Invariant 5.2 becomes violated, this overall increase will indeed
not lead to violation of this invariant.
Bounding arc length increase.
To show that Invariant 6.4 is preserved as well, let us ﬁrst note
that the only way for length of arcs to increase is due to 1-stretching occurring during stretch-boosts.
Furthermore, we only 1-stretch an arc if it is heavy. So, if a given (heavy) arc e gets 1-stretched at
some step t then its length increases by at most
st
e ≤ (1 + ˆγ)νt
eˆµ(f t, st, νt)
fte
≤ (1 + ˆγ)CH �m3η
√
�m
.
On the other hand, by Lemma 6.3, the increase of measure of such arc is at least (1 − ˆγ)νt
e. So, as
νt
e ≥ 1, the increase of measure of an arc is within a factor of O( �m3η
√
�m ) = O( �m−4η) of increase of the
length. So, as we just proved that the total measure increase is at most �O( �m
1
2 +3η) (cf. (26)), the
desired bound of �O( �m
1
2 −η) on the total length increase follows.
Finally, as each 1-stretch increases the measure by a factor of at least (2 − ˆγ) ≥ 3
2 and – as we
discussed above – we never 1-stretch anymore an arc whose measure is bigger than νmax = O( �m6η),
no single arc will get 1-stretched more than O(log νmax) = O(log �m) times. As a result, no single
arc has its length increased by more that O( �m−4η log �m) that is much smaller than 1. Therefore,
the Invariant 6.4 is also preserved. This concludes our analysis.
6.2
Preconditioning the Graph �G
Our analysis from the previous section was crucially relying on the assumption that all the ﬂows ˆf
t
are always ˆθ-smooth on the set of light arcs. Unfortunately, this assumption is not always valid.
To cope with this problem, we develop a modiﬁcation of our algorithm that ensures that this
ˆθ-smoothness assumption holds after all. Roughly speaking, we achieve that by an appropriate
preconditioning our solution at the beginning of each ˆθ-improvement phase. This preconditioning
is based on augmenting the graph �G with additional, auxiliary arcs and correspondingly extending
our solution on them. These arcs are very light (i.e., have small value ft
e of ﬂow ﬂowing through
32

them in augmented solution), while providing good connectivity (and thus relatively low eﬀective
resistance) between diﬀerent vertices of the augmented graph.
The underlying intuition here is that the over-congestion of a light arc e is caused by amounts
of ﬂow that are at most
√
�mFH (cf. Deﬁnition (6.7)) and thus are relatively small compared to the
ˆfwhole duality gap. So, by deploying these very light auxiliary arcs we encourage the electrical ﬂow
t to reroute such over-congesting ﬂow from e and send it along auxiliary arcs. On the other hand.
as the small value of this rerouted ﬂow is small, the perturbation of our desired (non-augmented)
solution introduced by these rerouting is relatively minor. Thus, we are able to deal with it relatively
easily at the end of the whole ˆθ-improvement phase, while still ending up making overall progress
on the quality of our solution.
Augmenting the Graph and the Solution
The exact implementation of our preconditioning is based on modifying the execution of ˆθ-improvement
phase that was presented in the previous section in the following way. Let (f t0, st0, νt0) be the ˆγ-
centered and ˆσ-feasible solution at the beginning of some ˆθ-improvement phase.
We start with augmenting the graph �G by adding to it a new vertex ¯v, as well as, av copies of
an arc (v, ¯v) and av copies of an arc (¯v, v), for each vertex v of �G other than v∗, where
av :=
�
e∈E(v)
νt0
e
(27)
is the total measure (with respect to νt0) of all the arcs adjacent to v in �G. We will call these newly
added arcs auxiliary and denote the augmented graph as ¯G.
Next, we extend the solution (f t0, st0, νt0) to that augmented graph ¯G by assigning ft0
e := FA,
st0
e := ˆµ(f t0,st0,νt0)
fe
and νt0 := 1 to each auxiliary arc e, where
FA := Cδ ˆµ(f t0, st0, νt0) �m
1
2 −3η
CA �T
(28)
with CA being some suﬃciently large constant to be ﬁxed later, and the lengths of the auxiliary
arcs being chosen so that the extended solution is still dual feasible. (As we will soon see, the actual
lengths of auxiliary arcs are irrelevant.) Note that after this extension, the solution (f t0, st0, νt0)
remains ˆγ-centered, ˆσ-feasible and the value of ˆµ(f t0, st0, νt0) is unchanged. Also, observe that
by Invariant 5.2, the number ¯m of arcs of the augmented graph ¯G is still only O( �m). So, relating
various quantities – in particular, the running times of our procedures – to either �m or ¯m results in
only a constant-factor discrepancy (that we will ignore in what follows).
Now, after the above preprocessing, we run the ˆθ-improvement phase implementation, as de-
scribed in the previous section, on the extended solution in the augmented graph ¯G. (In Section
6.2, we will prove that the assumption that underlies the analysis from the previous section, i.e.,
that all the ﬂows ˆf
t are ˆθ-smooth on light arcs, is indeed valid.) The only further modiﬁcation
here is that after each progress step we �m2η|¯κt
e|-stretch each auxiliary arc e with |¯κt
e| ≥ ˆθ2 (cf.
Theorem 5.5). We will call this stretch operation freezing. (Note that as α-stretching only increases
the resistances of arcs, this modiﬁcation is compatible with the energy-based potential argument
we employed in the previous section.) This freezing ensures that the ﬂows on auxiliary arcs do not
change to signiﬁcantly in our solution and thus the impact of preconditioning provided by auxiliary
33

arcs on the quality of the ﬁnal solution is minimized. We make this more precise in the following
lemma whose proof appears in Appendix E.7.
Lemma 6.12. During the whole ˆθ-improvement phase, we have that for each auxiliary arc e,
C−1
F FA ≤ ft
e ≤ CF FA, for some constant CF > 0. Also, the total increase of measure of auxil-
iary arcs in that phase is at most �O( �m8η).
Finally, once the execution of the above ˆθ-improvement phase ﬁnishes, we end up with a ˆγ-
centered and ˆσ-feasible solution (f t, st, νt) such that ˆµ(f t, st, νt) ≤ ˆλˆµ(f t0, st0, νt0), as desired.
However, this solution corresponds to the augmented graph ¯G instead of to the original graph �G.
To deal with this deﬁciency, we ﬁrst simply discard all the auxiliary arcs and correspondingly
truncate the solution (f t, st, νt) to non-auxiliary arcs. Unfortunately, doing that might, in partic-
ular, render that solution not ˆσ-feasible. So, to alleviate this problem, in Section 6.2 below, we
describe a ﬁxing procedure that, given such a truncated solution, produces the intended solution
(f tf , stf , νtf ) that corresponds to the original graph �G, is ˆγ-centered, ˆσ-feasible and
ˆµ(f tf , stf , νtf ) ≤ ˆλ(1 + O( �m− 1
2 ))ˆµ(f t0, st0, νt0).
(Note that in our algorithm we are executing only �T = �O( �m
1
2 −3η) ˆθ-improvement phases overall.
So, this additional (1 + O( �m− 1
2 )) factor above is inconsequential.)
As we will see, a byproduct of this ﬁxing procedure is an increase in the measure of (non-
auxiliary) arcs. However, we will show that this increase is bounded by O( CF �m
CA �T ). Thus, taking
CA to be suﬃciently large ensures that the resulting measure increases do not lead to violation of
Invariant 5.2. (Note that the auxiliary arcs are always discarded at the end, so from the point of
view of Invariant 5.2, it suﬃces that by Lemma 6.12 the measure of these arcs is always o( �m).)
In the light of the above discussion, all that remains is to describe and analyze the ﬁxing
procedure and to show that one can indeed assume that all the electrical ﬂows ˆf
t computed during
such ˆθ-improvement phase are ˆθ-smooth on the set of light arcs.
Fixing Procedure
We start by describing and analyzing the ﬁxing procedure that we employ at the end of each ˆθ-
improvement phase. Recall that in this procedure we are given as input a ˆγ-centered and ˆσ-feasible
solution (f t, st, νt) in the augmented graph ¯G such that ˆµ(f t, st, νt) ≤ ˆλˆµ(f t0, st0, νt0). Our goal
is to obtain a ˆγ-centered ˆσ-feasible solution (f tf , stf , νtf ) in the original graph �G that satisﬁes
ˆµ(f tf , stf , νtf ) ≤ ˆλ(1 + O( �m− 1
2 ))ˆµ(f t0, st0, νt0).
We do this in two steps. First, we simply truncate the solution (f t, st, νt) to the original graph
�G by discarding all the auxiliary arcs and ﬂow on them. Let us denote the resulting solution as
(f ′, s′, ν′). It is not hard to see that this solution is still ˆγ-centered. In the following lemma – whose
proof appears in Appendix E.8 – we argue that also the value of ˆµ(f ′, s′, ν′) has not increased by
much.
Lemma 6.13. ˆµ(f ′, s′, ν′) ≤ ˆλ(1 + O( �m− 1
2 ))ˆµ(f t0, st0, νt0).
At this point, we know that the solution (f ′, s′, ν′) is ˆγ-centered and ˆµ(f ′, s′, ν′) is as small as
needed. Unfortunately, this solution can still be not ˆσ-feasible.
Therefore, in the second step of our procedure, we address this last shortcoming. Our approach
here requires introducing a certain simple operation. For a given some solution (f , s, ν), as well as,
34

some α ≥ 0 and an arc e, let us deﬁne α-widening of e (in (f , s, ν)) as an operation in which we
increase the value of fe by a factor of (1+α) and increase νe by a factor of (1+β), where β is given
via (18).
We can view the α-widening operation as a counterpart of the α-stretching operation. In fact,
one can see that due to symmetric nature of fe and se and our choice of β, Lemma 6.3 also holds for
α-widening operation. (Note that in the proof of Lemma 6.3 the roles of fe and se are completely
interchangeable.)
Now, our way of obtaining the desired solution (f tf , stf , νtf ) is very simple. Let us denote by
¯σ the actual demand vector of f ′ and let ˜σ := ˆσ − ¯σ be the vector of demand diﬀerences. We
start with (f ′, s′, ν′) and for each vertex v of �G other than v∗, we do the following. If ˜σv ≥ 0 (resp.
˜σv < 0), we apply αv-widening to the arc e(v) := (v, v∗) (resp. e(v) := (v∗, v)) with αv := |˜σv|
f′e .
We take (f tf , stf , νtf ) to be the resulting solution. It is easy to see that this solution is ˆσ-feasible
now. Also, by Lemma 6.3, we know that this solution remains ˆγ-centered and that ˆµ(f tf , stf , νtf ) =
ˆµ(f ′, s′, ν′) ≤ ˆλ(1 + O( �m− 1
2 ))ˆµ(f t0, st0, νt0), as needed.
So, we just need to establish the claimed bound of O( CF �m
CA �T ) on total measure increase resulting
from this procedure. To this end, note that by Lemma 6.3 this increase is at most
(1 + ˆγ)
�
v̸=v∗
αvνt
e(v)
=
(1 + ˆγ)
�
v̸=v∗
|˜σv|
νt
f′e(v)
e(v)
≤ (1 + ˆγ)2 �
v̸=v∗
|˜σv|
s′
e(v)
ˆµ(f ′, s′, ν′)
=
O

 �
v̸=v∗
|˜σv|
ˆµ(f ′, s′, ν′)

 = O
� |ˆσ − ¯σ|1
ˆµ(f ′, s′, ν′)
�
,
where we used the Fact 5.3 and Invariant 6.4, as well as, we applied Lemma 6.5 to conclude that
each s′
e(v) is O(1).
Thus, in the light of the above, it only remains to bound |ˆσ − ¯σ|1.
Lemma 6.14. |ˆσ − ¯σ|1 = O( CF �mˆµ(f ′,s′,ν′)
CA �T
)
Proof. One can see that we can bound |ˆσ − ¯σ|1 by bounding the total (additive) change of the ﬂow
f t on all auxiliary arcs during the whole execution of ˆθ-improvement procedure. Furthermore, as
the ﬂow f t changes only during progress steps, and there is at most ˆθ−2 = �m2η of them, it suﬃces
to prove that in each progress step this change is at most O(CF ˆµ(f ′, s′, ν′) �m1−2η
CA �T )).
Now, by Theorem 5.5 and Lemma 6.12, this (additive) change at step t can be bounded as
�
e∈S
|¯κt
e|ft
e ≤ CF FA
�
e∈S
|¯κt
e| ≤ 4CF FA
��
e∈S
δtρ(ˆf
t, f t)e +
�
e∈S
ˆκt
e
�
,
(29)
where S is the set of auxiliary arcs. By Cauchy-Schwarz inequality, we get that
�
e∈S
ρ(ˆf
t, f t)e ≤
�
e∈S
νt
eρ(ˆf
t, f t)e ≤
�
∥ρ(ˆf
t, f t)∥2
νt,2νt(S) ≤ O( �m),
where we used (16) and the fact that by Lemma 6.12 νt(S) is O( �m). Similarly, we obtain that
�
e∈S
ˆκt
e ≤
�
e∈S
νt
eˆκt
e ≤
�
∥ˆκt∥2
νt,2νt(S) ≤ O(
√
�m),
35

where we used that fact that ∥ˆκt∥νt,2 ≤ 1
16.
Plugging the above to bounds back into (29) and recalling that we always set δt := (2Cδ ˆθ
√
�m)−1,
we obtain that
|ˆσ − ¯σ|1
≤
4CF FA
��
e∈S
δtρ(ˆf
t, f t)e +
�
e∈S
ˆκt
e
�
≤ O
�
CF FA
√
�m
Cδ ˆθ
�
≤
O
�CF ˆµ(f t0, st0, νt0) �m1−2η
CA �T
�
≤ O
�CF ˆµ(f ′, s′, ν′) �m1−2η
CA �T
�
,
where we utilized (28), as well as, the fact that, due to our stopping condition for ˆθ-improvement
phase, we can always assume that ˆµ(f t0, st0, νt0) is O(ˆµ(f ′, s′, ν′)). The lemma follows.
Clearly, by setting CA to be a suﬃciently large constant, we can ensure that the total measure
increase due to ﬁxing procedure will not lead to violation of Invariant 5.2.
ˆθ-smoothness on Light Arcs
As the ﬁnal step of our analysis, we prove now that in the course of our algorithm – after the
modiﬁcations described above – all the electrical ﬂows ˆf
t that we compute are indeed ˆθ-smooth on
the set of light arcs. That is, the assumption underlying the analysis performed in Section 6.1 is
indeed justiﬁed.
To this end, let us ﬁx some ˆσ-feasible and ˆγ-centered solution (f t, st, νt) in our augmented
graph ¯G and let ˆf
t be the associated electrical ˆσ-ﬂow. For convenience, we drop from now on all
the references to t in our notation.
Our proof will take advantage of the dual nature of electrical ﬂows. In particular, it will be
instrumental for us to consider the vertex potentials φ that induce the electrical ﬂow ˆf via (5). The
crucial property of these potentials is that they provide an embedding of all the vertices of ¯G into
a line. To make it precise, for a given arc e = (u, v), let us denote by φ−
e (resp. φ+
e ): the value of
φu (resp. φv), if φu ≤ φv; and the value of φv (resp. φu), otherwise. In other words, φ−
e (resp. φ+
e )
is the coordinate of the left-most (resp. right-most) endpoint of e in this line embedding.
Observe that by (5) and deﬁnition of resistances r (cf. (14)), we have that for a given arc
e = (u, v), the distance ∆e between the embeddings of its endpoints is
∆e := φ+
e − φ−
e = |φu − φv| = | ˆfe|re = µe| ˆfe|
f2e
= µeρ(ˆf , f )e
fe
,
and thus by Fact 5.3
(1 − ˆγ)ˆµ(f , s, ν)ρ(ˆf , f )e
fe
≤ ∆e
νe
≤ (1 + ˆγ)ˆµ(f , s, ν)ρ(ˆf , f )e
fe
.
(30)
Furthermore, for two subsets T, U ⊆ ¯V of vertices of ¯G, let us deﬁne the distance dist(T, U) between
these sets to be
dist(T, U) :=
min
v∈T,u∈U |φv − φu|.
(31)
Also, let us call two such subsets T ⊆ ¯V and U ⊆ ¯V , (∆, k)-separated, for some ∆ > 0 and integer
k ≥ 0, if dist(T, U) ≥ ∆ and min{a(T), a(U)} ≥ k, where a(U ′) := �
v∈U′ av and av is deﬁned in
(27).
36

Now, assume for the sake of contradiction that ˆf is not ˆθ-smooth on the set of light arcs, i.e.,
there exists an l∗ ≤ log ˆθ−3 such that
ν(Sl∗(ˆf ) \ Et
H) = ν(S∗) > ⌊ˆθ323l∗⌋,
(32)
where S∗ denotes Sl∗(ˆf ) \ Et
H with the set Sl∗(ˆf ) deﬁned by (17) and Et
H denotes the set of heavy
arcs. Our main goal is to show that in this case there exist two subsets T, U ⊆ ¯V of vertices that
are (∆∗, k∗)-separated with
∆∗ := CH �m3η
14 · 2l∗
and k∗ := 22l∗ �m1−6η(ˆµ(f , s, ν))2
CKF 2
A
,
(33)
where CH is the constant from Deﬁnition 6.7, FA is given by (28), and CK is a suﬃciently large
constant that does not depend on CH and will be set later.
To motivate this goal, we prove the following lemma.
Lemma 6.15. If there exist T, U ⊆ ¯V that are (∆∗, k∗)-separated then
Er(ˆf ) > CE �mˆµ(f , s, ν),
provided CH is chosen to be large enough.
Observe that the conclusion of this lemma violates the bound from Lemma 6.8.
Thus, the
resulting contradiction would allows us to conclude that ˆf indeed needs to be ˆθ-smooth on the set
of light arcs, as we wanted to prove.
Proof. Note that as dist(T, U) ≥ ∆∗, it must be the case that either dist({¯v}, U) ≥
∆∗
2
or
dist({¯v}, T) ≥ ∆∗
2 . (Recall that ¯v is the special vertex of ¯G that is adjacent to all the auxiliary
arcs.) Let us assume – without loss of generality – that the ﬁrst case holds.
Now, as min{a(T), a(U)} ≥ k∗, we know that, in particular, a(U) ≥ k∗. This, in turn, means
that at least k∗ of auxiliary arcs e must have ∆e ≥ ∆∗
2 . Furthermore, by Lemma 6.12, we know that
all but O( �m8η) of these arcs have measure 1. So, as k∗ is �Ω( �m1−6η), by ensuring that the constant
Cη in the deﬁnition of η ((19)) is big enough, we can conclude that the set ˆS of auxiliary arcs with
∆e ≥ ∆∗
2 and νe = 1 has size of at least k∗
2 .
So, by (30) and Lemma 6.12, we have that, for any such arc e in ˆS,
ρ(ˆf , f )e ≥
∆efe
(1 + ˆγ)νeˆµ(f , s, ν) ≥
∆eFA
(1 + ˆγ)CF ˆµ(f , s, ν) ≥
∆∗FA
4CF ˆµ(f , s, ν),
where we used the fact that ∆e ≥ ∆∗
2 and νe = 1, for all e in ˆS.
Now, the above inequality enables us to lowerbound the energy Er(ˆf ) of the ﬂow ˆf using sole
contribution of arcs in ˆS. We get that
Er(ˆf )
≥
�
e∈ ˆS
re ˆf2
e ≥
�
e∈ ˆS
(1 − ˆγ)ˆµ(f , s, ν)ρ(ˆf , f )2
e ≥ (1 − ˆγ)ˆµ(f , s, ν)| ˆS|
�
∆∗FA
4CF ˆµ(f , s, ν)
�2
≥
ˆµ(f , s, ν)k∗
�
∆∗FA
8CF ˆµ(f , s, ν)
�2
≥ Ω
�
ˆµ(f , s, ν) �m1−6η22l∗ � C2
H �m6η
C2
F CK22l∗
��
≥
Ω
�
ˆµ(f , s, ν) �m
� C2
H
C2
F CK
��
,
37

where we used the deﬁnition of r (14) and Fact 5.3.
So, once CH is chosen to be large enough constant – which we can always ensure to be the case
– the lemma follows. (Note that at this point the constant CF is ﬁxed already and we will make
sure that when we later set the constant CK, it does not depend on the value of CH.)
Finding the (∆∗, k∗)-separated Sets
In the light of the above, it remains to establish how condition (32) implies the existence of such
(∆∗, k∗)-separated sets T ∗ and U ∗. To this end, for a given x ∈ R, let us deﬁne V −
x (resp. V +
x ) to
be the set of vertices v with φv ≤ x (resp. φv ≥ x). Also, let Ex denote the set of arcs e of ¯G such
that φ−
e ≤ x ≤ φ+
e .
Now, let x∗ be the smallest x such that a(V −
x ) ≥ k∗. If a(Vx∗+∆∗) ≥ k∗ then taking T ∗ := V −
x∗
and U ∗ = V +
x∗+∆∗ will clearly constitute the (∆∗, k∗)-separated sets we are looking for.
So, we can focus on the case that a(Vx∗+∆∗) < k∗. Let us then take T ∗ := V +
x∗ ∩ V −
x∗+∆∗. Note
that, as 3k∗ is smaller than the number of all auxiliary arcs, we need to have a(T ∗) ≥ k∗. Next,
let us take U ∗ := V −
x∗−∆∗ ∪ V +
x∗+2∆∗. Clearly, dist(T ∗, U∗) ≥ ∆∗. Therefore, once we show that
a(U ∗) ≥ k∗, T ∗ and U ∗ will constitute the desired (∆∗, k∗)-separated sets.
We proceed now to showing that indeed a(U ∗) ≥ k∗. Let us deﬁne F(x) := �
e∈Ex fe (resp.
�F(x) := �
e∈Ex | ˆfe|) to be the total ﬂow of f (resp. ˆf ) ﬂowing through the arcs in Ex. We will be
interested in two quantities
A∗ :=
�
R\I∗ F(x)dx and
�A :=
�
R\I∗
�F(x)dx,
where I∗ is an interval [x∗ − ∆∗, x∗ + 2∆∗]. (Observe that if the interval I∗ was not excluded, �A
would be equal to the energy Er(ˆf ) of the ﬂow ˆf .)
Lowerbounding �A
First, we want to lowerbound �A. To this end, we note that by (30), for any
e ∈ S∗ (recall that S∗ := Sl∗(ˆf ) \ Et
H and thus, in particular, is contain only light arcs), we have
that
∆e
≥
(1 − ˆγ)ˆµ(f , s, ν)νe
ρ(ˆf , f )e
fe
≥ (1 − ˆγ)ˆµ(f , s, ν)ρ(ˆf , f )e
FH
≥
(1 − ˆγ)CH
ρ(ˆf , f )e
�m
1
2 −3η ≥ (1 − ˆγ)CH
�m3η
2l∗+1 ≥ 6∆∗,
where we also used (17), (33), and Deﬁnition 6.7.
As the interval I∗ has length 3∆∗, this means that for any arc e ∈ S∗, the interval [φ−
e , φ+
e ] \ I∗
has length of at least
∆e − 3∆∗ ≥ ∆e
2 .
This, in turn, implies that even if we account for contributions of the arcs from S∗ only, we have
38

that
�A
=
�
R\I∗
�F(x)dx ≥ 1
2
�
e∈S∗
∆e| ˆfe| ≥ (1 − ˆγ)ˆµ(f , s, ν)
2
�
e∈S∗
ρ(ˆf , f )eνe| ˆfe|
fe
≥
(1 − ˆγ)ˆµ(f , s, ν)
2
�
e∈S∗
ρ(ˆf , f )2
eνe ≥ ˆµ(f , s, ν)
5
�
e∈S∗
νe �m
22l∗
(34)
=
ˆµ(f , s, ν)
5 · 22l∗
ν(S∗) �m ≥ ˆµ(f , s, ν)
5
ˆθ32l∗ �m = ˆµ(f , s, ν)
5
2l∗ �m1−3η,
where we used (17), (30), and (32).
Upperbounding A∗
Now, we want to upperbound the value of A∗. To do that, let us deﬁne ¯S
to be the set of arcs that have at least one endpoint outside of the interval I∗. Note that by our
way of setting up the auxiliary arcs and the fact that by Lemma 6.12 and (25), the total increase
of measure of arcs during the ˆθ-improvement phase is �O( �m8η), we have that
a(U ∗) ≥ ν( ¯S)
3
− �O( �m8η).
(35)
So, if we are able to show that ν( ¯S) ≥ 4k∗ = �Ω( �m1−6η) and ensure again that the constant Cη in
deﬁnition of η (19) is large enough, we will prove that a(U ∗) ≥ k∗, as desired.
To establish such lowerbound on ν( ¯S), we use (30) and observe that
A∗ =
�
R\I∗ F(x)dx ≤
�
e∈ ¯S
∆efe ≤ (1 + ˆγ)ˆµ(f , s, ν)
�
e∈ ¯S
νeρ(ˆf , f )e,
where we noted that the only arcs that can contribute to A∗ are all in the set ¯S. Therefore, by Fact
5.3 and Cauchy-Schwarz inequality, we have that
(1 + ˆγ)ˆµ(f , s, ν)
�
e∈ ¯S
νeρ(ˆf , f )e ≤ (1 + ˆγ)ˆµ(f , s, ν)
�
(
�
e∈ ¯S
νeρ(ˆf , f )2e)ν( ¯S).
So, putting the above two bounds together, we get that
A∗ ≤ (1 + ˆγ)ˆµ(f , s, ν)
�
e∈ ¯S
νeρ(ˆf , f )e ≤ 5ˆµ(f , s, ν)
�
�mν( ¯S),
(36)
where we also used (16) and Lemma 5.7.
At this point, our last needed observation is captured by the following lemma.
Lemma 6.16. For any x ∈ R, we have that F(x) ≥ �F(x).
Notice that once the above lemma is established, we have that
A∗ =
�
R\I∗ F(x)dx ≥
�
R\I∗
�F(x)dx = �A,
39

and, as a result, we can put (34) and (36) together to obtain
ν( ¯S)
≥
1
�m
�
A∗
5ˆµ(f , s, ν)
�2
≥ 1
�m
�
�A
5ˆµ(f , s, ν)
�2
≥ 1
�m
�2l∗ �m1−3η
25
�2
≥
Ω(22l∗ �m1−6η) ≥ 4k∗,
once the constant CK in the deﬁnition (33) of k∗ is taken to be large enough. (Note that the term
ˆµ(f ,s,ν)
FA
in the deﬁnition of k∗ (33) is bounded by a constant that is independent of CH. So, indeed
CK does not depend on CH, as we wanted to ensure.)
Therefore, by (35), the above bounds shows that indeed a(U ∗) ≥ k∗, as needed.
At this point, we just need to perform the remaining proof of the lemma and the analysis of our
improved algorithm will be concluded.
Proof. The simple, but fundamental, observation we need to make here is that the ﬂow ˆf – being
an electrical ˆσ-ﬂow induced by vertex potentials φ via relationship (5) – is always ﬂowing in one
direction, i.e., from left to right, with respect to the line embedding given by φ. This, together with
the fact that ˆf is a ˆσ-ﬂow, implies that
�
v∈V +
x
ˆσv = �F(x).
On the other hand, f is also a feasible ˆσ-ﬂow, which means that the net inﬂow into V +
x
of f
has to be at least �
v∈V +
x ˆσv. This gives us that
F(x) ≥
�
v∈V +
x
ˆσv = �F(x),
as we wanted to establish.
7
Electrical Flows and the Central Path
In this section, we describe how we can use electrical ﬂows to advance our solution along the central
path. In other words, we describe and analyze the implementation of the improvement step and
thus prove Theorem 5.5. This implementation is directly inspired by – and, in fact, can be seen as
a reinterpretation of – the improvement steps used in path-following method.
Recall that in the improvement step, we are given a ˆγ-centered ˆσ-feasible solution (f t, st, νt)
and our goal is to compute, in �O( �m) time, a ˆγ-centered ˆσ-feasible solution (f t+1, st+1, νt+1) with
ˆµ(f t+1, st+1, νt+1) ≤ (1 − δt)ˆµ(f t, st, νt).
(37)
We perform this improvement in two main steps. The ﬁrst one – the descent step – uses the
electrical ﬂow ˆf
t associated with (f t, st, νt) and the corresponding vertex potentials �φt that induce
it, to perform a primal and dual update that results in a new, intermediate, solution (¯f t, ¯st, ¯νt).
This intermediate solution is ˆσ-feasible and has ˆµ(¯f t, ¯st, ¯νt) ≤ (1 − δt)ˆµ(f t, st, νt) as desired, but
it might be not ˆγ-centered anymore. To ﬁx that, in the second – centering – step, we compute the
desired solution (f t+1, st+1, νt+1) out of (¯f t, ¯st, ¯νt) by using another electrical ﬂow computation
that again provides a primal and dual update.
We describe and analyze both of these steps below. Note that as each of these two steps requires
only one computation of electrical ﬂow, it can be easily implemented to run in �O( �m) time, as needed.
40

Descent Step
Let ˆf
t be the electrical ˆσ-ﬂow associated with the solution (f t, st, νt) and let �φ
t
be the vertex potentials that induce ˆf
t. Consider a new primal-dual solution (¯f t, ¯st, ¯νt) given by
¯ft
e
:=
(1 − δt)ft
e + δt ˆft
e
(38)
¯st
e
:=
st
e −
δt
(1 − δt)(�φt
u − �φt
v) = st
e − δt
st
e
(1 − δt)fte
ˆft
e
(39)
¯νt
e
:=
νt
e,
(40)
for each arc e = (v, u) in �G, where δt satisﬁes conditions of the theorem and we also used the
deﬁnition (14) of the resistances that determine ˆf
t, as well as, the relationship (5) between electrical
ﬂow and the vertex potentials that induce it.
Observe that as ¯f t is a convex combination of two ˆσ-ﬂows – the ﬂows f t and ˆf
t – it also is an
ˆσ-ﬂow. Furthermore, as all νt
e ≥ 1, we have ∥ρ(ˆf
t, f t)∥νt,4 ≥ ∥ρ(ˆf
t, f t)∥∞ and thus, for each arc e,
¯ft
e = (1 − δt)ft
e + δt ˆft
e ≥ (1 − δt)ft
e − δt| ˆft
e| = (1 − δt − δtρ(ˆf
t, f t)e)ft
e ≥ (1 − 1
2 −
�
ˆγ)ft
e > 0, (41)
and similarly
¯st
e = st
e − δt
st
e
(1 − δt)fte
ˆft
e ≥ st
e − δt
st
e
(1 − δt)fte
| ˆft
e| = st
e − δt
st
e
(1 − δt)ρ(ˆf
t, f t)e ≥ (1 − 2
�
ˆγ)st
e > 0.
So, (¯f t, ¯st, ¯νt) is ˆσ-feasible, as desired.
Let us now analyze the value of ˆµ(¯f t, ¯st, ¯νt). To this end, observe that, for any arc e,
ˆ¯µt
e =
¯ft
e¯st
e
¯νte
=
(νt
e)−1((1 − δt)ft
e + δt ˆft
e)(st
e − δt
st
e
(1 − δt)fte
ˆft
e)
=
(νt
e)−1
�
(1 − δt)ft
est
e + δt ˆft
est
e − δt
st
e
(1 − δt)fte
ˆft
e(1 − δt)ft
e − (δt)2
st
e
(1 − δt)fte
( ˆft
e)2
�
=
(νt
e)−1
�
(1 − δt)µt
e + δt ˆft
est
e − δt ˆft
est
e − (δt)2
st
e
(1 − δt)ft
eρ(ˆf
t, f t)2
e
�
(42)
=
�
1 − δt − (δtρ(ˆf
t, f t)e)2
(1 − δt)
�
ˆµt
e.
So, by deﬁnition (10) and the fact that (δtρ(ˆf
t,f t)e)2
(1−δt)
≥ 0 for all e, we see that
ˆµ(¯f t, ¯st, ¯νt) ≤ (1 − δt)ˆµ(f t, st, νt)
and this inequality would be an equality if the second-order terms (i.e., terms quadratic in δt) were
ignored. (Also, if these terms were not present, the centrality of the solution would be preserved
too.)
41

Finally, let us focus on analyzing the centrality of (¯f t, ¯st, ¯νt). To this end, note that by deﬁnition
(11) and by (42) above we have
∥ˆ¯µt − ˆµ(¯f t, ¯st, ¯νt)1∥2
¯νt,2
≤
∥ˆ¯µt − (1 − δt)ˆµ(f t, st, νt)1∥2
¯νt,2 ≤
�
e
¯νt
e(ˆ¯µt
e − (1 − δt)ˆµ(f t, st, νt))2
=
�
e
νt
e
�
(1 − δt)(ˆµt
e − ˆµ(f t, st, νt)) − (δtρ(ˆf
t, f t)e)2
(1 − δt)
ˆµt
e
�2
≤
2
�
(1 − δt)2 �
e
νt
e(ˆµt
e − ˆµ(f t, st, νt))2 +
�
e
νt
e
(δtρ(ˆf
t, f t)e)4
(1 − δt)2
(ˆµt
e)2
�
(43)
≤
2
�
(1 − δt)2∥ˆµt − ˆµ(f t, st, νt)1∥2
νt,2 + (1 + ˆγ)2ˆµ(f t, st, νt)2
(1 − δt)2
(δt)4 �
e
νt
eρ(ˆf
t, f t)4
e
�
≤
2
�
(1 − δt)2ˆγ2ˆµ(f t, st, νt)2 + (1 + ˆγ)2ˆµ(f t, st, νt)2
(1 − δt)2
(δt)4 �
e
νt
eρ(ˆf
t, f t)4
e
�
≤
2
�
(1 − δt)2ˆγ2 + (1 + ˆγ)2
(1 − δt)2 (δt)4∥ρ(ˆf
t, f t)∥4
νt,4
�
ˆµ(f t, st, νt)2
≤
10ˆγ2ˆµ(¯f t, ¯st, ¯νt)2.
In the above derivation, the ﬁrst inequality follows as the ∥µ−t1∥ν,2 is always minimized by taking
t = ˆµ(f , s, ν). We also used the fact that (f t, st, νt) is ˆγ-centered, Fact 5.3 and the upperbound
on δt.
Therefore, we see that the price of making progress on the duality gap is that the centrality of
our solution could deteriorate by a factor of at most three.
Centering Step
To alleviate this possible increase of centrality, we apply a second step that
restores the centrality back within the desired bounds while not increasing the duality gap (so to
not to counter the progress on the duality gap that we just achieved).
To this end, consider a ﬂow ¯f ∗ in �G deﬁned as
¯f∗
e :=
ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte
¯ft
e,
(44)
for every arc e of �G. Note that the ﬂow ¯f ∗ might (and actually will) not be feasible in �G, as some
of ¯f∗
e can be negative.
Now, consider a ﬂow ¯f ′ given by
¯f′
e := ¯ft
e − ¯f∗
e = (1 −
ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte
) ¯ft
e = ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte
¯ft
e,
(45)
for each arc e. Observe that ¯f ′ is feasible in �G (i.e., ¯f′
e ≥ 0, for all e) and
¯f′
e¯st
e
¯νte
= ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte¯νte
¯ft
e¯st
e = ˆµ(¯f t, ¯st, ¯νt),
(46)
for each arc e. That is, (¯f ′, ¯st, ¯νt) is 0-centered with ˆµ(¯f ′, ¯st, ¯νt) = ˆµ(¯f t, ¯st, ¯νt).
42

So, this solution would be a perfect candidate for (f t+1, st+1, νt+1) except that the ﬂow ¯f ′ does
not need to be a ˆσ-ﬂow and thus this solution might not be ˆσ-feasible.
To ﬁx that – and obtain our desired solution (f t+1, st+1, νt+1) – let ˜σ be the demand vector of
the ﬂow ¯f ∗, and consider an electrical ˜σ-ﬂow ˜f
t that corresponds to resistances
˜rt
e := ¯st
¯f′ee
,
(47)
for each arc e and let ˜φ be the corresponding vertex potentials.
Let us deﬁne (f t+1, st+1, νt+1) to be
ft+1
e
:=
¯f′
e + ˜ft
e
st+1
e
:=
¯st
e − (�φt
u − �φt
v) = ¯st
e − ¯st
¯f′ee
˜ft
e
(48)
νt+1
e
:=
¯νt
e,
for each arc e = (v, u).
Clearly, now f t+1 is a ˆσ-ﬂow, as desired. Let us analyze its centrality. To this end, let us ﬁx
some arc e, and notice that
ˆµt+1
e
=
ft+1
e
st+1
e
νt+1
e
=
( ¯f′
e + ˜ft
e)(¯st
e − ¯st
e¯f′e
˜ft
e)
νt+1
e
=
(¯νt
e)−1
�
¯f′
e¯st
e + ¯st
e ˜ft
e − ¯st
e ˜ft
e − ¯st
¯f′ee
( ˜ft
e)2
�
=
ˆµ(¯f t, ¯st, ¯νt) −
¯st
e
¯νte ¯f′e
( ˜ft
e)2,
where we used (46). So, we see in particular that
ˆµ(f t+1, st+1, νt+1) ≤ ˆµ(¯f t, ¯st, ¯νt) ≤ (1 − δt)ˆµ(f t, st, νt),
as needed.
Now, by our derivation above, we have that
∥ˆµt+1 − ˆµ(f t+1, st+1, νt+1)1∥2
νt+1,2 ≤ ∥ˆµt+1 − ˆµ(¯f t, st, ¯νt)1∥2
νt+1,2 =
�
e
¯νt
e
� ¯st
e
¯νte ¯f′e
( ˜ft
e)2
�2
.
To bound the resulting expression, let us note that by Cauchy-Schwarz inequality and the fact
that measures are always at least 1 we have
�
e
¯νt
e
� ¯st
e
¯νte ¯f′e
( ˜ft
e)2
�2
≤
�
max
e
¯st
e
¯νte ¯f′e
( ˜ft
e)2
� ��
e
¯st
¯f′ee
( ˜ft
e)2
�
≤
��
e
¯st
¯f′ee
( ˜ft
e)2
�2
.
Now, the key insight here is that by (47),
��
e
¯st
¯f′ee
( ˜ft
e)2
�2
=
�
E˜rt(˜f
t)
�2
.
43

So, by bounding the energy of the electrical ﬂow ˜ft
e we will be able to bound the centrality of our
solution ˆµ(f t+1, st+1, νt+1). To bound this energy, we will ﬁrst bound the energy E˜rt(¯f ∗) of the
ﬂow ¯f ∗ and use the fact that both ¯f ∗ and ˜f
t are ˜σ-ﬂows and thus, by deﬁnition, ˜f
t is minimizing
the energy among all the ˜σ-ﬂows.
Observe that by deﬁnition (44) of the ﬂow ¯f ∗, the fact that (¯f t, ¯st, ¯νt) is 3ˆγ-centered – cf. (43)
– and Fact 5.3, we have that
E˜rt(¯f ∗)
=
�
e
¯st
e
¯f′e
�
ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte
¯ft
e
�2
≤
�
e
¯νt
eˆ¯µt
e
¯f′e
(ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt))2 ¯ft
e
(1 − 3ˆγ)ˆ¯µteˆµ(¯f t, ¯st, ¯νt)
≤
1
(1 − 3ˆγ)
�
e
¯νt
e
(ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt))2 ¯ft
e
ˆµ(¯f t, ¯st, ¯νt) ¯f′e
=
1
(1 − 3ˆγ)
�
e
¯νt
e
(ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt))2ˆ¯µt
e
ˆµ(¯f t, ¯st, ¯νt)2
≤
(1 + 3ˆγ)
(1 − 3ˆγ)
�
e
¯νt
e
(ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt))2
ˆµ(¯f t, ¯st, ¯νt)
= (1 + 3ˆγ)
(1 − 3ˆγ)
∥ˆ¯µt − ˆµ(¯f t, ¯st, ¯νt)1∥2
¯νt,2
ˆµ(¯f t, ¯st, ¯νt)
(49)
≤
(1 + 3ˆγ)
(1 − 3ˆγ)9ˆγ2ˆµ(¯f t, ¯st, ¯νt) ≤ 10ˆγ2ˆµ(¯f t, ¯st, ¯νt) ≤ 20ˆγ2ˆµ(f t+1, st+1, νt+1),
where we also used the deﬁnition (45) of the ﬂow ¯f ′.
In the light of the above discussion, we can conclude that
∥ˆµt+1 − ˆµ(f t+1, st+1, νt+1)1∥2
νt+1,2
≤
�
e
¯νt
e
� ¯st
e
¯νte ¯f′e
( ˜ft
e)2
�2
≤
��
e
¯st
¯f′ee
( ˜ft
e)2
�2
≤
�
20ˆγ2ˆµ(f t+1, st+1, νt+1)
�2 ≤ ˆγ2ˆµ(f t+1, st+1, νt+1)2,
as ˆγ ≤ 1
20. So, indeed (f t+1, st+1, νt+1) is ˆγ-centered.
Now, to prove that (f t+1, st+1, νt+1) is also ˆσ-feasible, we just need to show that for any arc e,
ρ(˜f
t,¯f ′)e = | ˜ft
¯f′ee|
≤ 1
2.
To this end, note that by (46) and (49) we have
νt
eˆµ(¯f t, ¯st, ¯νt)ρ(˜f
t,¯f ′)2
e = ¯st
e ¯f′
e
( ¯f′e)2 ( ˜ft
e)2 = ¯st
¯f′ee
( ˜ft
e)2 ≤ E˜rt(˜f
t) ≤ E˜rt(¯f ∗) ≤ 10ˆγ2ˆµ(¯f t, ¯st, ¯νt) ≤
1
1600 ˆµ(¯f t, ¯st, ¯νt).
(50)
Thus, indeed, we can conclude that we obtained a ˆγ-centered ˆσ-feasible solution (f t+1, st+1, νt+1)
with ˆµ(f t+1, st+1, νt+1) ≤ (1 − δt)ˆµ(f t, st, νt), as desired.
This concludes the proof of the ﬁrst part of the Theorem 5.5. The proof of the second part
appears in Appendix F.
8
Rounding Fractional Bipartite b-Matchings
In this section, we show how given a fractional b-matching x in some bipartite graph G = (P ∪Q, E)
with m = |E| edges, one can ﬁnd in �O(m) time an integral b-matching x ∗ in G whose size is at
least ⌊|x|1⌋. In other words, we prove Theorem 3.3.
44

Rounding Perfect Matchings
Let us ﬁrst consider the case when x is just a fractional perfect matching, i.e., bv = 1 for all vertices
and the size |x|1 of x is |b|1
2 , i.e., the fractional degree of each vertex in x is 1. We claim that in
this case we can just use Theorem 2.4 to obtain an integral perfect matching in �O(m) time.
To see why this is the case, consider a |P| × |Q| matrix M x in which rows and columns are
indexed by vertices from P and Q, respectively, and the entries are given by Mx
p,q := x(p,q) if the
edge (p, q) exists in G; and 0, otherwise. Observe that if x is perfect and all bv are equal to 1
then we need to have |P| = |Q|. Thus, M x is a square matrix. Furthermore, M x needs to be
also doubly-stochastic, as for any row indexed by vertex p ∈ P (resp. column indexed by vertex
q ∈ Q), the sum �
q′∈Q Mx
p,q′ (resp. �
p′∈P Mx
p′,q) of the entries in this row (resp. column) is equal
to �
e∈E(p) xe = bp = 1 (resp. �
e∈E(q) xe = bq = 1). So, invoking Theorem 2.4, we can obtain in
�O(m) time an integral matching x ∗ in the support of M x that is also the support of the edge set
E of our graph G.
Rounding Non-Perfect Matchings
Now, to recover the desired integral matching in the case when x is not necessarily perfect (but still
all bv are equal to 1), our ﬁrst step is to extend x to a perfect matching ¯x in a certain augmented
graph ¯G that is created from G by adding some dummy edges and vertices to it.
More precisely, let dP (resp. dQ) be the total deﬁcits of vertices in P (resp. in Q), i.e.,
dP := |P| −
�
e∈E(p),p∈P
xe
and
dQ := |Q| −
�
e∈E(q),q∈Q
xe.
Note that the size |x|1 of x has to be exactly |P| − dP = |Q| − dQ. We add to the vertex set Q,
⌈dP ⌉ (resp. to the vertex set P, ⌈dQ⌉) dummy vertices ¯q1, . . . , ¯q⌈dP ⌉ (resp. ¯p1, . . . , ¯p⌈dQ⌉). Next, we
extend the fractional matching x to ¯x by going over each non-dummy vertex p ∈ P (resp. q ∈ Q)
and fractionally matching it to the dummy vertices ¯q1, . . . , ¯q⌈dP ⌉ (resp. ¯p1, . . . , ¯p⌈dQ⌉), so to ensure
that its fractional degree becomes 1 and the fractional degree of dummy vertices never exceeds one.
It is not hard to see that by employing a simple greedy approach we can achieve this goal in �O(m)
time and, furthermore, ensure that: (1) each non-dummy vertex is matched to at most two dummy
vertices in ¯x; (2) at the end, there are at most two dummy vertices, say, ¯p⌈dQ⌉ and ¯q⌈dP ⌉, (one on
each side of the bipartition) that are yet not fully matched in ¯x. To alleviate the latter problem,
we just match these two dummy vertices to each other (one can check that their deﬁcits have to be
equal) and take the set of edges ¯E of our augmented graph ¯G to be the support of the matching ¯x.
(Note that by property (1), the size of this support will be still O(m).)
Clearly, ¯x is a perfect matching in ¯G, so we can use the �O(m)-time procedure we described
above to get an integral perfect matching ¯x ∗ in that graph. Once we do that, we take our desired
integral matching x ∗ in G to be ¯x ∗ after we removed from it all the edges of ¯x ∗ that are not in G,
i.e., all the edges that are incident to dummy vertices. Obviously, x ∗ is a feasible matching in G
and it is integral. To see that its size is at least ⌊|x|1⌋, note that, as there is at most ⌈dP ⌉ + ⌈dQ⌉
dummy vertices in ¯G, there could be at most that many edges incident to these vertices in ¯x ∗. But,
as ¯x ∗ is perfect, its size is equal to
|P| + ⌈dP ⌉ + |Q| + ⌈dQ⌉
2
= |P| − ⌈dP ⌉ + |Q| − ⌈dQ⌉
2
+ ⌈dP ⌉ + ⌈dQ⌉ = ⌊|x|1⌋ + ⌈dP ⌉ + ⌈dQ⌉,
45

where we used the fact that |P| − dP = |Q| − dQ = |x|1. Thus, indeed after removing at most
⌈dP ⌉ + ⌈dQ⌉ edges from ¯x ∗, the resulting integral matching x ∗ will have its size |x ∗|1 to be at least
⌊|x|1⌋, as desired.
Rounding b-Matchings
In the light of the above, it remains to show how to deal with the case when in the demand vector
b there are some bv that are bigger than 1 (and thus some of the entries of x could be bigger than
1, as well). To this end, let us observe ﬁrst that if there is an edge e = (p, q) with xe ≥ 1, we can
just subtract ⌊xe⌋ copies of this edge from our matching right away, while decreasing the demands
bp and bq of e’s endpoints accordingly, i.e., by ⌊xe⌋. (Note that by feasibility of x, bp, bq ≥ ⌊xe⌋.)
So, one can see that if ¯x is the fractional matching x after we made such transformation and ¯b are
the corresponding demands, then once we compute an integral ¯b-matching ¯x ∗ of size at least ⌊|¯x|1⌋
from ¯x, we can just add back these subtracted ⌊xe⌋ copies of edge e to ¯x ∗ to obtain the desired
integral b-matching x ∗ of size at least ⌊|¯x|1⌋ + ⌊xe⌋ = ⌊|x|1⌋.
Therefore, we can assume from now on that in our b-marching x all xes are smaller than one (but
still we can have some demands bv to be bigger than one). To round such fractional b-matchings,
for each vertex v ∈ V that has its demand bv bigger than 1, we split it into bv vertices v1, . . . , vbv –
each with demand one. Next, for every edge e that was previously incident to v, we connect it to
the new vertices and distribute its fractional weight xe in x among these new vertices. Again, by
applying a simple greedy approach we can ensure that each edge is connected to at most two among
the vertices v1, . . . , vbv and none of these vertices has its fractional degree bigger than 1. (Note
that this means, in particular, that once we apply such splitting to all vertices with bv > 1 then the
support of the corresponding “split” fractional matching is at most by a factor of four larger than
the support of x.) Clearly, at this point, we are again in situation where we just need to round a
fractional bipartite matching (with all demands being at most 1). Thus, we can use our rounding
procedure we described above and recover the integral matching we are seeking. This ﬁnishes the
proof of Theorem 3.3.
Acknowledgments. We are grateful to Andrew Goldberg, Jonathan Kelner, Lap Chi Lau, Gary
Miller, Richard Peng, Seth Pettie, Daniel Spielman, and Shang-Hua Teng for a number of helpful
discussions on this topic. We also thank Monika Henziger, Satish Rao, and Jens Vygen for useful
feedback on the manuscript.
References
[ABMP91] H. Alt, N. Blum, K. Mehlhorn, and M. Paul. Computing a maximum cardinality match-
ing in a bipartite graph in time O(n1.5�
m/ log n). Inf. Process. Lett., 37(4):237–240,
1991.
[AHK12]
S. Arora, E. Hazan, and S. Kale. The multiplicative weights update method: a meta-
algorithm and applications. Theory of Computing, 8(1):121–164, 2012.
[AHU74]
A. V. Aho, J. E. Hopcroft, and J. D. Ullman. The Design and Analysis of Computer
Algorithms. Addison-Wesley Longman Publishing Co., Boston, MA, USA, 1st edition,
1974.
46

[AMO93]
R. K. Ahuja, T. L. Magnanti, and J. B. Orlin. Network ﬂows: theory, algorithms, and
applications. Prentice-Hall, 1993.
[AMOR95] R. K. Ahuja, T. L. Magnanti, J. B. Orlin, and M. R. Reddy. Applications of Network
Optimization, volume 7 of Handbooks in Operations Research and Management Science.
North-Holland, 1995.
[BH74]
J. R. Bunch and J. E. Hopcroft. Triangular factorization and inversion by fast matrix
multiplication. Mathematics of Computation, 28(125):231–236, 1974.
[Bol98]
B. Bollobas. Modern Graph Theory. Springer, 1998.
[BV04]
S. Boyd and L. Vandenberghe. Convex Optimization. Cambridge University Press, 2004.
[CKM+11] P. Christiano, J. Kelner, A. Mądry, D. Spielman, and S.-H. Teng.
Electrical ﬂows,
Laplacian systems, and faster approximation of maximum ﬂow in undirected graphs. In
STOC’11: Proceedings of the 43rd Annual ACM Symposium on Theory of Computing,
pages 273–281, 2011.
[CLRS09]
T. H. Cormen, C. E. Leiserson, R. L. Rivest, and C. Stein. Introduction to Algorithms.
The MIT Press, 3rd edition, 2009.
[CW90]
D. Coppersmith and S. Winograd. Matrix multiplication via arithmetic progressions.
Journal of Symbolic Computation, 9:251–280, 1990.
[DS08]
S. I. Daitch and D. A. Spielman. Faster approximate lossy generalized ﬂow via interior
point algorithms. In STOC’08: Proceedings of the 40th Annual ACM Symposium on
Theory of Computing, pages 451–460, 2008.
[Edm65]
J. Edmonds. Paths, trees, and ﬂowers. Canadian Journal of Mathematics, 17:449–467,
1965.
[EFS56]
P. Elias, A. Feinstein, and C. E. Shannon. A note on the maximum ﬂow through a
network. IRE Transactions on Information Theory, 2, 1956.
[Ege31]
J. Egerváry. Matrixok kombinatorius tulajdonságairól. Matematikai és Fizikai Lapok,
38:16–28, 1931.
[ET75]
S. Even and R. E. Tarjan. Network ﬂow and testing graph connectivity. SIAM Journal
on Computing, 4(4):507–518, 1975.
[FF56]
L. R. Ford and D. R. Fulkerson. Maximal ﬂow through a network. Canadian Journal
of Mathematics, 8:399–404, 1956.
[FM95]
T. Feder and R. Motwani. Clique partitions, graph compression and speeding-up algo-
rithms. Journal of Computer and System Sciences, 51(2):261Ű–272, 1995.
[GK04]
A. V. Goldberg and A. V. Karzanov. Maximum skew-symmetric ﬂows and matchings.
Mathematical Programming, 100(3):537–568, 2004.
47

[GKK10]
A. Goel, M. Kapralov, and S. Khanna. Perfect matchings in O(n log n) time in regular
bipartite graphs. In STOC’10: Proceedings of the 42nd Annual ACM Symposium on
Theory of Computing, pages 39–46, 2010.
[GR98]
A. V. Goldberg and S. Rao. Beyond the ﬂow decomposition barrier. Journal of the
ACM, 45(5):783–797, 1998.
[GT91]
H. N. Gabow and R. E. Tarjan. Faster scaling algorithms for general graph matching
problems. Journal of the ACM, 38(4):815–853, 1991.
[Har09]
N. J. A. Harvey.
Algebraic algorithms for matching and matroid problems.
SIAM
Journal on Computing, 39(2):679–702, 2009.
[HK73]
J. Hopcroft and R. Karp. An n5/2 algorithm for maximum matchings in bipartite graphs.
SIAM Journal on Computing, 2(4):225–231, 1973.
[Hof60]
A. J. Hoﬀman. Some recent applications of the theory of linear inequalities to extremal
combinatorial analysis. In Proceedings of Symposia in Applied Mathematics, volume 10,
pages 113–127, 1960.
[Kar73]
A. V. Karzanov. O nakhozhdenii maksimal’nogo potoka v setyakh spetsial’nogo vida i
nekotorykh prilozheniyakh. Matematicheskie Voprosy Upravleniya Proizvodstvom, 5:81–
94, 1973. (in Russian; title translation: On ﬁnding maximum ﬂows in networks with
special structure and some applications).
[KKL13]
S. Khanna, T. C. Kwok, and L. C. Lau, 2013. Personal communication.
[KLOS13]
J. A. Kelner, Y. T. Lee, L. Orecchia, and A. Sidford. An almost-linear-time algorithm
for approximate max ﬂow in undirected graphs, and its multicommodity generalizations.
2013.
[KMP10]
I. Koutis, G. L. Miller, and R. Peng.
Approaching optimality for solving SDD sys-
tems. In FOCS’10: Proceedings of the 51st Annual IEEE Symposium on Foundations
of Computer Science, pages 235–244, 2010.
[KMP11]
I. Koutis, G. L. Miller, and R. Peng.
A nearly m log n-time solver for SDD linear
systems. In FOCS’11: Proceedings of the 52nd Annual IEEE Symposium on Foundations
of Computer Science, pages 590–598, 2011.
[Kön31]
D. König. Graphok és matrixok. Matematikai és Fizikai Lapok, 38:116–119, 1931.
[KOSZ13]
J. A. Kelner, L. Orecchia, A. Sidford, and Z. A. Zhu. A simple, combinatorial algorithm
for solving SDD systems in nearly-linear time. In STOC’13: Proceedings of the 45th
Annual ACM Symposium on the Theory of Computing, pages 911–920, 2013.
[KRT94]
V. King, S. Rao, and R. Tarjan. A faster deterministic maximum ﬂow algorithm. Journal
of Algorithms, 17(3):447–474, 1994.
[Lau13]
L. C. Lau, 2013. Personal communication.
48

[Lov79]
L. Lovász. On determinants, matchings and random algorithms. Fundamentals of Com-
putation Theory, 565–574, 1979.
[LP86]
L. Lovász and D. M. Plummer. Matching Theory. Elsevier Science, 1986.
[LRS13]
Y. T. Lee, S. Rao, and N. Srivastava. A new approach to computing maximum ﬂows
using electrical ﬂows. In STOC’13: Proceedings of the 45th Annual ACM Symposium
on the Theory of Computing, pages 755–764, 2013.
[Mąd10]
A. Mądry. Fast approximation algorithms for cut-based problems in undirected graphs.
In FOCS’10: Proceedings of the 51st Annual IEEE Symposium on Foundations of Com-
puter Science, pages 245–254, 2010.
[Mąd11]
A. Mądry. From Graphs to Matrices, and Back: New Techniques for Graph Algorithms.
PhD thesis, Massachusetts Institute of Technology, 2011.
[MS04]
M. Mucha and P. Sankowski.
Maximum matchings via Gaussian elimination.
In
FOCS’04: Proceedings of the 45th Annual IEEE Symposium on Foundations of Com-
puter Science, pages 248–255, 2004.
[Muc05]
M. Mucha. Finding maximum matchings via Gaussian elimination. PhD thesis, Uni-
versity of Warsaw, 2005.
[MV80]
S. Micali and V. V. Vazirani. An O(
�
|V |·|E|) algoithm for ﬁnding maximum matching
in general graphs. In FOCS’80: Proceedings of the 21st Annual IEEE Symposium on
Foundations of Computer Science, pages 17–27, 1980.
[Orl13]
J. B. Orlin. Max ﬂows in o(nm) time, or better. In STOC’13: Proceedings of the 45th
Annual ACM Symposium on the Theory of Computing, pages 765–774, 2013.
[RV89]
M. O. Rabin and V. V. Vazirani. Maximum matchings in general graphs through ran-
domization. J. Algorithms, 10(4):557–567, December 1989.
[Sch03]
A. Schrijver. Combinatorial Optimization: Polyhedra and Eﬃciency. Springer, 2003.
[She09]
J. Sherman. Breaking the multicommodity ﬂow barrier for O(√log n)-approximations
to sparsest cuts. In FOCS’09: Proceedings of the 50th Annual IEEE Symposium on
Foundations of Computer Science, pages 363–372, 2009.
[She13]
J. Sherman. Nearly maximum ﬂows in nearly linear time. In FOCS’13: Proceedings of
the 54th Annual IEEE Symposium on Foundations of Computer Science, 2013.
[ST03]
D. A. Spielman and S.-H. Teng. Solving sparse, symmetric, diagonally-dominant linear
systems in time O(m1.31). In FOCS’03: Proceedings of the 44th Annual IEEE Sympo-
sium on Foundations of Computer Science, 2003.
[ST04]
D. A. Spielman and S.-H. Teng. Nearly-linear time algorithms for graph partitioning,
graph sparsiﬁcation, and solving linear systems. In STOC’04: Proceedings of the 36th
Annual ACM Symposium on the Theory of Computing, pages 81–90, 2004.
49

[Tut47]
W. T. Tutte. The factorization of linear graphs. Journal of the London Mathematical
Society, 22:107–111, 1947.
[Vaz94]
V. V. Vazirani. A theory of alternating paths and blossoms for proving correctness of the
O(
�
|V ||E|) general graph matching algorithms. Combinatorica, 14 (1):71–109, 1994.
[VW12]
V. Vassilevska Williams. Multiplying matrices faster than Coppersmith-Winograd. In
STOC’12: Proceedings of the 44th Annual ACM Symposium on the Theory of Comput-
ing, 2012.
[Wri97]
S. J. Wright. Primal-Dual Interior-Point Methods. Society for Industrial and Applied
Mathematics, 1997.
[Ye97]
Y. Ye. Interior Point Algorithms: Theory and Analysis. John Wiley & Sons, 1997.
A
Proof of Lemma 2.1
Let C∗ be the value of right-hand side of the equality we need to establish, and - for notational
convenience - let us denote the energy Er(f ∗) as E∗. So, our goal is to show that C∗ = 1/E∗ and
that taking ˜φ attains the minimum C∗.
We start by noting that, for any vertex potentials φ, we have
�
(u,v)∈E
f∗
(u,v)(φv − φu) =
�
v
φv(
�
e∈E+(v)
f∗
e −
�
e∈E−(v)
f∗
e ) =
�
v
φvσv = σT φ,
(51)
where we used the fact that f ∗ is a σ-ﬂow (cf. (1)).
Note that by the above calculations and the deﬁnition of ˜φ we have
σT ˜φ = 1
E∗
�
(u,v)∈E
f∗
(u,v)(φ∗
v − φ∗
u) = 1
E∗
�
(u,v)∈E
r(u,v)(f∗
(u,v))2 = 1,
(52)
where we used (5) and the deﬁnition of energy (4). Therefore, we see that C∗ ≤ 1/E∗ as by (6)
�
e=(u,v)∈E
(�φv − �φu)2
re
=
1
(E∗)2
�
e=(u,v)∈E
(φ∗
v − φ∗
u)2
re
= 1/E∗.
(53)
Now, let �φ be the potential such that �
(u,v)∈E
(�φv−�φu)2
r(u,v)
= C∗ and let ˆf with ˆf(u,v) :=
�φv−�φu
r(u,v) ,
for each (u, v) ∈ E, be the corresponding ﬂow induced via 5. (Note that in principle ˆf does not
need to be a σ-ﬂow).
From (51) we get that
(f ∗)T Rˆf =
�
e
ref∗
e ˆfe =
�
(u,v)∈E
f∗
(u,v)(�φv − �φu) = σT �φ = 1,
(54)
where we again used (5) and the fact that σT �φ = 1 by deﬁnition.
50

We claim that the energy Er(ˆf ) of ˆf (and thus the value of C∗) is at least 1/E∗. To this end,
let us note that
Er(ˆf )
=
ˆf
T Rˆf =
� f ∗
E∗ + ˆf − f ∗
E∗
�T
R
� f ∗
E∗ + ˆf − f ∗
E∗
�
=
(f ∗)T Rf ∗
(E∗)2
− 2(f ∗)T
E∗ R
�
ˆf − f ∗
E∗
�
+
�
ˆf − f ∗
E∗
�T
R
�
ˆf − f ∗
E∗
�
.
As we have seen in (54), (f ∗)T Rˆf = 1, thus (f ∗)T
E∗ R
�
ˆf − f ∗
E∗
�
= 0 and we can write
Er(ˆf )
=
(f ∗)T Rf ∗
(E∗)2
− 2(f ∗)T
E∗ R
�
ˆf − f ∗
E∗
�
+
�
ˆf − f ∗
E∗
�T
R
�
ˆf − f ∗
E∗
�
=
1
E∗ +
�
ˆf − f ∗
E∗
�T
R
�
ˆf − f ∗
E∗
�
≥ 1
E∗ ,
as f T Rf ≥ 0 for any f .
So, C∗ ≥ 1/E∗ too and thus C∗ = 1/E∗. Also, by (52) and (53) we see that ˜φ indeed attains
the minimum, as desired.
B
Proof of Corollary 3.4
Let f be a fractional feasible s-t ﬂow of value F in G and let us consider ﬁrst the case when F is
integral. Recall that the reduction presented in Section 4 allows one to obtain in �O(m) time an
instance of bipartite b-matching problem – corresponding to some bipartite graph ¯G – that has a
property that if there exists a feasible s-t ﬂow of value F in G then ¯G has a perfect b-matching. Now,
the crucial observation is that the proof of that property presented in Section 4 is fully constructive
and, in particular, provides an �O(m)-time algorithm that produces such a perfect b-matching in ¯G
out of a feasible s-t ﬂow in G of value F. Furthermore, this construction also works for fractional
ﬂows, it just produces a perfect b-matching that is fractional.
In the light of the above, we can simply apply this transformation to our ﬂow f and get a
fractional perfect b-matching x in ¯G. Next, we can use the rounding procedure from Theorem
3.3 to obtain in �O(m) time a perfect b-matching x ∗ in ¯G that is integral. (Note that since b is
always integral, so is the size of any perfect b-matching.) This, in turn, allows us to utilize another
property of the graph ¯G that was established in Section 4. Namely, that out of any integral perfect
b-matching in ¯G, one can extract – in �O(m) time – an integral and feasible s-t ﬂow f ∗ in G of value
F. Clearly, by combining all of the above steps, we get our desired integral s-t ﬂow.
Finally, to deal with the case when F is not integral, we just add an arc (s, t) to G, set its
capacity to 1, and put a ﬂow of ⌈F⌉ − F ≤ 1 on it. Obviously, now we have a feasible s-t ﬂow of
value ⌈F⌉ in such modiﬁed graph G and ⌈F⌉ is integral. Therefore, we can use our approach we
described above to get an integral and feasible s-t ﬂow f ∗ in this graph and f ∗ will have a value
of ⌈F⌉. Note that f ∗ can have non-zero ﬂow on the arc (s, t) that we added, but as this arc has
capacity of 1, there can be exactly one unit of ﬂow on this arc. So, if we simply remove it from
f ∗, we will get an integral and feasible s-t ﬂow in the original graph G and the value of f ∗ will be
⌈F⌉ − 1 = ⌊F⌋, as desired. This concludes the proof of the corollary.
51

C
Appendix to Section 4
C.1
Correctness Analysis
It is easy to verify that the produced b-matching instance is indeed bipartite (we have edges only
between diﬀerent sides of bipartition P and Q), has exactly 2(m+n−1) = Θ(m) vertices, 3m+n−2 ≤
4m edges, and |b|1 ≤ 4|u|1. So, we just need to establish the claimed connection to existence of
feasible s-t ﬂows in the graph G.
From Flow f to Perfect b-matching x
To this end, assume that there exists a feasible s-t ﬂow f in G of value F. To see that a perfect
b-matching in ¯G exists, consider a b-matching x that, for each arc e = (u, v) in G, takes exactly
fe edges (pe, qe) and ue − fe edges (qu, pe) and (qe, pv). Then, for every vertex v of G other than s
and t, x takes �
e∈E+(v) fe copies of the edge (pv, qv).
To see that x is indeed a perfect b-matching, observe that due to feasibility of f (cf. (2)),
0 ≤ fe ≤ ue for each arc e, and thus x ≥ 0. Also, by the construction of x, all vertices pe and qe
have exactly ue edges adjacent to them in x. So, they are fully matched. To see that all vertices
pv and qv are fully matched too, consider some v ̸= s, t. Indeed, by deﬁnition of x, we have exactly
�
e∈E+(v) ue − fe + �
e∈E+(v) fe = �
e∈E+(v) ue = bpv (resp. �
e∈E−(v) ue − fe + �
e∈E−(v) fe =
�
e∈E−(v) ue = bqv) edges adjacent to pv (resp. qv), where we used the fact that �
e∈E+(v) fe =
�
e∈E−(v) fe, as f obeys ﬂow conservation constraints (1). Finally, in the case of vertex qs (resp.
pt) we have that their degree in x is exactly �
e∈E−(s) ue − fe = (�
e∈E−(s) ue) − F = bqs (resp.
�
e∈E+(t) ue − fe = (�
e∈E+(t) ue) − F = bpt), due to the value �
e∈E−(s) fe = �
e∈E+(t) fe of the
ﬂow f being exactly F. So, indeed such x is perfect, as claimed.
From Perfect b-matching x to Flow f
Now, to see that given a perfect b-matching x in ¯G we can quickly, i.e., in �O(m) time, recover an
s-t ﬂow of value F that is feasible in G, consider a ﬂow f given by fe = x(pe,qe) for each arc e in G.
That is, the ﬂow fe on an arc e is equal to the number of times a copy of an edge (pe, qe) appears
in x. Note that as the demands bpe and bqe of the endpoints of each edge (pe, qe) are equal to ue, f
is feasible in G.
Finally, to prove that f also preserves ﬂow conservation constraints (cf. (1)), note that as x is
perfect, it has to be that for any vertex v and e ∈ E+(v) (resp. e ∈ E−(v)) x(pv,qe) = bqe −x(pe,qe) =
ue − fe (resp. x(pe,qv) = bpe − x(pe,qe) = ue − fe). So, if we do not take into account the edges
(pv, qv), each vertex pv (resp. qv) has exactly �
e∈E+(v) bqe − x(pe,qe) = �
e∈E+(v) ue − fe (resp.
�
e∈E−(v) bpe − x(pe,qe) = �
e∈E−(v) ue − fe) edges adjacent to it in x. This means, in particular,
that in case of qs (resp. pt) we need to have that �
e∈E−(s) ue −fe = bqs = (�
e∈E−(s) ue)−F (resp.
�
e∈E+(t) ue − fe = bpt = (�
e∈E+(t) ue) − F) and thus �
e∈E−(s) = F (resp. �
e∈E+(t) fe = F),
i.e., the value of f is F. Furthermore, for any vertex v other than s and t, as x is perfect, w
need to have that �
e∈E+(v) ue = bpv = x(pv,qv) + �
e∈E+(v) ue − fe (resp. �
e∈E−(v) ue = bqv =
x(pv,qv) + �
e∈E−(v) ue − fe). Therefore, �
e∈E+(v) fe = x(pv,qv) = �
e∈E−(v) fe, i.e., f obeys all ﬂow
conservation constraints. So, indeed f is a feasible s-t ﬂow of value F in G, as desired.
Lastly, it is worth pointing out that even though in the above proof we assume that both the
s-t ﬂow f and the b-matching x are integral, the proof goes through unchanged in the case when
52

f and x are fractional. We just will have that if f is fractional then so will be the corresponding
b-matching x and vice versa.
D
Appendix to Section 5
D.1
Proof of Lemma 5.4
Let us take s0 to be the all-ones vector 1 (this corresponds to y0 assigning zero value to all vertices).
Next, let the ﬂow f 0 and measures ν0 be deﬁned as follows.
For each arc of the form (sp, tq) in �G, we give it a measure of one in ν0 and a ﬂow of one unit
is sent through it in f 0. Now, for each vertex sp (resp. tq) in �G, let rp := | �E−(sp)| − 1 − bp (resp.
rq := | �E+(tq)| − 1 − bq). If rp ≥ 0 (resp. rq ≥ 0) then we put a ﬂow of one and measure of one on
the arc (sp, v∗) (resp. (v∗, tq)) and a ﬂow and measure of rp + 1 (resp. rq + 1) on the arc (v∗, sp)
(resp. (tq, v∗)). On the other hand, if rp < 0 (resp. rq < 0) then we put a ﬂow and measure of
1 − rp (resp. 1 − rq) on the arc (sp, v∗) (resp. (v∗, tq)) and a ﬂow and measure of one on the arc
(v∗, sp) (resp. (tq, v∗)).
One can verify that the resulting ﬂow f 0 is indeed a ˆσ-ﬂow (again, one needs to use here the
fact that �
p bp = �
primal-dual feasible.q bq, as otherwise there is no perfect b-matching in G) and thus the solution is
Also, the total measure �
e ν0
e of all the arcs is at most �m + |b|1 ≤ 3 �m. Finally, we have that
ˆµ0
e = f0
e s0
e
ν0e
= 1 for all arcs e and thus the solution is indeed 0-centered and ˆµ(f 0, s0, ν0) = 1, as
desired.
E
Appendix to Section 6
E.1
Proof of Lemma 6.3
That (1 − γ)α ≤ β ≤ (1 + γ)α follows directly from Fact 5.3.
Let us show now that ˆµ(f ′, s′, ν′) = ˆµ(f , s, ν). To this end, let us deﬁne γe so as
(1 + γe) := β
α =
fese
νeˆµ(f , s, ν).
By deﬁnition (10), we have that
ˆµ(f ′, s′, ν′) =
�
g f′
gs′
g
�
g ν′g
=
(�
g̸=e fgsg) + (1 + α)fese
(�
g̸=e νg) + (1 + β)νe
= ˆµ(f , s, ν)
�
(�
g νg) + ανe(1 + γe)
(�
g νg) + ανe(1 + γe)
�
= ˆµ(f , s, ν)
Now, to bound the centrality of (f ′, s′, ν′), we need to bound the value of ∥ˆµ′−ˆµ(f ′, s′, ν′)1∥ν′,2.
However, as ˆµ(f ′, s′, ν′) = ˆµ(f , s, ν) and the two solution coincide on all the arcs except e, it suﬃces
to analyze the change in contribution of arc e to the centrality of the solution. Namely, we just
need to show that
ν′
e
�f′
es′
e
ν′e
− ˆµ(f , s, ν)
�2
= (1 + β)νe
�(1 + α)fese
(1 + β)νe
− ˆµ(f , s, ν)
�2
≤ νe(fese
νe
− ˆµ(f , s, ν))2.
53

To this end, observe the right side of the above inequality is just
νe
�fese
νe
− ˆµ(f , s, ν)
�2
= νeγ2
e ˆµ(f , s, ν)2.
So, we need to show that
ν′
e
νeˆµ(f , s, ν)2
�f′
es′
e
ν′e
− ˆµ(f , s, ν)
�2
= (1 + β)
�(1 + α)(1 + γe)
(1 + β)
− 1
�2
≤ γ2
e.
But this is true as
(1 + β)
�(1 + α)(1 + γe)
(1 + β)
− 1
�2
= ((1 + α)(1 + γe) − 1 − (1 + γe)α)2
1 + (1 + γe)α
=
γ2
e
1 + (1 + γe)α ≤ γ2
e,
where we used that fact that (1 + γe) ≥ 1
2 since, by Fact 5.3, (1 + γe) ≥ (1 − γ) ≥ 1
2.
E.2
Proof of Lemma 6.5
Note that by construction of the graph �G and by Invariant 6.4, we have that for any two vertices v,
v′ in �G there is a directed path from v to v′, as well as, a one from v′ and v, with each one of them
consisting of at most two arcs and having length at most 4. As (f , s, ν) is σ-feasible then it is, in
particular, dual feasible. So, this implies that if y is the embedding of the vertices of �G into a line
corresponding to the slack variables s, then |yv − yv′′| is at most 4 as well. Thus, we can conclude
that for any arc e = (v, v′) in �G, we have that se = ˆle − yv′ + yv ≤ ˆle + |yv − yv′′| is at most 6, as
desired.
E.3
Proof of Lemma 6.6
Note ﬁrst that all the arcs in the original version of �G have length 1 and α-stretching can only
increase these lengths.
This means that it is still true – as in the proof of Lemma 5.1 – that
ˆl(f ) − |b|1
2
is an upper bound on the total ﬂow between the vertices sp and tq that is not ﬂowing
over the direct arcs (sp, qt) reﬂecting the original edges of G.
Furthermore, as by Invariant 6.4 the total increase in the length of the arcs of �G is �O( �m
1
2 −η),
the cost ˆl(f ∗) of the ﬂow that encodes the perfect b-matching in G (cf. the proof of Lemma 5.1),
can increase to at most |b|1
2 + �O( �m
1
2 −η). (We use here the fact that f∗ never ﬂows more than one
unit of ﬂow through any of the arcs.) So, we can assume that the cost ˆl(f ) of the ﬂow f we have
is also |b|1
2 + �O( �m
1
2 −η), as otherwise we could conclude that no perfect b-matching exists in G.
However, then it must be the case that the total ﬂow in f that does not correspond to taking
the direct arcs is at most �O( �m
1
2 −η). Thus, the fractional b-matching obtained by taking only the
ﬂow that uses these direct ﬂow-paths will still result in a near-perfect b-matching in G.
E.4
Proof of Lemma 6.8
Note ﬁrst that the upperbound follows directly from Lemma 5.7 as long as we ensure that CE > 4
(which indeed will be the case).
To establish the lowerbound, let us note ﬁrst that without loss of generality we can assume
that in our b-matching instance G = (P ∪ Q, E), |P| ≥ |Q| and thus, as our graph G is sparse,
|P| = Ω( �m). (Otherwise, we just exchange the roles of P and Q in what follows below.)
54

Let us deﬁne a vector of resistances ˜r t given by
˜rt
e :=
�
rt
e
if e ∈ �E(sp), for some p ∈ P
0
otherwise,
where �E(sp) := �E+(sp) ∪ �E−(sp) is the set of all arcs incident to sp in �G. In other words, ˜r t
corresponds to setting to zero resistances (i.e., collapsing) of all the arcs that are not adjacent
to some vertex in P; and making the resistances of arcs that are adjacent to such sp equal to
their original resistances in r t. This means, in particular, that ˜rt
e ≤ rt
e, for each arc e, and thus, by
Rayleigh Monotonicity principle (cf. Fact 2.2), we know that if ˜f
t is the electrical ˆσ-ﬂow determined
by resistances ˜r t then
E˜rt(˜f
t) ≤ Ert(ˆf
t).
Therefore, we can just focus on lowerbounding E˜rt(˜f
t). To this end, note that after collapsing
all the arcs that were not adjacent to some vertex in P, we can think of �G as a graph that consists
only of vertices from P and a single vertex w∗ that represents the remaining collapsed vertices.
Furthermore, as there is no arcs in �G between diﬀerent vertices sp, all the arcs in this collapsed
graph are of the form (sp, w∗) or (w∗, sp) for some p ∈ P.
As a result, E˜rt(˜f
t) is equal to
E˜rt(˜f
t) =
�
p∈P
�
e∈ �
E(sp)
rt
e( ˜ft
e)2 =
�
p∈P
Rpσ2
sp,
where Rp is the eﬀective resistance between vertex sp and w∗ with respect to resistances ˜r t and the
last equality follows as ˜f
t is a ˆσ-ﬂow and all arcs are connecting to w∗.
Now, to lowerbound Rp, for some p ∈ P, note that by deﬁnition of r t (14), the fact that νt
e ≥ 1
for all e, and Fact 5.3, we have that
1
Rp
=
�
e∈ �
E(sp)
1
rte
=
�
e∈ �
E(sp)
(ft
e)2
µte
≤
�
e∈ �
E(sp)
(ft
e)2
(1 − ˆγ)νteˆµ(f t, st, νt) ≤
F 2
p
(1 − ˆγ)ˆµ(f t, st, νt),
where Fp := �
e∈ �
E(sp) ft
e and we used the well-known formula for eﬀective resistance of a circuit
that consists solely of parallel arcs.
So, all the above considerations allow us to observe that
E˜rt(˜f
t) =
�
p∈P
Rpˆσ2
sp ≥
�
p∈P
(1 − ˆγ)ˆµ(f t, st, νt)
F 2p
≥ (1 − ˆγ)ˆµ(f t, st, νt)|P|3
F 2 ,
where F = �
p Fp and we used the fact that |ˆσsp| ≥ bp ≥ 1, as well as, that for any n-dimensional
vector x, �n
i=1
1
x2
i ≥
n3
|x|2
1 .
Thus, it remains to provide an upperbound on F. To this end, let us decompose the ﬂow f t into
ﬂow-paths (whose endpoints are vertices sp and tq) and ﬂow-cycles. Clearly, the total contribution of
the ﬂow-paths to F can be at most |ˆσ|1 ≤ |b|1 = O( �m), since our b-matching instance is balanced.
On the other hand, as length of any ﬂow-cycle is at least two and each ﬂow-cycle contributes its
whole volume to the duality gap (f t)T st = �
e µt
e (as ﬂow-cycles do not exist in optimal solution),
55

the total contribution of ﬂow-cycle to F is at most 1
2
�
e µt
e. Thus, by (13) and Invariant 5.2, this
contribution is at most 1
2
�
e µt
e = 1
2 ˆµ(f t, st, νt)(�
e νt
e) ≤ 2 �mˆµ(f t, st, νt) ≤ 2 �m.
Therefore, we can conclude that F = O( �m) and since |P| is Ω( �m) we have
E˜rt(˜f
t) ≥ (1 − ˆγ)ˆµ(f t, st, νt)|P|3
F 2 ≥ C−1
E �mˆµ(f t, st, νt),
where CE > 4 is an appropriately chosen constant.
E.5
Proof of Lemma 6.9
Let us denote by r, ν, and ˆf , respectively, the resistances r t, measures νt, and electrical ˆσ-ﬂow ˆf
t
before stretch-boost and by r ′, ν′, and ˆf
′ the corresponding objects after stretch-boost. Also, let
as deﬁne S∗ := Sl∗(ˆf
t) ∩ Et
H, where l∗ is the index of the stretch-boost. In this notation, we want
to show that
Er′(ˆf
′) ≥
�
1 + ν(S∗)
36 · 22l∗
�
Er(ˆf ) ≥
�
1 +
ˆθ2(ν(S∗))
1
3
36
�
Er(ˆf ) ≥
�
1 +
ˆθ2
36
�
Er(ˆf ).
(55)
Clearly, the last inequality follows as νe ≥ 1 for all arcs e. To see that the second inequality holds,
observe that by (22) we have that
ν(S∗) ≥ ˆθ323l∗
and thus
ν(S∗)
36 · 22l∗ ≥ (ν(S∗))
1
3 (ˆθ323l∗)
2
3
36 · 22l∗
=
ˆθ2(ν(S∗))
1
3
36
.
Therefore, once the ﬁrst inequality in (55) is established, our lemma will follow by choosing CS := 1
36.
So, let us proceed to establishing that inequality. By Lemma 2.1, we know that if φ∗ is the
vector of vertex potentials corresponding to the ﬂow ˆf and resistances r then
1
Er(ˆf )
=
�
e=(u,v)∈ �
E
(�φv − �φu)2
re
,
(56)
where �φv := φ∗
v/Er(ˆf ), for each v, and ˆσT ˜φ = 1.
Now, consider an arc e ∈ S∗. By (5), the deﬁnition of the sets Sl∗(ˆf
t) (17), and Fact 5.6, we
have that
(�φv − �φu)2
re
=
1
Er(ˆf )2 re ˆf2
e ≥ (1 − ˆγ)νeˆµ(f , s, ν)ρ(f ,ˆf )2
Er(ˆf )2
≥
� (1 − ˆγ)νe �mˆµ(f , s, ν)
4 · 22(l∗+1) �mˆµ(f , s, ν)
�
1
Er(ˆf )
≥
�
νe
18 · 22l∗
�
1
Er(ˆf )
,
where we also used Lemma 5.7.
In other words, the contribution of arc e to the sum in (56)
constitutes at least
νe
18·22l∗ -fraction of this sum.
56

Next, observe that, by deﬁnition of 1-stretching, we need to have that the resistance doubles,
i.e., r′
e = 2re, for all the arcs e ∈ S∗, and remains the same for other arcs, i.e., r′
e = re, for e /∈ S∗.
This means that
�
e=(u,v)∈ �
E
(�φv − �φu)2
r′e
=
1
2
�
e=(u,v)∈S∗
(�φv − �φu)2
re
+
�
e=(u,v)∈ �
E\S∗
(�φv − �φu)2
r′e
=
1
Er(ˆf )
− 1
2
�
e=(u,v)∈S∗
(�φv − �φu)2
re
≤
1
Er(ˆf )
�
1 − ν(S∗)
36 · 22l∗
�
.
ofBut, by Lemma 2.1, we know that the above estimation provides an upper bound on the value
1
Er′(ˆf
′), i.e., we have
1
Er′(ˆf
′)
=
min
φ|ˆσT φ=1
�
e=(u,v)∈ �
E
(φv − φu)2
r′e
≤
�
e=(u,v)∈ �
E
(�φv − �φu)2
r′e
≤
1
Er(ˆf )
�
1 − ν(S∗)
36 · 22l∗
�
,
where we used the fact that ˆσT ˜φ = 1, by deﬁnition of ˜φ. Multiplying both sides by Er′(ˆf
′)Er(ˆf )
�
1− ν(S∗)
36·2l∗
� and
noticing that
1
(1−x) ≥ (1 + x) for any x ≥ 0, gives us the desired inequality in (55).
E.6
Proof of Lemma 6.11
Let us denote the solution (f t, st, νt) by (f , s, ν), the associated electrical ﬂow ˆf
t by ˆf , and let
r be the resistances r t corresponding to this solution (cf. (14)). Also, let (f ′, s′, ν′), ˆf
′, and r ′,
denote these respective object after the interior-point method step is applied.
In this notation, our goal is to show that
Er′(ˆf
′) ≥ (1 + CP ˆθ2 ln �m)−1Er(ˆf ).
To perform such lowerbounding of the energy decrease, we proceed similarly as we did in the
proof of Lemma 6.9. Namely, by Lemma 2.1, we know that
1
Er(ˆf )
=
�
e=(u,v)∈ �
E
(�φv − �φu)2
re
,
where �φe := φ∗
e/Er(ˆf ) and σT ˜φ = 1. We want to show that if we keep the same vertex potentials
˜φ and change the resistances to r ′ then still the corresponding sum – as in the equation above –
will not increase by too much (and thus provide a good upperbound on
1
Er′(ˆf
′)).
More speciﬁcally, recall that by Theorem 5.5, for any arc e,
r′
ree
= (1 + κt
e)
(1 − δt) ,
and that ∥κt∥∞ ≤ 1
2.
So, by Lemma 2.1, we have that
57

1
Er′(ˆf
′)
≤
�
e=(u,v)∈ �
E
(φv − φu)2
r′e
≤
�
e=(u,v)∈ �
E
(�φv − �φu)2
r′e
≤
�
e=(u,v)∈ �
E
(1 + 2|κt
e|)(�φv − �φu)2
re
,
where we use the fact that (1 − x)−1 ≤ (1 + 2x) when x ≤ 1
2 and that by deﬁnition of ˜φ, σT ˜φ = 1.
Furthermore, by (5) and deﬁnition of ˜φ, we have
�
e=(u,v)∈ �
E
(1+2|κt
e|)(�φv − �φu)2
re
=
1
Er(ˆf )
�
1 + 2
�
e
|κt
e|(�φv − �φu)2
re
Er(ˆf )
�
=
1
Er(ˆf )
�
1 + 2
�
e
|κt
e|re( ˆfe)2
Er(ˆf )
�
.
So, we again just need to show that
�
e
|κt
e|re( ˆfe)2
Er(ˆf )
≤ CP ˆθ2 ln �m,
and the lemma will follow.
To establish this last claim, note that for any arc e, re( ˆfe)2
Er(ˆf ) is just the fraction of energy of the
ﬂow ˆf (with respect to resistances r) that is contributed by the arc e. So, by Fact 5.6 and Lemma
6.8, we have that
re( ˆfe)2
Er(ˆf )
≤ (1 + ˆγ)νeˆµ(f , s, ν)ρ(f ,ˆf )2
e
Er(ˆf )
≤ 2CEνe
22k
,
(57)
whenever e ∈ Sk(ˆf ) (cf. (17)), for some integer k.
As a result, we can conclude that
�
e
|κt
e|re( ˆfe)2
Er(ˆf )
≤
2
�
l
�
e∈Tl
re( ˆfe)2
2lEr(ˆf )
≤ 2


�
l≤⌊log ˆθ−2⌋
�
e∈Tl
re( ˆfe)2
2lEr(ˆf )
+
�
l≥⌈log ˆθ−2⌉
�
e∈Tl
2ˆθ2 re( ˆfe)2
Er(ˆf )


≤
2


�
l≤⌊log ˆθ−2⌋
�
e∈Tl
νere( ˆfe)2
2lνeEr(ˆf )

 + 4ˆθ2 ≤ 4CE


�
l≤⌊log ˆθ−2⌋
�
k
�
e∈Tl∩Sk(ˆf )
νe
2l22k

 + 4ˆθ2
=
4CE


�
l≤⌊log ˆθ−2⌋
�
k
ν(Tl ∩ Sk(ˆf ))
22k+l

 + 4ˆθ2,
where Tl denotes T κt
l
(cf. (23)), (57), and the fact that
�
l≥⌈log ˆθ−2⌉
�
e∈Tl
re( ˆfe)2
Er(ˆf )
≤
�
e
re( ˆfe)2
Er(ˆf )
= Er(ˆf )
Er(ˆf )
= 1.
Now, by 2ˆθ-smoothness of ˆf (cf. Deﬁnition 6.1), we get that
ν(Tl ∩ Sk(ˆf )) ≤ ⌊ˆθ323(k+1)⌋,
(58)
58

l,for each l and k. Also, the fact that by Lemma 6.10 κt is O(1)-restricted implies that, for any ﬁxed
�
k
ν(Tl ∩ Sk(ˆf )) = ν(Tl) ≤ O(23l).
Therefore, we can see that for any l, we have
�
k
ν(Tl ∩ Sk(ˆf ))
22k+l
≤
k′
�
k=0
ν(Tl ∩ Sk(ˆf ))
22k+l
,
for some k′ = l+log ˆθ−1 +O(1). Here, we used the fact that by (58), ν(Tl ∩Sk(ˆf )) = ∅, if k < 0 and
that the expression we are bounding will be maximized if the set Tl contains as many high-energy
arcs as possible. (Note that due to the constraint ν(Tl) = O(23l) and the bound (58), Tl can then
only contain all the arcs in sets Sk(ˆf ) for all k ≥ 0 up to k′.) So, we can conclude that
∞
�
k=0
ν(Tl ∩ Sk(ˆf ))
2k+l
≤
k′
�
k=0
ˆθ323(k+1)
22k+l
= O(ˆθ32
k′
2 −l) = O(ˆθ2).
To ﬁnish our overall bound, we just need to note that by our above derivation, as well as, the
fact that Tl = ∅ if l ≤ 0 (as ∥κt∥∞ ≤ 1
2),
�
e
|κt
e|re( ˆfe)2
Er(ˆf )
≤ 4CE


⌊log ˆθ−2⌋
�
l=1
�
k
ν(Tl ∩ Sk(ˆf ))
22k+l

+4ˆθ2 ≤ 4CE
�
O(log ˆθ−2)O(ˆθ2) + ˆθ2�
= CP ˆθ2 ln �m,
as desired, once CP > 1 is chosen to be large enough.
E.7
Proof of Lemma 6.12
We start by bounding the increase of measure due to freezing. Let us ﬁx some progress step t and
some auxiliary arc e that is in Tl for some l ≤ log ˆθ−2, where Tl denotes T ¯κt
l , as deﬁned in (23).
(Note that only arcs in Tl with l ≤ log ˆθ−2 can be frozen at step t.)
By Lemma 6.3 and deﬁnition of Tl, the increase of measure resulting from �m2η|¯κt
e|-stretching e
is at most
(1 + ˆγ) �m2η|¯κt
e|νt
e ≤ 2 �m2η
2l
.
However, by Lemma 6.10, we know that the vector ¯κt is CR-restricted. Therefore, the total contri-
bution to measure increase of all the frozen arcs in Tl is at most
2 �m2η
2l
CR23l ≤ O( �m2η22l) = O( �m6η),
where we used the fact that l ≤ log ˆθ−2.
So, as there is at most log ˆθ−2 diﬀerent sets Tl that contribute in each progress step, and there is
at most ˆθ−2 = �m2η progress steps, the overall increase of measure due to freezing is at most �O( �m8η),
as required.
Note that once we establish below that all auxiliary have always ft
e that is within a factor of
CF of FA, the fact that FA is much smaller than FH will imply that all auxiliary arcs are always
59

light and thus never get stretch-boosted. So, the measure of auxiliary arc can increase only due to
freezing and we have already bounded this increase above.
Now, to prove the ﬁrst part of the lemma, let us ﬁx some auxiliary arc e. Initially, ft
e is equal
to FA. So, one just need to argue that the total multiplicative change of ft
e during the course of the
ˆθ-improvement phase execution is bounded by a constant.
To this end, note that the ﬂows on arcs change only during the progress steps. So, by Theorem
5.5, if we ﬁx some auxiliary arc e, its overall ﬂow changes by a factor of at most
tf
�
t=t0
(1 + |¯κt
e|).
Therefore, the total change of ﬂow of e during progress steps that have not resulted in freezing
it, can bounded by
tf
�
t=t0
(1 + |¯κt
e|) ≤ (1 + ˆθ2)
ˆθ−2 ≤ exp(1),
that is constant, as desired.
So, now we just need to focus on bounding the change of ﬂow on e resulting from the remaining
progress steps, i.e., the ones in which it was frozen. To this end, recall that whenever |¯κt
e| ≥ ˆθ−2 in
some step t then freezing �m2η|¯κt
e|-stretches e. By Lemma 6.3, the resulting increase of measure of
e is at least by a factor of
�
1 + (1 − ˆγ) �m2η|¯κt
e|
�
,
while the change of the ﬂow is by a factor of at most
�
1 + |¯κt
e|
�
.
Therefore, as the former factor is signiﬁcantly larger than the latter one, ∥¯κt∥∞ ≤ 1
2 (by Theorem
5.5), and as from discussion above we know that once the measure of an arc becomes larger than
CRˆθ−6 it will never be frozen again, the constant bound of the maximum multiplicative change of
the ﬂow of an auxiliary arc follows. This concludes the proof of the lemma.
E.8
Proof of Lemma 6.13
By deﬁnition of ˆµ(f t, st, νt) (cf. (10)), we have that
ˆµ(f t, st, νt) =
�
e νt
eˆµt
e
�
e νte
= ˆµ(f t, st, νt)
�
1 +
�
e νt
�eλe
e νte
�
,
where λe := (ˆµt
e−ˆµ(f t,st,νt))
ˆµ(f t,st,νt)
, for each arc e.
On the other hand, we have that
ˆµ(f ′, s′, ν′) =
�
e∈S νt
eˆµt
e
�
e∈S νte
= ˆµ(f t, st, νt)
�
1 +
�
e∈S νt
eλe
�
e∈S νte
�
≤ ˆλˆµ(f t0, st0, νt0)
�
1 +
�
e∈S νt
e|λe|
νt(S)
�
,
(59)
where S is the set of non-auxiliary arcs of ¯G.
60

Now, observe that by deﬁnition of ˆγ-centrality (cf. (11)) we have
∥λ∥νt,2 = ∥ˆµt − ˆµ(f t, st, νt)∥νt,2
ˆµ(f t, st, νt)
≤ ˆγ.
So, by applying Cauchy-Schwarz inequality we get that
�
e∈S νt
e|λe|
νt(S)
≤
��
e∈S νteλ2e
νt(S)
=
�
∥λ∥2
νt,2
νt(S) ≤
�
ˆγ2
νt(S) ≤ O( �m− 1
2 ),
where we use the fact that νt(S) ≥ �m.
By putting the above inequality and (59) together, the lemma follows.
E.9
Handling Approximate Nature of Electrical Flow Computations
Here, we discuss how one can adjust our algorithm developed in Sections 5–7 to nearly-linear time
electrical ﬂow computations that are only approximate – as in Theorem 2.3 – instead of being exact.
To this end, let us ﬁrst recall that we are using electrical ﬂow computations in two places of our
algorithm. One is our improvement step described in Section 7. There, to make the descent step, we
compute the electrical ﬂow ˆf
compute the electrical ﬂow ˜ft associated with our solution and then, to make the centering step, we
t. The other place where we use electrical ﬂow computations is to check
the ˆθ-smoothness condition (cf. Deﬁnition 6.1), that is to check which arcs are in the sets Sl(ˆf
t),
for l ≤ log ˆθ−3. (Note that it is suﬃcient for us to know this classiﬁcation only approximately, say
up to a constant factor.)
Observe that in all these three cases, we end up computing some electrical σ-ﬂows that are
determined by some resistances r deﬁned as re = se
fe (cf. (14)), for each arc e, and where (f , s, ν) is
some γ-centered and ¯σ′-feasible solution with γ ≤ 1
2 and both |σ|1 and |σ′|1 being O( �m). Further-
more, we always have that
1
O( �m) ≤ ˆµ(f , s, ν) ≤ 1, all variables se are bounded by a constant (see
Lemma 6.5), and the duality gap is O( �m). (All the deﬁnitions that are relevant here can be found
in Section 5 and at the beginning of Section 6.)
This implies that, for any arc e, fe is always polynomially bounded in �m. This is so since,
given our polynomially-bounded demands, any ﬂow of value ω( �m) would need to consist mostly of
ﬂow-cycles, and such ﬂow-cycles would contribute to duality gap (as they cannot exist in optimal
solution), which is always O( �m).
This, in turn, together with γ-centrality (see Fact 5.3) and Invariant 5.2, allows us to conclude
that all the resistances
re = se
fe
= (1 ± γ)νeˆµ(f , s, ν)
f2e
= (1 ± γ)
s2
e
νeˆµ(f , s, ν)
are within a polynomial in �m factor of each other.
It is known (see, e.g., Theorem 2.3 in [CKM+11]) that once all the resistances are within polyno-
mial of each other, one can aﬀord very good (and fast) approximation to all the major characteristics
of the electrical ﬂows (including good approximation to the ﬂow on each of the edges). In particular,
one is able to easily perform (approximate) classiﬁcation of arcs into sets Sl(ˆf
t), for l ≤ log ˆθ−3.
(Note that we want to classify here only arcs that contribute signiﬁcant portion of the total energy
61

anyway.) Also, looking at our analysis of our improvement step in Section 7, one can see that the
most fundamental requirement there is that the ﬂows ˆf
t and ˜f
t that we compute are indeed elec-
trical ﬂow, i.e., there are voltages that induce them via (5). After all, this is what ensures that our
ﬁrst-order updates to the centrality are canceling out. The fact that these ﬂow might not have the
exact demands we requested is of lesser importance. The only eﬀect of the latter will be that our
improvement steps will end up perturbing the ˆσ-feasibility of our maintained solution. However,
given that we have polynomially bounded resistance ratio and logarithmic dependence on error, we
can always make these perturbation very small and just ﬁx them at the end of each ˆθ-improvement
steps via the ﬁxing procedure that we already employ to ﬁx the eﬀects of the preconditioning – see
Section 6.2.
In the light of the above, we can conclude that indeed, having approximate, instead of exact,
electrical ﬂow computations is acceptable for our algorithm, at least as long the dependence of the
running time on the error is only logarithmic (which is the case here).
F
Appendix to Section 7
To prove the second part of the theorem, note ﬁrst that indeed νt+1 = ¯νt = νt. Next, we can check
that the cumulative changes of the vectors f t and st are equal to
ft+1
e
=
(1 − δt)
�
1 +
δt ˆft
e
(1 − δt)fte
� �
1 −
ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt)
ˆ¯µte
� �
1 +
˜ft
e
¯f′e
�
ft
e
st+1
e
=
�
1 −
δt ˆft
e
(1 − δt)fte
� �
1 −
˜ft
e
¯f′e
�
st
e,
for each arc e in �G.
As a result, by (14), we have that for each arc e,
(1 − δt)rt+1
e
= (1 − δt)st+1
e
ft+1
e
=
�
1 −
δt ˆft
e
(1−δt)fte
� �
1 −
˜ft
e¯f′e
�
st
e
�
1 +
δt ˆfte
(1−δt)fte
� �
1 −
ˆ¯µte−ˆµ(¯f t,¯st,¯νt)
ˆ¯µte
� �
1 +
˜fte¯f′e
�
fte
.
Recall that from the discussion above we already know that, for each arc e, |
δt ˆft
e
(1−δt)fte | =
δtρ(ˆf
t,f t)e
(1−δt)
≤ 2√ˆγ ≤ 1
10 (cf. (41)), |
ˆ¯µt
e−ˆµ(¯f t,¯st,¯νt)
ˆ¯µte
| ≤
ˆγ
(1−ˆγ) ≤ 1
40 (cf. Fact 5.3), and |
˜ft
e¯f′e | = ρ(˜f
t,¯f ′)e ≤
1
40 (cf. (50)). So, as rt
e = st
e
fte , we have that
(1 + κt
e) =
�
1 −
δt ˆft
e
(1−δt)fte
� �
1 −
˜ft
e¯f′e
�
�
1 +
δt ˆfte
(1−δt)fte
� �
1 −
ˆ¯µte−ˆµ(¯f t,¯st,¯νt)
ˆ¯µte
� �
1 +
˜fte¯f′e
�
and by performing a simple Taylor expansion approximation we can obtain that
|κt
e| ≤ 2
�
δtρ(ˆf
t, f t)e
(1 − δt)
+ |ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt)|
ˆ¯µte
+ ρ(˜f
t,¯f ′)e
�
≤ 4
�
δtρ(ˆf
t, f t)e + ˆκt
e
�
,
62

for each arc e, where ˆκt
e := |ˆ¯µt
e−ˆµ(¯f t,¯st,¯νt)|
ˆ¯µte
+ ρ(˜f
t,¯f ′)e.
Clearly, this means, in particular, that ∥κt
e∥∞ ≤ 2( 2
10 + 1
40 + 1
40) = 1
2, as desired. So, we just
need to show that ∥ˆκt∥νt,2 ≤ 1
16 too. To this end, observe that
∥ˆκt∥2
νt,2
≤
2
�
e
νt
e
�
(ˆ¯µt
e − ˆµ(¯f t, ¯st, ¯νt))2
(ˆ¯µte)2
+ ρ(˜f
t,¯f ′)2
e
�
≤
2
�
∥ˆ¯µt − ˆµ(¯f t, ¯st, ¯νt)1∥2
¯νt,2
(1 − ˆγ)2ˆµ(¯f t, ¯st, ¯νt)2
+
1
ˆµ(¯f t, ¯st, ¯νt)
�
e
ˆµ(¯f t, ¯st, ¯νt)ρ(˜f
t,¯f ′)2
e
�
≤
2
�
9ˆγ2 +
E˜rt(˜f
t)
ˆµ(¯f t, ¯st, ¯νt)
�
≤
1
256,
as desired, where we used a combination of Fact 5.3, the fact that (¯f t, ¯st, ¯νt) is 3ˆγ-centered, as well
as, equations (46) and (49). This concludes the proof of the theorem.
63