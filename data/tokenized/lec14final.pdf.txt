CPSC 420 Lecture 14: Today’s announcements:
▶ Examlet 2 on Feb 17 in class. Closed book & no notes
▶ Reading: Ch.3 Dynamic Programming [by Erickson]
Introduction to Algorithms [by Manber]
An O(ND) difference algorithm and its variations [by Myers]
https://go.exlibris.link/Wv9Rf8Tn
Today’s Plan
▶ Dynamic programming
▶ Longest Increasing Subsequence
▶ Edit Distance
1 / 6

Best Increasing Subsequences Dynamic Programming
8
3
4
9
6
2
1
5
7
2
R[k] extends BIS[j] iff BIS[j].last < R[k] and
(j = |BIS| or BIS[j + 1].last > R[k])
Maintain lists L[0], L[1], .. where L0[0] = [0]. After we scan R[1..k]
Lk[j] =
�
Lk−1[j] ◦ R[k]
if R[k] extends BISk−1[j]
Lk−1[j]
otherwise
L[0] =
0
L[1] =
8
3
2
1
L[2] =
4
2
L[3] =
9
6
5
L[4] =
7
use binary search to ﬁnd j
Running time?
a
b
means b extended
BIS ending with a
As a result list Lk[i] ends with BISk[j].last at step k.
2 / 6

Use LIS to solve LCS [Hunt & Szymanski, McIlroy 1977]
= X
Y =
A
B
C
B
A
C
C
B
B
x
x
x
C
x
x
x
D
A x
x
B
x
x
x
C
x
x
x
C
x
x
x
3 / 6

Use LIS to solve LCS [Hunt & Szymanski, McIlroy 1977]
= X
Y =
A
B
C
B
A
C
C
B
B
x○
x
x
C
x○
x
x
D
A x
x
B
x
x○
x
C
x
x○ x
C
x
x
x○
1 , 2
2 , 3
5 , 4
6 , 6
7 , 7
Longest Common Subsequence = BCBCC
What properties do the circled entries have?
3 / 6

Use LIS to solve LCS [Hunt & Szymanski, McIlroy 1977]
= X
Y =
A
B
C
B
A
C
C
B
B
x○
x
x
C
x○
x
x
D
A x
x
B
x
x○
x
C
x
x○ x
C
x
x
x○
1 , 2
2 , 3
5 , 4
6 , 6
7 , 7
Longest Common Subsequence = BCBCC
What properties do the circled entries have?
They form a sequence of index-pairs of matches that increase in
both dimensions.
Idea: Use LIS to find a longest such “doubly-increasing” sequence
in the sequence of all index-pairs of matches.
3 / 6

Use LIS to solve LCS [Hunt & Szymanski, McIlroy 1977]
= X
Y =
A
B
C
B
A
C
C
B
B
x○
x
x
C
x○
x
x
D
A x
x
B
x
x○
x
C
x
x○ x
C
x
x
x○
1 , 2
2 , 3
5 , 4
6 , 6
7 , 7
Longest Common Subsequence = BCBCC
Write index-pairs of matches in top-bottom, right-left order.
1 1 1 2 2 2 4 4 5 5 5 6 6 6 7 7 7
8 4 2 7 6 3 5 1 8 4 2 7 6 3 7 6 3
= S
A common sequence of X and Y corresponds to an increasing
sequence of S (and vice-versa).
3 / 6

Use LIS to solve LCS [Hunt & Szymanski, McIlroy 1977]
LCS(X, Y )
1. Stably sort X keeping track of each character’s index in X
3.2. for i = 1 to n
look up Y [i] in sorted X
4.
add indices of matching characters in reverse order to S
5. Q = LIS(S)
6. Output X[Q] (characters in X indexed by Q)
X = A B C B A C C B
Y = B C D A B C C
A
A
B
B
B
C
C
C
1
5
2
4
8
3
6
7
In practice: Use hashing rather than sorting.
4 / 6

A different approach to edit distance [Myers 1986]
The edit distance between X and Y is the minimum number of
inserts and deletes to transform X into Y .
Problem: Given two strings X and Y , find edit distance d(X, Y ).
elephant
d−→ elephnt
i−→ telephnt
d−→ telephn
i−→ telephon
i−→ telephone
LCS(elephant, telephone) = elephn
5 / 6

A different approach to edit distance [Myers 1986]
The edit distance between X and Y is the minimum number of
inserts and deletes to transform X into Y .
Problem: Given two strings X and Y , find edit distance d(X, Y ).
elephant
d−→ elephnt
i−→ telephnt
d−→ telephn
i−→ telephon
i−→ telephone
LCS(elephant, telephone) = elephn
d(X, Y ) = |X| + |Y | − 2|LCS(X, Y )|
So why are we talking about edit distance?
5 / 6

A different approach to edit distance [Myers 1986]
(0, 0)
D
A
R
V
A
T
R
A
V
A
D
(x, y − 1) ↓ (x, y) insert Y [y]
(x − 1, y) → (x, y) delete X[x]
(x − 1, y − 1) ↘ (x, y) X[x] = Y [y]
= X
Y =
red cost = 1
black cost = 0
(m, n)
6 / 6

A different approach to edit distance [Myers 1986]
(0, 0)
D
A
R
V
A
T
R
A
V
A
D
(x, y − 1) ↓ (x, y) insert Y [y]
(x − 1, y) → (x, y) delete X[x]
(x − 1, y − 1) ↘ (x, y) X[x] = Y [y]
= X
Y =
red cost = 1
black cost = 0
(m, n)
Edit distance d(X, Y ) ≡ shortest path length from (0, 0) to (m, n).
6 / 6

A different approach to edit distance [Myers 1986]
(0, 0)
D
A
R
V
A
T
R
A
V
A
D
(x, y − 1) ↓ (x, y) insert Y [y]
(x − 1, y) → (x, y) delete X[x]
(x − 1, y − 1) ↘ (x, y) X[x] = Y [y]
= X
Y =
red cost = 1
black cost = 0
(m, n)
0
1
2
3
4
5
Edit distance d(X, Y ) ≡ shortest path length from (0, 0) to (m, n).
Dijkstra’s shortest path alg. explores at most (2d + 1)(n + m)
vertices.
6 / 6

A different approach to edit distance [Myers 1986]
(0, 0)
D
A
R
V
A
T
R
A
V
A
D
(x, y − 1) ↓ (x, y) insert Y [y]
(x − 1, y) → (x, y) delete X[x]
(x − 1, y − 1) ↘ (x, y) X[x] = Y [y]
= X
Y =
red cost = 1
black cost = 0
(m, n)
0
1
2
3
4
5
Edit distance d(X, Y ) ≡ shortest path length from (0, 0) to (m, n).
Dijkstra’s shortest path alg. explores at most (2d + 1)(n + m)
vertices.
Running time: O(d(n + m)).
6 / 6