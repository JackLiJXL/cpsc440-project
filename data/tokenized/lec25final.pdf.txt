Suppose we use a linear structure (like an array, paper, etc.) to store a set of data (no duplicates).

Oper + a + b + c ? c ? b ? b ? c list a ab abc abc abc abc abc cost 1 2 3 3 2 2 3 = 16 list a ab abc abc cab bca bca cost 1 2 3 3 3 1 2 = 15 list a ab abc bac bac bca bca bca cost 1 2 3 1 3 1 1 2 = 13 list a ab abc abc acb abc bac cost 1 2 3 3 3 2 3 = 17

Oper + a + b + c ? c ? b ? b ? c list a ab abc abc abc abc abc cost 1 2 3 3 2 2 3 = 16 list a ab abc abc cab bca bca cost 1 2 3 3 3 1 2 = 15 list a ab abc bac bac bca bca bca cost 1 2 3 1 3 1 1 2 = 13 list a ab abc abc acb abc bac cost 1 2 3 3 3 2 3 = 17 Frequency Count Order items by #finds so far (decreasing). Move-to-front On every find( x ), move x to the front. Transpose On every find( x ), swap x one closer to the front.

Oper + a + b + c ? c ? b ? b ? c list a ab abc abc abc abc abc cost 1 2 3 3 2 2 3 = 16 MTF a ab abc abc cab bca bca FC 1 2 3 3 3 1 2 = 15 list a ab abc bac bac bca bca bca cost 1 2 3 1 3 1 1 2 = 13 TR a ab abc abc acb abc bac cost 1 2 3 3 3 2 3 = 17 Frequency Count Order items by #finds so far (decreasing). Move-to-front On every find( x ), move x to the front. Transpose On every find( x ), swap x one closer to the front.

orders items by total number of finds:

= number of find( x i ) ops.

Transpose is bad. Suppose the m operations are + x 3 + x 4 + x 5 . . . + x n + x 1 + x 2 ? x 1 ? x 2 ? x 1 ? x 2 . . . m − n operations so the list starts as x 3 x 4 . . . x n x 1 x 2 . cost(TR) = n i =1 i + ( m − n ) n ∼ mn for large m . cost(SOPT) = ni =1 i + 1 . 5 m ∼ 1 . 5 m for large m .

= number of find( x i ) ops.

When f i ≥ f j , the worst case for MTF is: ? x j ? x i ? x j ? x i . . . ? x j ? x i 2 f j find ops ? x i ? x i . . . ? x i f i − f j find ops So cost MTF ( i , j ) ≤ f j and cost MTF ( j , i ) ≤ f j . Thus, cost MTF ( i , j ) + cost MTF ( j , i ) ≤ 2 f j ≤ 2(cost SOPT ( i , j ) + cost SOPT ( j , i )) and so cost(MTF) ≤ 2cost(SOPT)

cost(MTF) ≤ 2cost(SOPT)

Proof: Let s = s 1 s 2 . . . s m be a sequence of items to find. OPT s i − 1 OPT 0 s i − 1 i s i − 1 i s i − 1 j s i OPT free-moves s i to ‘ after i th access. cost = j + k ‘ k ‘ s i k OPT 0 pay-moves s i to ‘ after i − 1 th access. cost = ( j + ( k − ‘ )) + ‘ j $ i − 1 i − 1 .

OPT 0 s i − 1 i s i − 1 ‘ s i k OPT 0 pay-moves s i to ‘ after i − 1 th access. cost = ( j + ( k − ‘ )) + ‘ j $ i − 1

Proof: Let ϕ ( i ) be the number of inversions between the list orders of MTF and OPT after find( s i ). a b c d e b d a e c φ ( i ) = 4 OPT MTF Let c i ( A ) be the cost of A on find( s i ). We first show that c i (MTF) + ϕ ( i ) − ϕ ( i − 1) ≤ 2 c i (OPT) − 1.

OPT s i s i MTF A B C D OPT s i s i MTF A B C ⇒ k matches from A to C ‘ matches from B to C φ ( i ) − φ ( i − 1) = k k ‘ k ‘ s i j j 1. c i (MTF) = k + ℓ + 1 2. ϕ ( i ) − ϕ ( i − 1) = k − ℓ 3. c i (OPT) = j + P ( i ) ≥ k + 1 + P ( i ) where P ( i ) is #paid swaps by OPT on i th find. 4. Each of P ( i ) paid swaps increases ϕ ( i ) by ≤ 1. So c i (MTF) + [ ϕ ( i ) − ϕ ( i − 1)] ≤ k + ℓ + 1 + [ k − ℓ + P ( i )]

Sum over all i to get: cost(MTF) + mi =1 [ ϕ ( i ) − ϕ ( i − 1)] = m i =1 ( c i (MTF) + [ ϕ ( i ) − ϕ ( i − 1)]) ≤ m i =1 (2 c i (OPT) − 1) = 2cost(OPT) − m ≤ 2cost(OPT) Since mi =1 [ ϕ ( i ) − ϕ ( i − 1)] = ϕ ( m ) − ϕ (0) ≥ 0, we’re done.