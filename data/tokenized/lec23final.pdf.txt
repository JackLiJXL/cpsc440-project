CPSC 420 Lecture 23: Today’s announcements:
▶ Examlet 3 on Mar 17 in class. Closed book & no notes
▶ Reading: Randomized Algorithms [by Motwani and Raghavan]
Today’s Plan
▶ Online Algorithms
▶ Hiring problem ✓
▶ Page replacement
▶ List Update
▶ Experts
1 / 11

Online Algorithms
For input sequence p1, p2, . . . , pn an online algorithm must
produce an output given p1, p2, . . . , pi for each i without seeing
pi+1, . . . , pn.
Page replacement in a cache
p1, . . . , pn is a sequence of page requests made by a program.
k is cache size (in pages).
At the ith page request, pi, the cache contains some k pages. If pi
is not in cache (page fault) some page must be evicted from
cache to make room for pi, then pi is added to the cache.
The cost of a page replacement algorithm A on sequence
p1, p2, . . . , pn is
fA(p1, p2, . . . , pn) = # faults A has on p1, p2, . . . , pn
Online algorithm must decide what page to evict without knowing
future requests.
2 / 11

Some paging algorithms
LRU (Least Recently Used) Evict page whose most recent
request occurred furthest in the past.
FIFO (First In First Out) Evict page that has been in cache
the longest.
LFU (Least Frequently Used) Evict page that has been
requested least often.
OPT (Optimal) Evict best∗ page knowing the future
requests.
3 / 11

Some paging algorithms
LRU (Least Recently Used) Evict page whose most recent
request occurred furthest in the past.
FIFO (First In First Out) Evict page that has been in cache
the longest.
LFU (Least Frequently Used) Evict page that has been
requested least often.
OPT (Optimal) Evict best∗ page knowing the future
requests.
∗ next request is furthest in the future
3 / 11

Paging algorithms: Example
A
B
C
D
B
A
B
C
D
A
B
requests
LRU
A
B
C
D
D
D
D
C
C
C
B
Y
A
B
C
C
A
A
A
D
D
D
Z
Y
A
B
B
B
B
B
B
A
A
*
*
*
*
*
*
*
*
*
9 faults
FIFO
A
B
C
D
D
A
B
C
D
A
B
Y
A
B
C
C
D
A
B
C
D
A
Z
Y
A
B
B
C
D
A
B
C
D
*
*
*
*
*
*
*
*
*
*
10 faults
LFU
A
B
C
D
D
D
D
C
C
A
A
Y
A
B
C
C
A
A
A
D
D
D
Z
Y
A
B
B
B
B
B
B
B
B
*
*
*
*
*
*
*
*
8 faults
OPT
A
B
C
D
D
D
D
D
D
D
B
Y
A
B
B
B
B
B
C
C
C
C
Z
Y
A
A
A
A
A
A
A
A
A
*
*
*
*
*
*
6 faults
4 / 11

Evaluating online algorithms
Which algorithm is best?
Worst case cost
n = max
p1..pn fLRU(p1..pn) = max
p1..pn fFIFO(p1..pn) = max
p1..pn fLFU(p1..pn)
Every online algorithm can be made to fault on every request.
Average case cost
E[fX(p1..pn)] = n(1 − k/m)
where m = # possible pages
Competitive analysis
How does online alg compare to best offline alg?
An online algorithm A is c-competitive if for all p1, p2, . . . , pn,
fA(p1..pn) ≤ c · fOPT(p1..pn) + b
for some constant b.
5 / 11

Lower Bound on Competitive Factor
Claim: If A is a deterministic online alg for paging then c ≥ k.
Proof: Idea: Find a sequence that is bad for A but good for OPT.
Suppose both A and OPT start with pages 1, 2, . . . , k in cache.
Request page a1 = k + 1
A evicts some page, call it a2
Request page a2
A evicts some page, call it a3
Request page a3
etc...
⇒ Online alg A faults on every request.
How many different pages are there?
6 / 11

Lower Bound on Competitive Factor
Claim: If A is a deterministic online alg for paging then c ≥ k.
Proof: Idea: Find a sequence that is bad for A but good for OPT.
Suppose both A and OPT start with pages 1, 2, . . . , k in cache.
Request page a1 = k + 1
A evicts some page, call it a2
Request page a2
A evicts some page, call it a3
Request page a3
etc...
⇒ Online alg A faults on every request.
How many different pages are there? k + 1
6 / 11

Lower Bound on Competitive Factor
How often does OPT fault?
a1 a2 a3 . . . aj aj+1 . . . requests
OPT
*
*
faults
Sub-claim: OPT faults at most once in k successive page requests
from this sequence
Proof.
OPT evicts the page p in cache that is requested furthest in the
future. Since there are only k + 1 different pages, the next k pages
requested can be kept in cache.
⇒ fA(a1, a2, . . . , an) ≥ k · fOPT(a1, a2, . . . , an)
7 / 11

LRU is k-competitive
Theorem
LRU is k-competitive
Proof.
Let p1, p2, . . . , pn be any sequence of page requests. Partition this
sequence into contiguous subsequences (phases) such that LRU
faults on the first page of the phase and the phase contains exactly
k different pages (or ≤ k in the last phase).
k = 3
A C D C C B C A D A A requests
LRU
* ? ?
*
*
*
faults
OPT
? ? ?
*
*
faults
phase 1
ph 2
ph 3
LRU faults ≤ k times per phase.
OPT must have the first page of a phase in cache at the beginning
of a phase. Since the remainder of the phase plus the first page of
the next phase consists of k different pages, OPT must fault at
least once during these requests.⇒ OPT faults ≥ #phases − 1
i
8 / 11

Any Marking Algorithm is k-competitive
Marking Algorithm MARK
0. Start with all k pages in cache unmarked
2.1. On page request p
if p not in cache then
3.
evict any unmarked page
(if no unmarked page, first unmark all k pages)
5.
bring p into cache
6.
mark p
A
B
C
D
B
A
B
C
D
A
B
MARK
•A
•A
•A
•D
•D
•D
•D
•C
•C
•C
•B
Y
•B
•B
B
•B
•B
•B
B
•D
•D
D
Z
Z
•C
C
C
•A
•A
A
A
•A
A
*
*
*
*
*
*
*
*
LRU
A
B
C
D
D
D
D
C
C
C
B
Y
A
B
C
C
A
A
A
D
D
D
Z
Y
A
B
B
B
B
B
B
A
A
*
*
*
*
*
*
*
*
*
9 / 11

Any Marking Algorithm is k-competitive
Marking Algorithm MARK
0. Start with all k pages in cache unmarked
2.1. On page request p
if p not in cache then
3.
evict any unmarked page
(if no unmarked page, first unmark all k pages)
5.
bring p into cache
6.
mark p
Proof.
Partition p1, p2, . . . , pn into phases, a maximal subsequence with k
distinct pages. (The first starts with p1.) Assume p1 is not in
cache. MARK faults ≤ k times per phase.
OPT must have the first page pi of a phase in cache at the
beginning of a phase. Since the remainder of the phase plus the
first page of the next phase consists of k different pages (different
from pi), OPT must fault at least once during these requests.
⇒ OPT faults ≥ #phases − 1 times.
10 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
OPT(1 2 3 4 1 2 3 4) = 2
11 / 11

Randomized online algorithm
Online Hide and Seek
Mouse hides in one of m hiding places.
Cat looks in one hiding place each time step.
If Cat finds Mouse, Mouse runs to another place.
Cost = #times Mouse moves
OPT = min #times future-knowing Mouse must move
1
2
3
4
OPT(1 2 3 4 1 2 3 4) = 2
OPT(1 2 1 1 3 4 1 2) = 1
11 / 11