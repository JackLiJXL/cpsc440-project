algorithm must decide what page to evict without knowing

(First In First Out) Evict page that has been in cache

(First In First Out) Evict page that has been in cache

next request is furthest in the future

A B C D B A B C D A B requests LRU A B C D D D D C C C B Y A B C C A A A D D D Z Y A B B B B B B A A * * * * * * * * * 9 faults FIFO A B C D D A B C D A B Y A B C C D A B C D A Z Y A B B C D A B C D * * * * * * * * * * 10 faults LFU A B C D D D D C C A A Y A B C C A A A D D D Z Y A B B B B B B B B * * * * * * * * 8 faults OPT A B C D D D D D D D B Y A B B B B B C C C C Z Y A A A A A A A A A * * * * * * 6 faults

= max p 1 .. p n f FIFO ( p 1 .. p n ) = max p 1 .. p n f LFU ( p 1 .. p n )

where m = # possible pages

⇒ Online alg A faults on every request.

How many different pages are there?

Claim: If A is a deterministic online alg for paging then c ≥ k . Proof: Idea: Find a sequence that is bad for A but good for OPT. Suppose both A and OPT start with pages 1 , 2 , . . . , k in cache.

⇒ Online alg A faults on every request.

How many different pages are there? k +

Let p 1 , p 2 , . . . , p n be any sequence of page requests. Partition this sequence into contiguous subsequences ( phases ) such that LRU faults on the first page of the phase and the phase contains exactly k different pages (or ≤ k in the last phase). k = 3 A C D C C B C A D A A requests LRU * ? ? * * * faults OPT ? ? ? * * faults phase 1 ph 2 ph 3 LRU faults ≤ k times per phase. OPT must have the first page of a phase in cache at the beginning of a phase. Since the remainder of the phase plus the first page of the next phase consists of k different pages, OPT must fault at

Marking Algorithm MARK 0. Start with all k pages in cache unmarked 1. On page request p 2. if p not in cache then 3. evict any unmarked page (if no unmarked page, first unmark all k pages) 5. bring p into cache 6. mark p A B C D B A B C D A B MARK • A • A • A • D • D • D • D • C • C • C • B Y • B • B B • B • B • B B • D • D D Z Z • C C C • A • A A A • A A * * * * * * * * LRU A B C D D D D C C C B Y A B C C A A A D D D Z Y A B B B B B B A A * * * * * * * * *

Marking Algorithm MARK 0. Start with all k pages in cache unmarked 1. On page request p 2. if p not in cache then 3. evict any unmarked page (if no unmarked page, first unmark all k pages) 5. bring p into cache 6. mark p Proof. Partition p 1 , p 2 , . . . , p n into phases , a maximal subsequence with distinct pages. (The first starts with p 1 .) Assume p 1 is not in cache. MARK faults ≤ k times per phase. OPT must have the first page p i of a phase in cache at the beginning of a phase. Since the remainder of the phase plus the first page of the next phase consists of k different pages (different from p i ), OPT must fault at least once during these requests.

0. Start with all k pages in cache unmarked 1. On page request p 2. if p not in cache then 3. evict any unmarked page (if no unmarked page, first unmark all k pages) 5. bring p into cache 6. mark p

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2 OPT(1 2 3 4 1 2 3 4) = 2

Mouse hides in one of m hiding places. Cat looks in one hiding place each time step. If Cat finds Mouse, Mouse runs to another place.

= min #times future-knowing Mouse must move

1 2 3 4 OPT(1 2 3 4 1 2 3 4) = 2 OPT(1 2 1 1 3 4 1 2) = 1