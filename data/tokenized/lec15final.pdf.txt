Construct an encoding (sequence of bits) c i for each character a i that the expected length of an encoded message is minimized.

Construct an encoding (sequence of bits) c i for each character a i that the expected length of an encoded message is minimized.

Idea Higher probability characters get shorter codes. A B C D E F G H .3 .2 .1 .1 .07 .03 .15 .05 minPQ: A .2 B .05 C .15 D .1 E .3 F .03 G .1 H .07

Construct an encoding (sequence of bits) c i for each character a i that the expected length of an encoded message is minimized.

Construct an encoding (sequence of bits) c i for each character a i that the expected length of an encoded message is minimized.

Higher probability characters get shorter codes. A B C D E F G H .3 .2 .1 .1 .07 .03 .15 .05 A .2 C .15 D .1 E .3 G .1 BFH .15 B F BF H BFH minPQ:

A .2 C .15 D .1 E .3 G .1 BFH .15 minPQ:

Construct an encoding (sequence of bits) c i for each character a i so that the expected length of an encoded message is minimized.

Idea Higher probability characters get shorter codes. A B C D E F G H .3 .2 .1 .1 .07 .03 .15 .05 B F BF C G D A E H BFH A: 11 B: 00000 C: 001 D: 101 E: 01 F: 00001 G: 100 H: 0001

A B C D not unique 0 010 01 10 not prefix-free 00 10 11 110 prefix-free 0 10 110 111 Decode 10101100010

A B C D not unique 0 010 01 10 not prefix-free 00 10 11 110 prefix-free 0 10 110 111

Decode 10101100010

No (unique) code can compress all inputs of length n .

Let c ( n ) be the number of phrases created from input of length n . Let α be the size of the alphabet of characters in input. Length of output is c ( n )(log 2 c ( n ) + log 2 α ) bits.

| A | AA | B | AB | BB | BA | ABB | BB ▶ Parse input into distinct phrases reading from left to right. Each phrase is the shortest string not already a phrase. The 0th phrase is ∅ . ▶ Output i c for each phrase w , where c is the last character of w and i is the index of phrase u where w = u ◦ c 1 2 3 4 5 6 7 8 A AA B AB BB BA ABB BB 0 A 1 A 0 B 1 B 3 B 3 A 4 B 3 00 10 001 011 0111 0110 1001 111 Let c ( n ) be the number of phrases created from input of length n . Let α be the size of the alphabet of characters in input. Length of output is c ( n )(log 2 c ( n ) + log 2 α ) bits.

How do we show LZ78 is a good compressor? Empirical Try it on lots of inputs. Worst case? Average case? Something else?

Maximize c ( n ) (make many small phrases)

A | B | AA | AB | BA | BB |

c ( n ) ❶ ≤ n k k − 1 + n − n k k + 1 ≤ n k − 1 ❷ ≤ n log 2 c ( n ) − 3 since ❶ to maximize c ( n ), the first n k input bits make ≤ c ( n k ) phrases and the rest make phrases of length k + 1, and ❷ c ( n ) ≤ c ( n k +1 ) = 2 k +2 − 2.

As we saw, LZ78 compresses inputs of length n to about

If LZ78 breaks x into distinct phrases x = y 1 y 2 . . . y c ( n ) then Q ( x ) = c ( n ) j =1 Q ( y j ) = ℓ | y i | = ℓ Q ( y i ) Let c ℓ be the number of phrases of length ℓ . Since the y i ’s with length ℓ are distinct v,
 | y i | = ℓ Q ( y i ) ≤ 1 and | y | = ℓ Q ( y i ) ≤ 1 c ℓ c ℓ take log sum over ℓ − log 2 Q ( x ) ≥ ℓ c ℓ log 2 c ℓ